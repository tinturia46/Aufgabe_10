/* Generated by JSIL v0.8.2 build 17617. See http://jsil.org/ for more information. */ 
'use strict';
var $asm07 = JSIL.DeclareAssembly("Fusee.Math.Core, Version=0.5.0.0, Culture=neutral, PublicKeyToken=null");

JSIL.DeclareNamespace("Fusee");
JSIL.DeclareNamespace("Fusee.Math");
JSIL.DeclareNamespace("Fusee.Math.Core");
/* struct Fusee.Math.Core.AABBf */ 

(function AABBf$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.Fusee.Math.Core.float3)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm07.Fusee.Math.Core.float4x4)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize(System.Array.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm15.System.Int32)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm15.System.Boolean)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [$asm07.TypeRef("Fusee.Math.Core.float3"), $asm15.TypeRef("System.Single")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single")
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [$asm07.TypeRef("Fusee.Math.Core.float4x4"), $asm07.TypeRef("Fusee.Math.Core.float3")]))) ();
  };


  function AABBf__ctor (min_, max_) {
    this.min = min_.MemberwiseClone();
    this.max = max_.MemberwiseClone();
  }; 

  function AABBf_get_Center () {
    return $S00().CallStatic($T00(), "op_Multiply", null, $T00().op_Addition(this.max.MemberwiseClone(), this.min).MemberwiseClone(), 0.5);
  }; 

  function AABBf_get_Size () {
    return $T00().op_Subtraction(this.max.MemberwiseClone(), this.min);
  }; 

  function AABBf_op_Multiply (m, box) {
    var ret = new $thisType();
    var cube = JSIL.Array.New($T00(), [$S01().Construct(box.min.x, box.min.y, box.min.z), $S01().Construct(box.min.x, box.min.y, box.max.z), $S01().Construct(box.min.x, box.max.y, box.min.z), $S01().Construct(box.min.x, box.max.y, box.max.z), $S01().Construct(box.max.x, box.min.y, box.min.z), $S01().Construct(box.max.x, box.min.y, box.max.z), $S01().Construct(box.max.x, box.max.y, box.min.z), $S01().Construct(box.max.x, box.max.y, box.max.z)]);

    for (var i = 0; i < 8; i = ((i + 1) | 0)) {
      cube[i] = $S02().CallStatic($T01(), "op_Multiply", null, m, cube[i]);
    }
    ret.min = cube[0].MemberwiseClone();
    ret.max = cube[0].MemberwiseClone();

    for (var j = 1; j < 8; j = ((j + 1) | 0)) {
      var flag = +cube[j].x < +ret.min.x;
      if (flag) {
        ret.min.x = +cube[j].x;
      }
      var flag2 = +cube[j].y < +ret.min.y;
      if (flag2) {
        ret.min.y = +cube[j].y;
      }
      var flag3 = +cube[j].z < +ret.min.z;
      if (flag3) {
        ret.min.z = +cube[j].z;
      }
      var flag4 = +cube[j].x > +ret.max.x;
      if (flag4) {
        ret.max.x = +cube[j].x;
      }
      var flag5 = +cube[j].y > +ret.max.y;
      if (flag5) {
        ret.max.y = +cube[j].y;
      }
      var flag6 = +cube[j].z > +ret.max.z;
      if (flag6) {
        ret.max.z = +cube[j].z;
      }
    }
    return ret;
  }; 

  function AABBf_Union (a, b) {
    var ret = new $thisType();
    ret.min.x = +(
      (+a.min.x < +b.min.x)
         ? a.min.x
         : b.min.x)
    ;
    ret.min.y = +(
      (+a.min.y < +b.min.y)
         ? a.min.y
         : b.min.y)
    ;
    ret.min.z = +(
      (+a.min.z < +b.min.z)
         ? a.min.z
         : b.min.z)
    ;
    ret.max.x = +(
      (+a.max.x > +b.max.x)
         ? a.max.x
         : b.max.x)
    ;
    ret.max.y = +(
      (+a.max.y > +b.max.y)
         ? a.max.y
         : b.max.y)
    ;
    ret.max.z = +(
      (+a.max.z > +b.max.z)
         ? a.max.z
         : b.max.z)
    ;
    return ret;
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.Core.AABBf", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 2, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("Fusee.Math.Core.float3"), $asm07.TypeRef("Fusee.Math.Core.float3")]), 
      AABBf__ctor
    );

    $.Method({Static:false, Public:true }, "get_Center", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float3")), 
      AABBf_get_Center
    );

    $.Method({Static:false, Public:true }, "get_Size", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float3")), 
      AABBf_get_Size
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$asm07.TypeRef("Fusee.Math.Core.float4x4"), $.Type]), 
      AABBf_op_Multiply
    );

    $.Method({Static:true , Public:true }, "Union", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      AABBf_Union
    );

    $.Field({Static:false, Public:true }, "min", $asm07.TypeRef("Fusee.Math.Core.float3"))
      .Attribute($asm0F.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [1]; });

    $.Field({Static:false, Public:true }, "max", $asm07.TypeRef("Fusee.Math.Core.float3"))
      .Attribute($asm0F.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [2]; });

    $.Property({Static:false, Public:true }, "Center", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "Size", $asm07.TypeRef("Fusee.Math.Core.float3"));


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("ProtoBuf.ProtoContractAttribute"));

})();

/* class Fusee.Math.Core.Curve */ 

(function Curve$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm15.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm07.Fusee.Math.Core.Curve_$lCalcAdaptivePolyline$gd__4)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm15.System.Single)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.Fusee.Math.Core.Curve_$lCalcAdaptivePolyline$gd__5)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.Fusee.Math.Core.Curve_$lCalcUniformPolyline$gd__3)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm15.System.Collections.Generic.IList$b1.Of($asm07.Fusee.Math.Core.CurvePart))) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm07.Fusee.Math.Core.CurvePart)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm12.System.Linq.Enumerable)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerable$b1.Of($asm07.Fusee.Math.Core.Curve))) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm15.System.Collections.Generic.List$b1.Of($asm07.Fusee.Math.Core.CurvePart))) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerator$b1.Of($asm07.Fusee.Math.Core.Curve))) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm15.System.Collections.IEnumerator)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerator$b1.Of($asm07.Fusee.Math.Core.CurvePart))) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerable$b1.Of($asm07.Fusee.Math.Core.CurvePart))) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm15.System.Collections.Generic.ICollection$b1.Of($asm07.Fusee.Math.Core.CurvePart))) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm15.System.IDisposable)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm15.TypeRef("System.Collections.Generic.List`1", [$asm07.TypeRef("Fusee.Math.Core.CurvePart")]), null))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerable$b1.Of($asm07.Fusee.Math.Core.Curve).GetEnumerator)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm15.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerator$b1.Of($asm07.Fusee.Math.Core.Curve).get_Current)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerable$b1.Of($asm07.Fusee.Math.Core.CurvePart).GetEnumerator)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerator$b1.Of($asm07.Fusee.Math.Core.CurvePart).get_Current)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm15.System.Collections.Generic.ICollection$b1.Of($asm07.Fusee.Math.Core.CurvePart).Add)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm15.System.IDisposable.Dispose)) ();
  };


  function Curve__ctor () {
  }; 

  function Curve_CalcAdaptivePolyline$00 (angle) {
    var expr_07 = new ($T01())(-2);
    expr_07.$l$g4__this = this;
    expr_07.$l$g3__angle = (angle | 0);
    return expr_07;
  }; 

  function Curve_CalcAdaptivePolyline$01 (acreage) {
    var expr_07 = new ($T03())(-2);
    expr_07.$l$g4__this = this;
    expr_07.$l$g3__acreage = +acreage;
    return expr_07;
  }; 

  function Curve_CalcUniformPolyline (subdiv) {
    var expr_07 = new ($T04())(-2);
    expr_07.$l$g4__this = this;
    expr_07.$l$g3__subdiv = (subdiv | 0);
    return expr_07;
  }; 

  function Curve_CombineCurves$02 (a, b) {
    var expr_06 = new $thisType();
    expr_06.CurveParts = $T05().$Cast($T07().Concat$b1($T06())(a.CurveParts, b.CurveParts));
    return expr_06;
  }; 

  function Curve_CombineCurves$03 (curves) {
    var expr_06 = new $thisType();
    expr_06.CurveParts = $S00().Construct();
    var combinedCurve = expr_06;
    var enumerator = $IM00().Call(curves, null);
    try {

      while ($IM01().Call(enumerator, null)) {
        var curve = $IM02().Call(enumerator, null);
        var enumerator2 = $IM03().Call(curve.CurveParts, null);
        try {

          while ($IM01().Call(enumerator2, null)) {
            var part = $IM04().Call(enumerator2, null);
            $IM05().Call(combinedCurve.CurveParts, null, part);
          }
        } finally {
          if (enumerator2 !== null) {
            $IM06().Call(enumerator2, null);
          }
        }
      }
    } finally {
      if (enumerator !== null) {
        $IM06().Call(enumerator, null);
      }
    }
    return combinedCurve;
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.Object"), 
      Name: "Fusee.Math.Core.Curve", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      Curve__ctor
    );

    $.Method({Static:false, Public:true }, "CalcAdaptivePolyline", 
      new JSIL.MethodSignature($asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), [$.Int32]), 
      Curve_CalcAdaptivePolyline$00
    );

    $.Method({Static:false, Public:true }, "CalcAdaptivePolyline", 
      new JSIL.MethodSignature($asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), [$.Single]), 
      Curve_CalcAdaptivePolyline$01
    );

    $.Method({Static:false, Public:true }, "CalcUniformPolyline", 
      new JSIL.MethodSignature($asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), [$.Int32]), 
      Curve_CalcUniformPolyline
    );

    $.Method({Static:true , Public:true }, "CombineCurves", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      Curve_CombineCurves$02
    );

    $.Method({Static:true , Public:true }, "CombineCurves", 
      new JSIL.MethodSignature($.Type, [$asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$.Type])]), 
      Curve_CombineCurves$03
    );

    $.Field({Static:false, Public:true }, "CurveParts", $asm15.TypeRef("System.Collections.Generic.IList`1", [$asm07.TypeRef("Fusee.Math.Core.CurvePart")]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Math.Core.Curve+<CalcUniformPolyline>d__3 */ 

(function $lCalcUniformPolyline$gd__3$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm15.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm15.System.Threading.Thread)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerator$b1.Of($asm07.Fusee.Math.Core.CurvePart))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm15.System.IDisposable)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerator$b1.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm15.System.Exception)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerable$b1.Of($asm07.Fusee.Math.Core.CurvePart))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm15.System.Boolean)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm15.System.Collections.IEnumerator)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerable$b1.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm07.Fusee.Math.Core.CurvePart)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm15.System.NotSupportedException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm15.TypeRef("System.NotSupportedException"), null))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm15.System.IDisposable.Dispose)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerable$b1.Of($asm07.Fusee.Math.Core.CurvePart).GetEnumerator)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm15.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerator$b1.Of($asm07.Fusee.Math.Core.float3).get_Current)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerator$b1.Of($asm07.Fusee.Math.Core.CurvePart).get_Current)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerable$b1.Of($asm07.Fusee.Math.Core.float3).GetEnumerator)) ();
  };


  function $lCalcUniformPolyline$gd__3__ctor ($l$g1__state) {
    this.$l$g1__state = ($l$g1__state | 0);
    this.$l$gl__initialThreadId = ($T01().get_CurrentThread().get_ManagedThreadId() | 0);
  }; 

  function $lCalcUniformPolyline$gd__3_$l$gm__Finally1 () {
    this.$l$g1__state = -1;
    if (this.$l$gs__1 !== null) {
      $IM00().Call(this.$l$gs__1, null);
    }
  }; 

  function $lCalcUniformPolyline$gd__3_$l$gm__Finally2 () {
    this.$l$g1__state = -3;
    if (this.$l$gs__3 !== null) {
      $IM00().Call(this.$l$gs__3, null);
    }
  }; 

  function $lCalcUniformPolyline$gd__3_MoveNext ($exception) {
    try {

      var $label0 = 0;
    $labelgroup0: 
      while (true) {
        switch ($label0) {
          case 0: /* $entry0 */ 
            var num = (this.$l$g1__state | 0);
            if (num === 0) {
              this.$l$g1__state = -1;
              this.$l$gs__1 = $IM01().Call(this.$l$g4__this.CurveParts, null);
              this.$l$g1__state = -3;
              $label0 = 2 /* goto IL_DA */ ;
              continue $labelgroup0;
            }
            if (num !== 1) {
              var result = false;
              return result;
            }
            this.$l$g1__state = -4;

            $label0 = 1 /* goto IL_B7 */ ;
            continue $labelgroup0;
          case 1: /* IL_B7 */ 
            if ($IM02().Call(this.$l$gs__3, null)) {
              this.$lvert$g5__4 = $IM03().Call(this.$l$gs__3, null).MemberwiseClone();
              this.$l$g2__current = this.$lvert$g5__4.MemberwiseClone();
              this.$l$g1__state = 1;
              result = true;
              return result;
            }
            this.$l$gm__Finally2();
            this.$l$gs__3 = null;
            this.$lpart$g5__2 = null;

            $label0 = 2 /* goto IL_DA */ ;
            continue $labelgroup0;
          case 2: /* IL_DA */ 
            if ($IM02().Call(this.$l$gs__1, null)) {
              this.$lpart$g5__2 = $IM04().Call(this.$l$gs__1, null);
              this.$l$gs__3 = $IM05().Call((this.$lpart$g5__2).CalcUniformPolyline(this.subdiv), null);
              this.$l$g1__state = -4;
              $label0 = 1 /* goto IL_B7 */ ;
              continue $labelgroup0;
            }
            this.$l$gm__Finally1();
            this.$l$gs__1 = null;
            result = false;

            break $labelgroup0;
        }
      }
    } catch ($exception) {
      this.System_IDisposable_Dispose();
      throw $exception;
    }
    return result;
  }; 

  function $lCalcUniformPolyline$gd__3_System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator () {
    if (!(((this.$l$g1__state | 0) !== -2) || ((this.$l$gl__initialThreadId | 0) !== ($T01().get_CurrentThread().get_ManagedThreadId() | 0)))) {
      this.$l$g1__state = 0;
      var $lCalcUniformPolyline$gd__ = this;
    } else {
      $lCalcUniformPolyline$gd__ = new $thisType(0);
      $lCalcUniformPolyline$gd__.$l$g4__this = this.$l$g4__this;
    }
    $lCalcUniformPolyline$gd__.subdiv = (this.$l$g3__subdiv | 0);
    return $lCalcUniformPolyline$gd__;
  }; 

  function $lCalcUniformPolyline$gd__3_System_Collections_Generic_IEnumerator$lFusee_Math_Core_float3$g_get_Current () {
    return this.$l$g2__current;
  }; 

  function $lCalcUniformPolyline$gd__3_System_Collections_IEnumerable_GetEnumerator () {
    return this.System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator();
  }; 

  function $lCalcUniformPolyline$gd__3_System_Collections_IEnumerator_get_Current () {
    return this.$l$g2__current;
  }; 

  function $lCalcUniformPolyline$gd__3_System_Collections_IEnumerator_Reset () {
    throw $S00().Construct();
  }; 

  function $lCalcUniformPolyline$gd__3_System_IDisposable_Dispose () {
    var num = (this.$l$g1__state | 0);
    if ((((num - -4) | 0) <= 1) || (num === 1)) {
      try {
        if ((num === -4) || (num === 1)) {
          try {
          } finally {
            this.$l$gm__Finally2();
          }
        }
      } finally {
        this.$l$gm__Finally1();
      }
    }
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.Object"), 
      Name: "Fusee.Math.Core.Curve+<CalcUniformPolyline>d__3", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Int32), 
      $lCalcUniformPolyline$gd__3__ctor
    )
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false}, "$l$gm__Finally1", 
      JSIL.MethodSignature.Void, 
      $lCalcUniformPolyline$gd__3_$l$gm__Finally1
    );

    $.Method({Static:false, Public:false}, "$l$gm__Finally2", 
      JSIL.MethodSignature.Void, 
      $lCalcUniformPolyline$gd__3_$l$gm__Finally2
    );

    $.Method({Static:false, Public:false, Virtual:true }, "MoveNext", 
      JSIL.MethodSignature.Return($.Boolean), 
      $lCalcUniformPolyline$gd__3_MoveNext
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "MoveNext");

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerable$lFusee.Math.Core.float3$g.GetEnumerator", 
      JSIL.MethodSignature.Return($asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")])), 
      $lCalcUniformPolyline$gd__3_System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator
    )
      .Overrides($asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), "GetEnumerator")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lFusee.Math.Core.float3$g.get_Current", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float3")), 
      $lCalcUniformPolyline$gd__3_System_Collections_Generic_IEnumerator$lFusee_Math_Core_float3$g_get_Current
    )
      .Overrides($asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), "get_Current")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerable.GetEnumerator", 
      JSIL.MethodSignature.Return($asm15.TypeRef("System.Collections.IEnumerator")), 
      $lCalcUniformPolyline$gd__3_System_Collections_IEnumerable_GetEnumerator
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerable"), "GetEnumerator")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.get_Current", 
      JSIL.MethodSignature.Return($.Object), 
      $lCalcUniformPolyline$gd__3_System_Collections_IEnumerator_get_Current
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "get_Current")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Reset", 
      JSIL.MethodSignature.Void, 
      $lCalcUniformPolyline$gd__3_System_Collections_IEnumerator_Reset
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "Reset")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.IDisposable.Dispose", 
      JSIL.MethodSignature.Void, 
      $lCalcUniformPolyline$gd__3_System_IDisposable_Dispose
    )
      .Overrides($asm15.TypeRef("System.IDisposable"), "Dispose")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Field({Static:false, Public:false}, "$l$g1__state", $.Int32);

    $.Field({Static:false, Public:false}, "$l$g2__current", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:false}, "$l$gl__initialThreadId", $.Int32);

    $.Field({Static:false, Public:false}, "subdiv", $.Int32);

    $.Field({Static:false, Public:true }, "$l$g3__subdiv", $.Int32);

    $.Field({Static:false, Public:true }, "$l$g4__this", $asm07.TypeRef("Fusee.Math.Core.Curve"));

    $.Field({Static:false, Public:false}, "$l$gs__1", $asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.CurvePart")]));

    $.Field({Static:false, Public:false}, "$lpart$g5__2", $asm07.TypeRef("Fusee.Math.Core.CurvePart"));

    $.Field({Static:false, Public:false}, "$l$gs__3", $asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]));

    $.Field({Static:false, Public:false}, "$lvert$g5__4", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lFusee.Math.Core.float3$g.Current", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Current", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
      /* 1 */ $asm15.TypeRef("System.Collections.IEnumerable"), 
      /* 2 */ $asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
      /* 3 */ $asm15.TypeRef("System.Collections.IEnumerator"), 
      /* 4 */ $asm15.TypeRef("System.IDisposable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class Fusee.Math.Core.Curve+<CalcAdaptivePolyline>d__4 */ 

(function $lCalcAdaptivePolyline$gd__4$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm15.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm15.System.Threading.Thread)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerator$b1.Of($asm07.Fusee.Math.Core.CurvePart))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm15.System.IDisposable)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerator$b1.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm15.System.Exception)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerable$b1.Of($asm07.Fusee.Math.Core.CurvePart))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm15.System.Boolean)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm15.System.Collections.IEnumerator)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerable$b1.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm07.Fusee.Math.Core.CurvePart)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm15.System.NotSupportedException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), [$asm15.TypeRef("System.Int32")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm15.TypeRef("System.NotSupportedException"), null))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm15.System.IDisposable.Dispose)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerable$b1.Of($asm07.Fusee.Math.Core.CurvePart).GetEnumerator)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm15.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerator$b1.Of($asm07.Fusee.Math.Core.float3).get_Current)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerator$b1.Of($asm07.Fusee.Math.Core.CurvePart).get_Current)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerable$b1.Of($asm07.Fusee.Math.Core.float3).GetEnumerator)) ();
  };


  function $lCalcAdaptivePolyline$gd__4__ctor ($l$g1__state) {
    this.$l$g1__state = ($l$g1__state | 0);
    this.$l$gl__initialThreadId = ($T01().get_CurrentThread().get_ManagedThreadId() | 0);
  }; 

  function $lCalcAdaptivePolyline$gd__4_$l$gm__Finally1 () {
    this.$l$g1__state = -1;
    if (this.$l$gs__1 !== null) {
      $IM00().Call(this.$l$gs__1, null);
    }
  }; 

  function $lCalcAdaptivePolyline$gd__4_$l$gm__Finally2 () {
    this.$l$g1__state = -3;
    if (this.$l$gs__3 !== null) {
      $IM00().Call(this.$l$gs__3, null);
    }
  }; 

  function $lCalcAdaptivePolyline$gd__4_MoveNext ($exception) {
    try {

      var $label0 = 0;
    $labelgroup0: 
      while (true) {
        switch ($label0) {
          case 0: /* $entry0 */ 
            var num = (this.$l$g1__state | 0);
            if (num === 0) {
              this.$l$g1__state = -1;
              this.$l$gs__1 = $IM01().Call(this.$l$g4__this.CurveParts, null);
              this.$l$g1__state = -3;
              $label0 = 2 /* goto IL_DA */ ;
              continue $labelgroup0;
            }
            if (num !== 1) {
              var result = false;
              return result;
            }
            this.$l$g1__state = -4;

            $label0 = 1 /* goto IL_B7 */ ;
            continue $labelgroup0;
          case 1: /* IL_B7 */ 
            if ($IM02().Call(this.$l$gs__3, null)) {
              this.$lvert$g5__4 = $IM03().Call(this.$l$gs__3, null).MemberwiseClone();
              this.$l$g2__current = this.$lvert$g5__4.MemberwiseClone();
              this.$l$g1__state = 1;
              result = true;
              return result;
            }
            this.$l$gm__Finally2();
            this.$l$gs__3 = null;
            this.$lpart$g5__2 = null;

            $label0 = 2 /* goto IL_DA */ ;
            continue $labelgroup0;
          case 2: /* IL_DA */ 
            if ($IM02().Call(this.$l$gs__1, null)) {
              this.$lpart$g5__2 = $IM04().Call(this.$l$gs__1, null);
              this.$l$gs__3 = $IM05().Call($S00().CallVirtual("CalcAdaptivePolyline", null, this.$lpart$g5__2, this.angle), null);
              this.$l$g1__state = -4;
              $label0 = 1 /* goto IL_B7 */ ;
              continue $labelgroup0;
            }
            this.$l$gm__Finally1();
            this.$l$gs__1 = null;
            result = false;

            break $labelgroup0;
        }
      }
    } catch ($exception) {
      this.System_IDisposable_Dispose();
      throw $exception;
    }
    return result;
  }; 

  function $lCalcAdaptivePolyline$gd__4_System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator () {
    if (!(((this.$l$g1__state | 0) !== -2) || ((this.$l$gl__initialThreadId | 0) !== ($T01().get_CurrentThread().get_ManagedThreadId() | 0)))) {
      this.$l$g1__state = 0;
      var $lCalcAdaptivePolyline$gd__ = this;
    } else {
      $lCalcAdaptivePolyline$gd__ = new $thisType(0);
      $lCalcAdaptivePolyline$gd__.$l$g4__this = this.$l$g4__this;
    }
    $lCalcAdaptivePolyline$gd__.angle = (this.$l$g3__angle | 0);
    return $lCalcAdaptivePolyline$gd__;
  }; 

  function $lCalcAdaptivePolyline$gd__4_System_Collections_Generic_IEnumerator$lFusee_Math_Core_float3$g_get_Current () {
    return this.$l$g2__current;
  }; 

  function $lCalcAdaptivePolyline$gd__4_System_Collections_IEnumerable_GetEnumerator () {
    return this.System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator();
  }; 

  function $lCalcAdaptivePolyline$gd__4_System_Collections_IEnumerator_get_Current () {
    return this.$l$g2__current;
  }; 

  function $lCalcAdaptivePolyline$gd__4_System_Collections_IEnumerator_Reset () {
    throw $S01().Construct();
  }; 

  function $lCalcAdaptivePolyline$gd__4_System_IDisposable_Dispose () {
    var num = (this.$l$g1__state | 0);
    if ((((num - -4) | 0) <= 1) || (num === 1)) {
      try {
        if ((num === -4) || (num === 1)) {
          try {
          } finally {
            this.$l$gm__Finally2();
          }
        }
      } finally {
        this.$l$gm__Finally1();
      }
    }
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.Object"), 
      Name: "Fusee.Math.Core.Curve+<CalcAdaptivePolyline>d__4", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Int32), 
      $lCalcAdaptivePolyline$gd__4__ctor
    )
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false}, "$l$gm__Finally1", 
      JSIL.MethodSignature.Void, 
      $lCalcAdaptivePolyline$gd__4_$l$gm__Finally1
    );

    $.Method({Static:false, Public:false}, "$l$gm__Finally2", 
      JSIL.MethodSignature.Void, 
      $lCalcAdaptivePolyline$gd__4_$l$gm__Finally2
    );

    $.Method({Static:false, Public:false, Virtual:true }, "MoveNext", 
      JSIL.MethodSignature.Return($.Boolean), 
      $lCalcAdaptivePolyline$gd__4_MoveNext
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "MoveNext");

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerable$lFusee.Math.Core.float3$g.GetEnumerator", 
      JSIL.MethodSignature.Return($asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")])), 
      $lCalcAdaptivePolyline$gd__4_System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator
    )
      .Overrides($asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), "GetEnumerator")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lFusee.Math.Core.float3$g.get_Current", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float3")), 
      $lCalcAdaptivePolyline$gd__4_System_Collections_Generic_IEnumerator$lFusee_Math_Core_float3$g_get_Current
    )
      .Overrides($asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), "get_Current")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerable.GetEnumerator", 
      JSIL.MethodSignature.Return($asm15.TypeRef("System.Collections.IEnumerator")), 
      $lCalcAdaptivePolyline$gd__4_System_Collections_IEnumerable_GetEnumerator
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerable"), "GetEnumerator")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.get_Current", 
      JSIL.MethodSignature.Return($.Object), 
      $lCalcAdaptivePolyline$gd__4_System_Collections_IEnumerator_get_Current
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "get_Current")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Reset", 
      JSIL.MethodSignature.Void, 
      $lCalcAdaptivePolyline$gd__4_System_Collections_IEnumerator_Reset
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "Reset")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.IDisposable.Dispose", 
      JSIL.MethodSignature.Void, 
      $lCalcAdaptivePolyline$gd__4_System_IDisposable_Dispose
    )
      .Overrides($asm15.TypeRef("System.IDisposable"), "Dispose")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Field({Static:false, Public:false}, "$l$g1__state", $.Int32);

    $.Field({Static:false, Public:false}, "$l$g2__current", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:false}, "$l$gl__initialThreadId", $.Int32);

    $.Field({Static:false, Public:false}, "angle", $.Int32);

    $.Field({Static:false, Public:true }, "$l$g3__angle", $.Int32);

    $.Field({Static:false, Public:true }, "$l$g4__this", $asm07.TypeRef("Fusee.Math.Core.Curve"));

    $.Field({Static:false, Public:false}, "$l$gs__1", $asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.CurvePart")]));

    $.Field({Static:false, Public:false}, "$lpart$g5__2", $asm07.TypeRef("Fusee.Math.Core.CurvePart"));

    $.Field({Static:false, Public:false}, "$l$gs__3", $asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]));

    $.Field({Static:false, Public:false}, "$lvert$g5__4", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lFusee.Math.Core.float3$g.Current", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Current", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
      /* 1 */ $asm15.TypeRef("System.Collections.IEnumerable"), 
      /* 2 */ $asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
      /* 3 */ $asm15.TypeRef("System.Collections.IEnumerator"), 
      /* 4 */ $asm15.TypeRef("System.IDisposable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class Fusee.Math.Core.Curve+<CalcAdaptivePolyline>d__5 */ 

(function $lCalcAdaptivePolyline$gd__5$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm15.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm15.System.Threading.Thread)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerator$b1.Of($asm07.Fusee.Math.Core.CurvePart))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm15.System.IDisposable)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerator$b1.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm15.System.Exception)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerable$b1.Of($asm07.Fusee.Math.Core.CurvePart))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm15.System.Boolean)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm15.System.Collections.IEnumerator)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerable$b1.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm07.Fusee.Math.Core.CurvePart)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm15.System.NotSupportedException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), [$asm15.TypeRef("System.Single")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm15.TypeRef("System.NotSupportedException"), null))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm15.System.IDisposable.Dispose)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerable$b1.Of($asm07.Fusee.Math.Core.CurvePart).GetEnumerator)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm15.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerator$b1.Of($asm07.Fusee.Math.Core.float3).get_Current)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerator$b1.Of($asm07.Fusee.Math.Core.CurvePart).get_Current)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerable$b1.Of($asm07.Fusee.Math.Core.float3).GetEnumerator)) ();
  };


  function $lCalcAdaptivePolyline$gd__5__ctor ($l$g1__state) {
    this.$l$g1__state = ($l$g1__state | 0);
    this.$l$gl__initialThreadId = ($T01().get_CurrentThread().get_ManagedThreadId() | 0);
  }; 

  function $lCalcAdaptivePolyline$gd__5_$l$gm__Finally1 () {
    this.$l$g1__state = -1;
    if (this.$l$gs__1 !== null) {
      $IM00().Call(this.$l$gs__1, null);
    }
  }; 

  function $lCalcAdaptivePolyline$gd__5_$l$gm__Finally2 () {
    this.$l$g1__state = -3;
    if (this.$l$gs__3 !== null) {
      $IM00().Call(this.$l$gs__3, null);
    }
  }; 

  function $lCalcAdaptivePolyline$gd__5_MoveNext ($exception) {
    try {

      var $label0 = 0;
    $labelgroup0: 
      while (true) {
        switch ($label0) {
          case 0: /* $entry0 */ 
            var num = (this.$l$g1__state | 0);
            if (num === 0) {
              this.$l$g1__state = -1;
              this.$l$gs__1 = $IM01().Call(this.$l$g4__this.CurveParts, null);
              this.$l$g1__state = -3;
              $label0 = 2 /* goto IL_DA */ ;
              continue $labelgroup0;
            }
            if (num !== 1) {
              var result = false;
              return result;
            }
            this.$l$g1__state = -4;

            $label0 = 1 /* goto IL_B7 */ ;
            continue $labelgroup0;
          case 1: /* IL_B7 */ 
            if ($IM02().Call(this.$l$gs__3, null)) {
              this.$lvert$g5__4 = $IM03().Call(this.$l$gs__3, null).MemberwiseClone();
              this.$l$g2__current = this.$lvert$g5__4.MemberwiseClone();
              this.$l$g1__state = 1;
              result = true;
              return result;
            }
            this.$l$gm__Finally2();
            this.$l$gs__3 = null;
            this.$lpart$g5__2 = null;

            $label0 = 2 /* goto IL_DA */ ;
            continue $labelgroup0;
          case 2: /* IL_DA */ 
            if ($IM02().Call(this.$l$gs__1, null)) {
              this.$lpart$g5__2 = $IM04().Call(this.$l$gs__1, null);
              this.$l$gs__3 = $IM05().Call($S00().CallVirtual("CalcAdaptivePolyline", null, this.$lpart$g5__2, this.acreage), null);
              this.$l$g1__state = -4;
              $label0 = 1 /* goto IL_B7 */ ;
              continue $labelgroup0;
            }
            this.$l$gm__Finally1();
            this.$l$gs__1 = null;
            result = false;

            break $labelgroup0;
        }
      }
    } catch ($exception) {
      this.System_IDisposable_Dispose();
      throw $exception;
    }
    return result;
  }; 

  function $lCalcAdaptivePolyline$gd__5_System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator () {
    if (!(((this.$l$g1__state | 0) !== -2) || ((this.$l$gl__initialThreadId | 0) !== ($T01().get_CurrentThread().get_ManagedThreadId() | 0)))) {
      this.$l$g1__state = 0;
      var $lCalcAdaptivePolyline$gd__ = this;
    } else {
      $lCalcAdaptivePolyline$gd__ = new $thisType(0);
      $lCalcAdaptivePolyline$gd__.$l$g4__this = this.$l$g4__this;
    }
    $lCalcAdaptivePolyline$gd__.acreage = +this.$l$g3__acreage;
    return $lCalcAdaptivePolyline$gd__;
  }; 

  function $lCalcAdaptivePolyline$gd__5_System_Collections_Generic_IEnumerator$lFusee_Math_Core_float3$g_get_Current () {
    return this.$l$g2__current;
  }; 

  function $lCalcAdaptivePolyline$gd__5_System_Collections_IEnumerable_GetEnumerator () {
    return this.System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator();
  }; 

  function $lCalcAdaptivePolyline$gd__5_System_Collections_IEnumerator_get_Current () {
    return this.$l$g2__current;
  }; 

  function $lCalcAdaptivePolyline$gd__5_System_Collections_IEnumerator_Reset () {
    throw $S01().Construct();
  }; 

  function $lCalcAdaptivePolyline$gd__5_System_IDisposable_Dispose () {
    var num = (this.$l$g1__state | 0);
    if ((((num - -4) | 0) <= 1) || (num === 1)) {
      try {
        if ((num === -4) || (num === 1)) {
          try {
          } finally {
            this.$l$gm__Finally2();
          }
        }
      } finally {
        this.$l$gm__Finally1();
      }
    }
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.Object"), 
      Name: "Fusee.Math.Core.Curve+<CalcAdaptivePolyline>d__5", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Int32), 
      $lCalcAdaptivePolyline$gd__5__ctor
    )
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false}, "$l$gm__Finally1", 
      JSIL.MethodSignature.Void, 
      $lCalcAdaptivePolyline$gd__5_$l$gm__Finally1
    );

    $.Method({Static:false, Public:false}, "$l$gm__Finally2", 
      JSIL.MethodSignature.Void, 
      $lCalcAdaptivePolyline$gd__5_$l$gm__Finally2
    );

    $.Method({Static:false, Public:false, Virtual:true }, "MoveNext", 
      JSIL.MethodSignature.Return($.Boolean), 
      $lCalcAdaptivePolyline$gd__5_MoveNext
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "MoveNext");

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerable$lFusee.Math.Core.float3$g.GetEnumerator", 
      JSIL.MethodSignature.Return($asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")])), 
      $lCalcAdaptivePolyline$gd__5_System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator
    )
      .Overrides($asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), "GetEnumerator")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lFusee.Math.Core.float3$g.get_Current", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float3")), 
      $lCalcAdaptivePolyline$gd__5_System_Collections_Generic_IEnumerator$lFusee_Math_Core_float3$g_get_Current
    )
      .Overrides($asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), "get_Current")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerable.GetEnumerator", 
      JSIL.MethodSignature.Return($asm15.TypeRef("System.Collections.IEnumerator")), 
      $lCalcAdaptivePolyline$gd__5_System_Collections_IEnumerable_GetEnumerator
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerable"), "GetEnumerator")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.get_Current", 
      JSIL.MethodSignature.Return($.Object), 
      $lCalcAdaptivePolyline$gd__5_System_Collections_IEnumerator_get_Current
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "get_Current")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Reset", 
      JSIL.MethodSignature.Void, 
      $lCalcAdaptivePolyline$gd__5_System_Collections_IEnumerator_Reset
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "Reset")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.IDisposable.Dispose", 
      JSIL.MethodSignature.Void, 
      $lCalcAdaptivePolyline$gd__5_System_IDisposable_Dispose
    )
      .Overrides($asm15.TypeRef("System.IDisposable"), "Dispose")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Field({Static:false, Public:false}, "$l$g1__state", $.Int32);

    $.Field({Static:false, Public:false}, "$l$g2__current", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:false}, "$l$gl__initialThreadId", $.Int32);

    $.Field({Static:false, Public:false}, "acreage", $.Single);

    $.Field({Static:false, Public:true }, "$l$g3__acreage", $.Single);

    $.Field({Static:false, Public:true }, "$l$g4__this", $asm07.TypeRef("Fusee.Math.Core.Curve"));

    $.Field({Static:false, Public:false}, "$l$gs__1", $asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.CurvePart")]));

    $.Field({Static:false, Public:false}, "$lpart$g5__2", $asm07.TypeRef("Fusee.Math.Core.CurvePart"));

    $.Field({Static:false, Public:false}, "$l$gs__3", $asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]));

    $.Field({Static:false, Public:false}, "$lvert$g5__4", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lFusee.Math.Core.float3$g.Current", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Current", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
      /* 1 */ $asm15.TypeRef("System.Collections.IEnumerable"), 
      /* 2 */ $asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
      /* 3 */ $asm15.TypeRef("System.Collections.IEnumerator"), 
      /* 4 */ $asm15.TypeRef("System.IDisposable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class Fusee.Math.Core.CurvePart */ 

(function CurvePart$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm15.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm07.Fusee.Math.Core.CurvePart_$lCalcAdaptivePolyline$gd__4)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm15.System.Single)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.Fusee.Math.Core.CurvePart_$lCalcAdaptivePolyline$gd__5)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.Fusee.Math.Core.CurvePart_$lCalcUniformPolyline$gd__3)) ();
  };


  function CurvePart__ctor () {
  }; 

  function CurvePart_CalcAdaptivePolyline$00 (angle) {
    var expr_07 = new ($T01())(-2);
    expr_07.$l$g4__this = this;
    expr_07.$l$g3__angle = (angle | 0);
    return expr_07;
  }; 

  function CurvePart_CalcAdaptivePolyline$01 (acreage) {
    var expr_07 = new ($T03())(-2);
    expr_07.$l$g4__this = this;
    expr_07.$l$g3__acreage = +acreage;
    return expr_07;
  }; 

  function CurvePart_CalcUniformPolyline (subdiv) {
    var expr_07 = new ($T04())(-2);
    expr_07.$l$g4__this = this;
    expr_07.$l$g3__subdiv = (subdiv | 0);
    return expr_07;
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.Object"), 
      Name: "Fusee.Math.Core.CurvePart", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      CurvePart__ctor
    );

    $.Method({Static:false, Public:true }, "CalcAdaptivePolyline", 
      new JSIL.MethodSignature($asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), [$.Int32]), 
      CurvePart_CalcAdaptivePolyline$00
    );

    $.Method({Static:false, Public:true }, "CalcAdaptivePolyline", 
      new JSIL.MethodSignature($asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), [$.Single]), 
      CurvePart_CalcAdaptivePolyline$01
    );

    $.Method({Static:false, Public:true }, "CalcUniformPolyline", 
      new JSIL.MethodSignature($asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), [$.Int32]), 
      CurvePart_CalcUniformPolyline
    );

    $.Field({Static:false, Public:true }, "IsClosed", $.Boolean);

    $.Field({Static:false, Public:true }, "StartPoint", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:true }, "CurveSegments", $asm15.TypeRef("System.Collections.Generic.IList`1", [$asm07.TypeRef("Fusee.Math.Core.CurveSegment")]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Math.Core.CurvePart+<CalcUniformPolyline>d__3 */ 

(function $lCalcUniformPolyline$gd__3$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm15.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm15.System.Threading.Thread)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerator$b1.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm15.System.IDisposable)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm15.System.Exception)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm15.System.Boolean)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm15.System.Collections.IEnumerator)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm15.System.Collections.Generic.ICollection$b1.Of($asm07.Fusee.Math.Core.CurveSegment))) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm15.System.Collections.Generic.IList$b1.Of($asm07.Fusee.Math.Core.CurveSegment))) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm07.Fusee.Math.Core.LinearSegment)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm07.Fusee.Math.Core.BezierConicSegment)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm07.Fusee.Math.Core.BezierCubicSegment)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm15.System.Collections.Generic.IList$b1.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm15.System.Collections.Generic.ICollection$b1.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerable$b1.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm07.Fusee.Math.Core.CurveSegment)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm15.System.NotSupportedException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm15.TypeRef("System.NotSupportedException"), null))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm15.System.IDisposable.Dispose)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm15.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerator$b1.Of($asm07.Fusee.Math.Core.float3).get_Current)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm15.System.Collections.Generic.ICollection$b1.Of($asm07.Fusee.Math.Core.CurveSegment).get_Count)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm15.System.Collections.Generic.IList$b1.Of($asm07.Fusee.Math.Core.CurveSegment).get_Item)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm15.System.Collections.Generic.IList$b1.Of($asm07.Fusee.Math.Core.float3).get_Item)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm15.System.Collections.Generic.ICollection$b1.Of($asm07.Fusee.Math.Core.float3).get_Count)) ();
  };
  var $IM07 = function () {
    return ($IM07 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerable$b1.Of($asm07.Fusee.Math.Core.float3).GetEnumerator)) ();
  };


  function $lCalcUniformPolyline$gd__3__ctor ($l$g1__state) {
    this.$l$g1__state = ($l$g1__state | 0);
    this.$l$gl__initialThreadId = ($T01().get_CurrentThread().get_ManagedThreadId() | 0);
  }; 

  function $lCalcUniformPolyline$gd__3_$l$gm__Finally1 () {
    this.$l$g1__state = -1;
    if (this.$l$gs__4 !== null) {
      $IM00().Call(this.$l$gs__4, null);
    }
  }; 

  function $lCalcUniformPolyline$gd__3_MoveNext ($exception) {
    try {

      var $label0 = 0;
    $labelgroup0: 
      while (true) {
        switch ($label0) {
          case 0: /* $entry0 */ 
            var num = (this.$l$g1__state | 0);
            if (num === 0) {
              this.$l$g1__state = -1;
              this.$li$g5__1 = 0;
              $label0 = 2 /* goto IL_1E2 */ ;
              continue $labelgroup0;
            }
            if (num !== 1) {
              var result = false;
              return result;
            }
            this.$l$g1__state = -3;

            $label0 = 1 /* goto IL_1B4 */ ;
            continue $labelgroup0;
          case 1: /* IL_1B4 */ 
            if ($IM01().Call(this.$l$gs__4, null)) {
              this.$lvert$g5__5 = $IM02().Call(this.$l$gs__4, null).MemberwiseClone();
              this.$l$g2__current = this.$lvert$g5__5.MemberwiseClone();
              this.$l$g1__state = 1;
              result = true;
              return result;
            }
            this.$l$gm__Finally1();
            this.$l$gs__4 = null;
            var num2 = (this.$li$g5__1 | 0);
            this.$li$g5__1 = ((num2 + 1) | 0);

            $label0 = 2 /* goto IL_1E2 */ ;
            continue $labelgroup0;
          case 2: /* IL_1E2 */ 
            if ((this.$li$g5__1 | 0) < ($IM03().Call(this.$l$g4__this.CurveSegments, null) | 0)) {
              this.$ldegree$g5__3 = 0;
              if (JSIL.GetType($IM04().Call(this.$l$g4__this.CurveSegments, null, this.$li$g5__1)) === $T09().__Type__) {
                this.$ldegree$g5__3 = 1;
              } else {
                if (JSIL.GetType($IM04().Call(this.$l$g4__this.CurveSegments, null, this.$li$g5__1)) === $T0A().__Type__) {
                  this.$ldegree$g5__3 = 2;
                } else {
                  if (JSIL.GetType($IM04().Call(this.$l$g4__this.CurveSegments, null, this.$li$g5__1)) === $T0B().__Type__) {
                    this.$ldegree$g5__3 = 3;
                  }
                }
              }
              this.$lsp$g5__2 = (
                ((this.$li$g5__1 | 0) === 0)
                   ? this.$l$g4__this.StartPoint
                   : $IM05().Call($IM04().Call(this.$l$g4__this.CurveSegments, null, (((this.$li$g5__1 | 0) - 1) | 0)).Vertices, null, ((($IM06().Call($IM04().Call(this.$l$g4__this.CurveSegments, null, (((this.$li$g5__1 | 0) - 1) | 0)).Vertices, null) | 0) - 1) | 0)))
              .MemberwiseClone();
              this.$l$gs__4 = $IM07().Call(($IM04().Call(this.$l$g4__this.CurveSegments, null, this.$li$g5__1)).CalcUniformPolyline(this.$lsp$g5__2.MemberwiseClone(), this.subdiv, this.$ldegree$g5__3), null);
              this.$l$g1__state = -3;
              $label0 = 1 /* goto IL_1B4 */ ;
              continue $labelgroup0;
            }
            result = false;

            break $labelgroup0;
        }
      }
    } catch ($exception) {
      this.System_IDisposable_Dispose();
      throw $exception;
    }
    return result;
  }; 

  function $lCalcUniformPolyline$gd__3_System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator () {
    if (!(((this.$l$g1__state | 0) !== -2) || ((this.$l$gl__initialThreadId | 0) !== ($T01().get_CurrentThread().get_ManagedThreadId() | 0)))) {
      this.$l$g1__state = 0;
      var $lCalcUniformPolyline$gd__ = this;
    } else {
      $lCalcUniformPolyline$gd__ = new $thisType(0);
      $lCalcUniformPolyline$gd__.$l$g4__this = this.$l$g4__this;
    }
    $lCalcUniformPolyline$gd__.subdiv = (this.$l$g3__subdiv | 0);
    return $lCalcUniformPolyline$gd__;
  }; 

  function $lCalcUniformPolyline$gd__3_System_Collections_Generic_IEnumerator$lFusee_Math_Core_float3$g_get_Current () {
    return this.$l$g2__current;
  }; 

  function $lCalcUniformPolyline$gd__3_System_Collections_IEnumerable_GetEnumerator () {
    return this.System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator();
  }; 

  function $lCalcUniformPolyline$gd__3_System_Collections_IEnumerator_get_Current () {
    return this.$l$g2__current;
  }; 

  function $lCalcUniformPolyline$gd__3_System_Collections_IEnumerator_Reset () {
    throw $S00().Construct();
  }; 

  function $lCalcUniformPolyline$gd__3_System_IDisposable_Dispose () {
    var num = (this.$l$g1__state | 0);
    if ((num === -3) || (num === 1)) {
      try {
      } finally {
        this.$l$gm__Finally1();
      }
    }
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.Object"), 
      Name: "Fusee.Math.Core.CurvePart+<CalcUniformPolyline>d__3", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Int32), 
      $lCalcUniformPolyline$gd__3__ctor
    )
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false}, "$l$gm__Finally1", 
      JSIL.MethodSignature.Void, 
      $lCalcUniformPolyline$gd__3_$l$gm__Finally1
    );

    $.Method({Static:false, Public:false, Virtual:true }, "MoveNext", 
      JSIL.MethodSignature.Return($.Boolean), 
      $lCalcUniformPolyline$gd__3_MoveNext
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "MoveNext");

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerable$lFusee.Math.Core.float3$g.GetEnumerator", 
      JSIL.MethodSignature.Return($asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")])), 
      $lCalcUniformPolyline$gd__3_System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator
    )
      .Overrides($asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), "GetEnumerator")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lFusee.Math.Core.float3$g.get_Current", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float3")), 
      $lCalcUniformPolyline$gd__3_System_Collections_Generic_IEnumerator$lFusee_Math_Core_float3$g_get_Current
    )
      .Overrides($asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), "get_Current")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerable.GetEnumerator", 
      JSIL.MethodSignature.Return($asm15.TypeRef("System.Collections.IEnumerator")), 
      $lCalcUniformPolyline$gd__3_System_Collections_IEnumerable_GetEnumerator
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerable"), "GetEnumerator")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.get_Current", 
      JSIL.MethodSignature.Return($.Object), 
      $lCalcUniformPolyline$gd__3_System_Collections_IEnumerator_get_Current
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "get_Current")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Reset", 
      JSIL.MethodSignature.Void, 
      $lCalcUniformPolyline$gd__3_System_Collections_IEnumerator_Reset
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "Reset")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.IDisposable.Dispose", 
      JSIL.MethodSignature.Void, 
      $lCalcUniformPolyline$gd__3_System_IDisposable_Dispose
    )
      .Overrides($asm15.TypeRef("System.IDisposable"), "Dispose")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Field({Static:false, Public:false}, "$l$g1__state", $.Int32);

    $.Field({Static:false, Public:false}, "$l$g2__current", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:false}, "$l$gl__initialThreadId", $.Int32);

    $.Field({Static:false, Public:false}, "subdiv", $.Int32);

    $.Field({Static:false, Public:true }, "$l$g3__subdiv", $.Int32);

    $.Field({Static:false, Public:true }, "$l$g4__this", $asm07.TypeRef("Fusee.Math.Core.CurvePart"));

    $.Field({Static:false, Public:false}, "$li$g5__1", $.Int32);

    $.Field({Static:false, Public:false}, "$lsp$g5__2", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:false}, "$ldegree$g5__3", $.Int32);

    $.Field({Static:false, Public:false}, "$l$gs__4", $asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]));

    $.Field({Static:false, Public:false}, "$lvert$g5__5", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lFusee.Math.Core.float3$g.Current", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Current", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
      /* 1 */ $asm15.TypeRef("System.Collections.IEnumerable"), 
      /* 2 */ $asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
      /* 3 */ $asm15.TypeRef("System.Collections.IEnumerator"), 
      /* 4 */ $asm15.TypeRef("System.IDisposable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class Fusee.Math.Core.CurvePart+<CalcAdaptivePolyline>d__4 */ 

(function $lCalcAdaptivePolyline$gd__4$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm15.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm15.System.Threading.Thread)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerator$b1.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm15.System.IDisposable)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm15.System.Exception)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm15.System.Boolean)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm15.System.Collections.IEnumerator)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm15.System.Collections.Generic.ICollection$b1.Of($asm07.Fusee.Math.Core.CurveSegment))) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm15.System.Collections.Generic.IList$b1.Of($asm07.Fusee.Math.Core.CurveSegment))) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm07.Fusee.Math.Core.LinearSegment)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm07.Fusee.Math.Core.BezierConicSegment)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm07.Fusee.Math.Core.BezierCubicSegment)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm15.System.Collections.Generic.IList$b1.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm15.System.Collections.Generic.ICollection$b1.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerable$b1.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm07.Fusee.Math.Core.CurveSegment)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm15.System.NotSupportedException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm15.TypeRef("System.NotSupportedException"), null))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm15.System.IDisposable.Dispose)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm15.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerator$b1.Of($asm07.Fusee.Math.Core.float3).get_Current)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm15.System.Collections.Generic.ICollection$b1.Of($asm07.Fusee.Math.Core.CurveSegment).get_Count)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm15.System.Collections.Generic.IList$b1.Of($asm07.Fusee.Math.Core.CurveSegment).get_Item)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm15.System.Collections.Generic.IList$b1.Of($asm07.Fusee.Math.Core.float3).get_Item)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm15.System.Collections.Generic.ICollection$b1.Of($asm07.Fusee.Math.Core.float3).get_Count)) ();
  };
  var $IM07 = function () {
    return ($IM07 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerable$b1.Of($asm07.Fusee.Math.Core.float3).GetEnumerator)) ();
  };


  function $lCalcAdaptivePolyline$gd__4__ctor ($l$g1__state) {
    this.$l$g1__state = ($l$g1__state | 0);
    this.$l$gl__initialThreadId = ($T01().get_CurrentThread().get_ManagedThreadId() | 0);
  }; 

  function $lCalcAdaptivePolyline$gd__4_$l$gm__Finally1 () {
    this.$l$g1__state = -1;
    if (this.$l$gs__4 !== null) {
      $IM00().Call(this.$l$gs__4, null);
    }
  }; 

  function $lCalcAdaptivePolyline$gd__4_MoveNext ($exception) {
    try {

      var $label0 = 0;
    $labelgroup0: 
      while (true) {
        switch ($label0) {
          case 0: /* $entry0 */ 
            var num = (this.$l$g1__state | 0);
            if (num === 0) {
              this.$l$g1__state = -1;
              this.$li$g5__1 = 0;
              $label0 = 2 /* goto IL_1E2 */ ;
              continue $labelgroup0;
            }
            if (num !== 1) {
              var result = false;
              return result;
            }
            this.$l$g1__state = -3;

            $label0 = 1 /* goto IL_1B4 */ ;
            continue $labelgroup0;
          case 1: /* IL_1B4 */ 
            if ($IM01().Call(this.$l$gs__4, null)) {
              this.$lvert$g5__5 = $IM02().Call(this.$l$gs__4, null).MemberwiseClone();
              this.$l$g2__current = this.$lvert$g5__5.MemberwiseClone();
              this.$l$g1__state = 1;
              result = true;
              return result;
            }
            this.$l$gm__Finally1();
            this.$l$gs__4 = null;
            var num2 = (this.$li$g5__1 | 0);
            this.$li$g5__1 = ((num2 + 1) | 0);

            $label0 = 2 /* goto IL_1E2 */ ;
            continue $labelgroup0;
          case 2: /* IL_1E2 */ 
            if ((this.$li$g5__1 | 0) < ($IM03().Call(this.$l$g4__this.CurveSegments, null) | 0)) {
              this.$ldegree$g5__3 = 0;
              if (JSIL.GetType($IM04().Call(this.$l$g4__this.CurveSegments, null, this.$li$g5__1)) === $T09().__Type__) {
                this.$ldegree$g5__3 = 1;
              } else {
                if (JSIL.GetType($IM04().Call(this.$l$g4__this.CurveSegments, null, this.$li$g5__1)) === $T0A().__Type__) {
                  this.$ldegree$g5__3 = 2;
                } else {
                  if (JSIL.GetType($IM04().Call(this.$l$g4__this.CurveSegments, null, this.$li$g5__1)) === $T0B().__Type__) {
                    this.$ldegree$g5__3 = 3;
                  }
                }
              }
              this.$lsp$g5__2 = (
                ((this.$li$g5__1 | 0) === 0)
                   ? this.$l$g4__this.StartPoint
                   : $IM05().Call($IM04().Call(this.$l$g4__this.CurveSegments, null, (((this.$li$g5__1 | 0) - 1) | 0)).Vertices, null, ((($IM06().Call($IM04().Call(this.$l$g4__this.CurveSegments, null, (((this.$li$g5__1 | 0) - 1) | 0)).Vertices, null) | 0) - 1) | 0)))
              .MemberwiseClone();
              this.$l$gs__4 = $IM07().Call(($IM04().Call(this.$l$g4__this.CurveSegments, null, this.$li$g5__1)).CalcAdaptivePolylineWAngle(this.$lsp$g5__2.MemberwiseClone(), this.angle, this.$ldegree$g5__3), null);
              this.$l$g1__state = -3;
              $label0 = 1 /* goto IL_1B4 */ ;
              continue $labelgroup0;
            }
            result = false;

            break $labelgroup0;
        }
      }
    } catch ($exception) {
      this.System_IDisposable_Dispose();
      throw $exception;
    }
    return result;
  }; 

  function $lCalcAdaptivePolyline$gd__4_System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator () {
    if (!(((this.$l$g1__state | 0) !== -2) || ((this.$l$gl__initialThreadId | 0) !== ($T01().get_CurrentThread().get_ManagedThreadId() | 0)))) {
      this.$l$g1__state = 0;
      var $lCalcAdaptivePolyline$gd__ = this;
    } else {
      $lCalcAdaptivePolyline$gd__ = new $thisType(0);
      $lCalcAdaptivePolyline$gd__.$l$g4__this = this.$l$g4__this;
    }
    $lCalcAdaptivePolyline$gd__.angle = (this.$l$g3__angle | 0);
    return $lCalcAdaptivePolyline$gd__;
  }; 

  function $lCalcAdaptivePolyline$gd__4_System_Collections_Generic_IEnumerator$lFusee_Math_Core_float3$g_get_Current () {
    return this.$l$g2__current;
  }; 

  function $lCalcAdaptivePolyline$gd__4_System_Collections_IEnumerable_GetEnumerator () {
    return this.System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator();
  }; 

  function $lCalcAdaptivePolyline$gd__4_System_Collections_IEnumerator_get_Current () {
    return this.$l$g2__current;
  }; 

  function $lCalcAdaptivePolyline$gd__4_System_Collections_IEnumerator_Reset () {
    throw $S00().Construct();
  }; 

  function $lCalcAdaptivePolyline$gd__4_System_IDisposable_Dispose () {
    var num = (this.$l$g1__state | 0);
    if ((num === -3) || (num === 1)) {
      try {
      } finally {
        this.$l$gm__Finally1();
      }
    }
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.Object"), 
      Name: "Fusee.Math.Core.CurvePart+<CalcAdaptivePolyline>d__4", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Int32), 
      $lCalcAdaptivePolyline$gd__4__ctor
    )
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false}, "$l$gm__Finally1", 
      JSIL.MethodSignature.Void, 
      $lCalcAdaptivePolyline$gd__4_$l$gm__Finally1
    );

    $.Method({Static:false, Public:false, Virtual:true }, "MoveNext", 
      JSIL.MethodSignature.Return($.Boolean), 
      $lCalcAdaptivePolyline$gd__4_MoveNext
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "MoveNext");

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerable$lFusee.Math.Core.float3$g.GetEnumerator", 
      JSIL.MethodSignature.Return($asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")])), 
      $lCalcAdaptivePolyline$gd__4_System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator
    )
      .Overrides($asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), "GetEnumerator")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lFusee.Math.Core.float3$g.get_Current", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float3")), 
      $lCalcAdaptivePolyline$gd__4_System_Collections_Generic_IEnumerator$lFusee_Math_Core_float3$g_get_Current
    )
      .Overrides($asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), "get_Current")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerable.GetEnumerator", 
      JSIL.MethodSignature.Return($asm15.TypeRef("System.Collections.IEnumerator")), 
      $lCalcAdaptivePolyline$gd__4_System_Collections_IEnumerable_GetEnumerator
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerable"), "GetEnumerator")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.get_Current", 
      JSIL.MethodSignature.Return($.Object), 
      $lCalcAdaptivePolyline$gd__4_System_Collections_IEnumerator_get_Current
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "get_Current")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Reset", 
      JSIL.MethodSignature.Void, 
      $lCalcAdaptivePolyline$gd__4_System_Collections_IEnumerator_Reset
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "Reset")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.IDisposable.Dispose", 
      JSIL.MethodSignature.Void, 
      $lCalcAdaptivePolyline$gd__4_System_IDisposable_Dispose
    )
      .Overrides($asm15.TypeRef("System.IDisposable"), "Dispose")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Field({Static:false, Public:false}, "$l$g1__state", $.Int32);

    $.Field({Static:false, Public:false}, "$l$g2__current", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:false}, "$l$gl__initialThreadId", $.Int32);

    $.Field({Static:false, Public:false}, "angle", $.Int32);

    $.Field({Static:false, Public:true }, "$l$g3__angle", $.Int32);

    $.Field({Static:false, Public:true }, "$l$g4__this", $asm07.TypeRef("Fusee.Math.Core.CurvePart"));

    $.Field({Static:false, Public:false}, "$li$g5__1", $.Int32);

    $.Field({Static:false, Public:false}, "$lsp$g5__2", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:false}, "$ldegree$g5__3", $.Int32);

    $.Field({Static:false, Public:false}, "$l$gs__4", $asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]));

    $.Field({Static:false, Public:false}, "$lvert$g5__5", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lFusee.Math.Core.float3$g.Current", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Current", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
      /* 1 */ $asm15.TypeRef("System.Collections.IEnumerable"), 
      /* 2 */ $asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
      /* 3 */ $asm15.TypeRef("System.Collections.IEnumerator"), 
      /* 4 */ $asm15.TypeRef("System.IDisposable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class Fusee.Math.Core.CurvePart+<CalcAdaptivePolyline>d__5 */ 

(function $lCalcAdaptivePolyline$gd__5$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm15.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm15.System.Threading.Thread)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerator$b1.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm15.System.IDisposable)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm15.System.Exception)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm15.System.Boolean)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm15.System.Collections.IEnumerator)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm15.System.Collections.Generic.ICollection$b1.Of($asm07.Fusee.Math.Core.CurveSegment))) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm15.System.Collections.Generic.IList$b1.Of($asm07.Fusee.Math.Core.CurveSegment))) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm07.Fusee.Math.Core.LinearSegment)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm07.Fusee.Math.Core.BezierConicSegment)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm07.Fusee.Math.Core.BezierCubicSegment)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm15.System.Collections.Generic.IList$b1.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm15.System.Collections.Generic.ICollection$b1.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerable$b1.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm07.Fusee.Math.Core.CurveSegment)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm15.System.NotSupportedException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm15.TypeRef("System.NotSupportedException"), null))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm15.System.IDisposable.Dispose)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm15.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerator$b1.Of($asm07.Fusee.Math.Core.float3).get_Current)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm15.System.Collections.Generic.ICollection$b1.Of($asm07.Fusee.Math.Core.CurveSegment).get_Count)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm15.System.Collections.Generic.IList$b1.Of($asm07.Fusee.Math.Core.CurveSegment).get_Item)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm15.System.Collections.Generic.IList$b1.Of($asm07.Fusee.Math.Core.float3).get_Item)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm15.System.Collections.Generic.ICollection$b1.Of($asm07.Fusee.Math.Core.float3).get_Count)) ();
  };
  var $IM07 = function () {
    return ($IM07 = JSIL.Memoize($asm15.System.Collections.Generic.IEnumerable$b1.Of($asm07.Fusee.Math.Core.float3).GetEnumerator)) ();
  };


  function $lCalcAdaptivePolyline$gd__5__ctor ($l$g1__state) {
    this.$l$g1__state = ($l$g1__state | 0);
    this.$l$gl__initialThreadId = ($T01().get_CurrentThread().get_ManagedThreadId() | 0);
  }; 

  function $lCalcAdaptivePolyline$gd__5_$l$gm__Finally1 () {
    this.$l$g1__state = -1;
    if (this.$l$gs__4 !== null) {
      $IM00().Call(this.$l$gs__4, null);
    }
  }; 

  function $lCalcAdaptivePolyline$gd__5_MoveNext ($exception) {
    try {

      var $label0 = 0;
    $labelgroup0: 
      while (true) {
        switch ($label0) {
          case 0: /* $entry0 */ 
            var num = (this.$l$g1__state | 0);
            if (num === 0) {
              this.$l$g1__state = -1;
              this.$li$g5__1 = 0;
              $label0 = 2 /* goto IL_1E2 */ ;
              continue $labelgroup0;
            }
            if (num !== 1) {
              var result = false;
              return result;
            }
            this.$l$g1__state = -3;

            $label0 = 1 /* goto IL_1B4 */ ;
            continue $labelgroup0;
          case 1: /* IL_1B4 */ 
            if ($IM01().Call(this.$l$gs__4, null)) {
              this.$lvert$g5__5 = $IM02().Call(this.$l$gs__4, null).MemberwiseClone();
              this.$l$g2__current = this.$lvert$g5__5.MemberwiseClone();
              this.$l$g1__state = 1;
              result = true;
              return result;
            }
            this.$l$gm__Finally1();
            this.$l$gs__4 = null;
            var num2 = (this.$li$g5__1 | 0);
            this.$li$g5__1 = ((num2 + 1) | 0);

            $label0 = 2 /* goto IL_1E2 */ ;
            continue $labelgroup0;
          case 2: /* IL_1E2 */ 
            if ((this.$li$g5__1 | 0) < ($IM03().Call(this.$l$g4__this.CurveSegments, null) | 0)) {
              this.$ldegree$g5__3 = 0;
              if (JSIL.GetType($IM04().Call(this.$l$g4__this.CurveSegments, null, this.$li$g5__1)) === $T09().__Type__) {
                this.$ldegree$g5__3 = 1;
              } else {
                if (JSIL.GetType($IM04().Call(this.$l$g4__this.CurveSegments, null, this.$li$g5__1)) === $T0A().__Type__) {
                  this.$ldegree$g5__3 = 2;
                } else {
                  if (JSIL.GetType($IM04().Call(this.$l$g4__this.CurveSegments, null, this.$li$g5__1)) === $T0B().__Type__) {
                    this.$ldegree$g5__3 = 3;
                  }
                }
              }
              this.$lsp$g5__2 = (
                ((this.$li$g5__1 | 0) === 0)
                   ? this.$l$g4__this.StartPoint
                   : $IM05().Call($IM04().Call(this.$l$g4__this.CurveSegments, null, (((this.$li$g5__1 | 0) - 1) | 0)).Vertices, null, ((($IM06().Call($IM04().Call(this.$l$g4__this.CurveSegments, null, (((this.$li$g5__1 | 0) - 1) | 0)).Vertices, null) | 0) - 1) | 0)))
              .MemberwiseClone();
              this.$l$gs__4 = $IM07().Call(($IM04().Call(this.$l$g4__this.CurveSegments, null, this.$li$g5__1)).CalcAdaptivePolylineWArcreage(this.$lsp$g5__2.MemberwiseClone(), this.acreage, this.$ldegree$g5__3), null);
              this.$l$g1__state = -3;
              $label0 = 1 /* goto IL_1B4 */ ;
              continue $labelgroup0;
            }
            result = false;

            break $labelgroup0;
        }
      }
    } catch ($exception) {
      this.System_IDisposable_Dispose();
      throw $exception;
    }
    return result;
  }; 

  function $lCalcAdaptivePolyline$gd__5_System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator () {
    if (!(((this.$l$g1__state | 0) !== -2) || ((this.$l$gl__initialThreadId | 0) !== ($T01().get_CurrentThread().get_ManagedThreadId() | 0)))) {
      this.$l$g1__state = 0;
      var $lCalcAdaptivePolyline$gd__ = this;
    } else {
      $lCalcAdaptivePolyline$gd__ = new $thisType(0);
      $lCalcAdaptivePolyline$gd__.$l$g4__this = this.$l$g4__this;
    }
    $lCalcAdaptivePolyline$gd__.acreage = +this.$l$g3__acreage;
    return $lCalcAdaptivePolyline$gd__;
  }; 

  function $lCalcAdaptivePolyline$gd__5_System_Collections_Generic_IEnumerator$lFusee_Math_Core_float3$g_get_Current () {
    return this.$l$g2__current;
  }; 

  function $lCalcAdaptivePolyline$gd__5_System_Collections_IEnumerable_GetEnumerator () {
    return this.System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator();
  }; 

  function $lCalcAdaptivePolyline$gd__5_System_Collections_IEnumerator_get_Current () {
    return this.$l$g2__current;
  }; 

  function $lCalcAdaptivePolyline$gd__5_System_Collections_IEnumerator_Reset () {
    throw $S00().Construct();
  }; 

  function $lCalcAdaptivePolyline$gd__5_System_IDisposable_Dispose () {
    var num = (this.$l$g1__state | 0);
    if ((num === -3) || (num === 1)) {
      try {
      } finally {
        this.$l$gm__Finally1();
      }
    }
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.Object"), 
      Name: "Fusee.Math.Core.CurvePart+<CalcAdaptivePolyline>d__5", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Int32), 
      $lCalcAdaptivePolyline$gd__5__ctor
    )
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false}, "$l$gm__Finally1", 
      JSIL.MethodSignature.Void, 
      $lCalcAdaptivePolyline$gd__5_$l$gm__Finally1
    );

    $.Method({Static:false, Public:false, Virtual:true }, "MoveNext", 
      JSIL.MethodSignature.Return($.Boolean), 
      $lCalcAdaptivePolyline$gd__5_MoveNext
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "MoveNext");

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerable$lFusee.Math.Core.float3$g.GetEnumerator", 
      JSIL.MethodSignature.Return($asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")])), 
      $lCalcAdaptivePolyline$gd__5_System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator
    )
      .Overrides($asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), "GetEnumerator")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lFusee.Math.Core.float3$g.get_Current", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float3")), 
      $lCalcAdaptivePolyline$gd__5_System_Collections_Generic_IEnumerator$lFusee_Math_Core_float3$g_get_Current
    )
      .Overrides($asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), "get_Current")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerable.GetEnumerator", 
      JSIL.MethodSignature.Return($asm15.TypeRef("System.Collections.IEnumerator")), 
      $lCalcAdaptivePolyline$gd__5_System_Collections_IEnumerable_GetEnumerator
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerable"), "GetEnumerator")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.get_Current", 
      JSIL.MethodSignature.Return($.Object), 
      $lCalcAdaptivePolyline$gd__5_System_Collections_IEnumerator_get_Current
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "get_Current")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Reset", 
      JSIL.MethodSignature.Void, 
      $lCalcAdaptivePolyline$gd__5_System_Collections_IEnumerator_Reset
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "Reset")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.IDisposable.Dispose", 
      JSIL.MethodSignature.Void, 
      $lCalcAdaptivePolyline$gd__5_System_IDisposable_Dispose
    )
      .Overrides($asm15.TypeRef("System.IDisposable"), "Dispose")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Field({Static:false, Public:false}, "$l$g1__state", $.Int32);

    $.Field({Static:false, Public:false}, "$l$g2__current", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:false}, "$l$gl__initialThreadId", $.Int32);

    $.Field({Static:false, Public:false}, "acreage", $.Single);

    $.Field({Static:false, Public:true }, "$l$g3__acreage", $.Single);

    $.Field({Static:false, Public:true }, "$l$g4__this", $asm07.TypeRef("Fusee.Math.Core.CurvePart"));

    $.Field({Static:false, Public:false}, "$li$g5__1", $.Int32);

    $.Field({Static:false, Public:false}, "$lsp$g5__2", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:false}, "$ldegree$g5__3", $.Int32);

    $.Field({Static:false, Public:false}, "$l$gs__4", $asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]));

    $.Field({Static:false, Public:false}, "$lvert$g5__5", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lFusee.Math.Core.float3$g.Current", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Current", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
      /* 1 */ $asm15.TypeRef("System.Collections.IEnumerable"), 
      /* 2 */ $asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
      /* 3 */ $asm15.TypeRef("System.Collections.IEnumerator"), 
      /* 4 */ $asm15.TypeRef("System.IDisposable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class Fusee.Math.Core.CurveSegment */ 

(function CurveSegment$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize(System.Array.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm15.System.Int32)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm15.System.Collections.Generic.List$b1.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm15.System.Random)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.Fusee.Math.Core.float3)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm15.System.Double)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm15.System.Boolean)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm15.System.Single)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm07.Fusee.Math.Core.CurveSegment_$lCalcAdaptivePolylineWAngle$gd__4)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm07.Fusee.Math.Core.CurveSegment_$lCalcAdaptivePolylineWArcreage$gd__5)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm07.Fusee.Math.Core.CurveSegment_$lCalcUniformPolyline$gd__3)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm07.Fusee.Math.Core.M)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm07.Fusee.Math.Core.float3x3)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm15.System.Math)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm15.TypeRef("System.Random"), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm07.TypeRef("Fusee.Math.Core.float3")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm15.TypeRef("System.Collections.Generic.List`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), null))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [$asm15.TypeRef("System.Single"), $asm07.TypeRef("Fusee.Math.Core.float3")]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.float3x3"), [
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single")
      ]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm15.TypeRef("System.Double"), [$asm15.TypeRef("System.Double"), $asm15.TypeRef("System.Int32")]))) ();
  };


  function CurveSegment__ctor () {
  }; 

  function CurveSegment_AdaptiveSamplingWAngle (verts, angle, /* ref */ vertList) {
    var rnd = $S00().Construct();
    var a = verts[0].MemberwiseClone();
    var b = verts[(((verts.length | 0) - 1) | 0)].MemberwiseClone();
    var t = +$thisType.RandomT(rnd, 0.45, 0.55);
    var vertNearMiddle = this.CalcPoint(Math.fround(t), verts);
    var flag = $thisType.IsAngleFlatEnough(a.MemberwiseClone(), vertNearMiddle, b.MemberwiseClone(), +angle);
    var leftCurve = new JSIL.BoxedVariable(null);
    var rightCurve = new JSIL.BoxedVariable(null);
    if (flag) {
      $S01().CallVirtual("Add", null, vertList.get(), b.MemberwiseClone());
    } else {
      leftCurve.set($S02().Construct());
      rightCurve.set($S02().Construct());
      this.SplitCurve(Math.fround(t), verts, /* ref */ leftCurve, /* ref */ rightCurve);
      this.AdaptiveSamplingWAngle($T02().prototype.ToArray.call(leftCurve.get()), angle, /* ref */ vertList);
      this.AdaptiveSamplingWAngle($T02().prototype.ToArray.call(rightCurve.get()), angle, /* ref */ vertList);
    }
  }; 

  function CurveSegment_AdaptiveSamplingWArcreage (verts, acreage, /* ref */ vertList) {
    var rnd = $S00().Construct();
    var a = verts[0];
    var b = verts[(((verts.length | 0) - 1) | 0)].MemberwiseClone();
    var t = +$thisType.RandomT(rnd, 0.45, 0.55);
    var vertNearMiddle = this.CalcPoint(Math.fround(t), verts);
    var flag = $thisType.IsArcreageSmallEnough(a, vertNearMiddle, b, acreage);
    var leftCurve = new JSIL.BoxedVariable(null);
    var rightCurve = new JSIL.BoxedVariable(null);
    if (flag) {
      $S01().CallVirtual("Add", null, vertList.get(), b.MemberwiseClone());
    } else {
      leftCurve.set($S02().Construct());
      rightCurve.set($S02().Construct());
      this.SplitCurve(Math.fround(t), verts, /* ref */ leftCurve, /* ref */ rightCurve);
      this.AdaptiveSamplingWArcreage($T02().prototype.ToArray.call(leftCurve.get()), acreage, /* ref */ vertList);
      this.AdaptiveSamplingWArcreage($T02().prototype.ToArray.call(rightCurve.get()), acreage, /* ref */ vertList);
    }
  }; 

  function CurveSegment_CalcAdaptivePolylineWAngle (startPoint, angle, degree) {
    var expr_07 = new ($T08())(-2);
    expr_07.$l$g4__this = this;
    expr_07.$l$g3__startPoint = startPoint.MemberwiseClone();
    expr_07.$l$g3__angle = (angle | 0);
    expr_07.$l$g3__degree = (degree | 0);
    return expr_07;
  }; 

  function CurveSegment_CalcAdaptivePolylineWArcreage (startPoint, acreage, degree) {
    var expr_07 = new ($T09())(-2);
    expr_07.$l$g4__this = this;
    expr_07.$l$g3__startPoint = startPoint.MemberwiseClone();
    expr_07.$l$g3__acreage = +acreage;
    expr_07.$l$g3__degree = (degree | 0);
    return expr_07;
  }; 

  function CurveSegment_CalcPoint (t, vertices) {
    var flag = (vertices.length | 0) === 1;
    if (flag) {
      var result = vertices[0].MemberwiseClone();
    } else {
      var newVerts = JSIL.Array.New($T04(), (((vertices.length | 0) - 1) | 0));

      for (var i = 0; i < (newVerts.length | 0); i = ((i + 1) | 0)) {
        var point = $T04().op_Addition(
          $S03().CallStatic($T04(), "op_Multiply", null, 1 - +t, vertices[i].MemberwiseClone()).MemberwiseClone(), 
          $S03().CallStatic($T04(), "op_Multiply", null, t, vertices[((i + 1) | 0)].MemberwiseClone())
        );
        newVerts[i] = point.MemberwiseClone();
      }
      result = this.CalcPoint(t, newVerts).MemberwiseClone();
    }
    return result;
  }; 

  function CurveSegment_CalcUniformPolyline (startPoint, segmentsPerCurve, degree) {
    var expr_07 = new ($T0A())(-2);
    expr_07.$l$g4__this = this;
    expr_07.$l$g3__startPoint = startPoint.MemberwiseClone();
    expr_07.$l$g3__segmentsPerCurve = (segmentsPerCurve | 0);
    expr_07.$l$g3__degree = (degree | 0);
    return expr_07;
  }; 

  function CurveSegment_IsAngleFlatEnough (a, m, b, threshold) {
    var p = $T04().op_Subtraction(a.MemberwiseClone(), m);
    var q = $T04().op_Subtraction(b.MemberwiseClone(), m);
    var angle = +$T04().CalculateAngle(p, q);
    angle = +$T0B().RadiansToDegrees(angle);
    return ((angle <= 180) && (angle >= (180 - +threshold)));
  }; 

  function CurveSegment_IsArcreageSmallEnough (a, m, b, threshold) {
    var det = +($S04().Construct(1, 1, 1, (+m.x - +a.x), (+m.y - +a.y), (+m.z - +a.z), (+b.x - +a.x), (+b.y - +a.y), (+b.z - +a.z))).get_Determinant();
    var area = 0.5 * det;
    var flag = area < 1;
    if (flag) {
      area *= -1;
    }
    return (area < threshold);
  }; 

  function CurveSegment_RandomT (rnd, min, max) {
    var rndT = +min + (+rnd.NextDouble() * (+max - +min));
    rndT = +$S05().CallStatic($T0D(), "Round", null, rndT, 2);
    var flag = !((rndT === 0.5));
    if (flag) {
      var result = rndT;
    } else {
      result = +$thisType.RandomT(rnd, min, max);
    }
    return result;
  }; 

  function CurveSegment_SplitCurve (t, vertices, /* ref */ leftCurve, /* ref */ rightCurve) {
    var flag = (vertices.length | 0) === 1;
    if (flag) {
      $S01().CallVirtual("Add", null, leftCurve.get(), vertices[0].MemberwiseClone());
      $S01().CallVirtual("Add", null, rightCurve.get(), vertices[0].MemberwiseClone());
      $T02().prototype.Reverse.call(rightCurve.get());
    } else {
      var newVerts = JSIL.Array.New($T04(), (((vertices.length | 0) - 1) | 0));

      for (var i = 0; i < (newVerts.length | 0); i = ((i + 1) | 0)) {
        var flag2 = i === 0;
        if (flag2) {
          $S01().CallVirtual("Add", null, leftCurve.get(), vertices[0].MemberwiseClone());
        }
        var flag3 = i === (((newVerts.length | 0) - 1) | 0);
        if (flag3) {
          $S01().CallVirtual("Add", null, rightCurve.get(), vertices[((i + 1) | 0)].MemberwiseClone());
        }
        var newVert = $T04().op_Addition(
          $S03().CallStatic($T04(), "op_Multiply", null, 1 - +t, vertices[i].MemberwiseClone()).MemberwiseClone(), 
          $S03().CallStatic($T04(), "op_Multiply", null, t, vertices[((i + 1) | 0)].MemberwiseClone())
        );
        newVerts[i] = newVert.MemberwiseClone();
      }
      this.SplitCurve(t, newVerts, /* ref */ leftCurve, /* ref */ rightCurve);
    }
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.Object"), 
      Name: "Fusee.Math.Core.CurveSegment", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      CurveSegment__ctor
    );

    $.Method({Static:false, Public:false}, "AdaptiveSamplingWAngle", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$asm07.TypeRef("Fusee.Math.Core.float3")]), $.Int32, 
          $jsilcore.TypeRef("JSIL.Reference", [$asm15.TypeRef("System.Collections.Generic.List`1", [$asm07.TypeRef("Fusee.Math.Core.float3")])])
        ]), 
      CurveSegment_AdaptiveSamplingWAngle
    );

    $.Method({Static:false, Public:false}, "AdaptiveSamplingWArcreage", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$asm07.TypeRef("Fusee.Math.Core.float3")]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$asm15.TypeRef("System.Collections.Generic.List`1", [$asm07.TypeRef("Fusee.Math.Core.float3")])])
        ]), 
      CurveSegment_AdaptiveSamplingWArcreage
    );

    $.Method({Static:false, Public:true }, "CalcAdaptivePolylineWAngle", 
      new JSIL.MethodSignature($asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), [
          $asm07.TypeRef("Fusee.Math.Core.float3"), $.Int32, 
          $.Int32
        ]), 
      CurveSegment_CalcAdaptivePolylineWAngle
    );

    $.Method({Static:false, Public:true }, "CalcAdaptivePolylineWArcreage", 
      new JSIL.MethodSignature($asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), [
          $asm07.TypeRef("Fusee.Math.Core.float3"), $.Single, 
          $.Int32
        ]), 
      CurveSegment_CalcAdaptivePolylineWArcreage
    );

    $.Method({Static:false, Public:true }, "CalcPoint", 
      new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [$.Single, $jsilcore.TypeRef("System.Array", [$asm07.TypeRef("Fusee.Math.Core.float3")])]), 
      CurveSegment_CalcPoint
    );

    $.Method({Static:false, Public:true , Virtual:true }, "CalcUniformPolyline", 
      new JSIL.MethodSignature($asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), [
          $asm07.TypeRef("Fusee.Math.Core.float3"), $.Int32, 
          $.Int32
        ]), 
      CurveSegment_CalcUniformPolyline
    );

    $.Method({Static:true , Public:false}, "IsAngleFlatEnough", 
      new JSIL.MethodSignature($.Boolean, [
          $asm07.TypeRef("Fusee.Math.Core.float3"), $asm07.TypeRef("Fusee.Math.Core.float3"), 
          $asm07.TypeRef("Fusee.Math.Core.float3"), $.Single
        ]), 
      CurveSegment_IsAngleFlatEnough
    );

    $.Method({Static:true , Public:false}, "IsArcreageSmallEnough", 
      new JSIL.MethodSignature($.Boolean, [
          $asm07.TypeRef("Fusee.Math.Core.float3"), $asm07.TypeRef("Fusee.Math.Core.float3"), 
          $asm07.TypeRef("Fusee.Math.Core.float3"), $.Single
        ]), 
      CurveSegment_IsArcreageSmallEnough
    );

    $.Method({Static:true , Public:false}, "RandomT", 
      new JSIL.MethodSignature($.Double, [
          $asm15.TypeRef("System.Random"), $.Double, 
          $.Double
        ]), 
      CurveSegment_RandomT
    );

    $.Method({Static:false, Public:true }, "SplitCurve", 
      new JSIL.MethodSignature(null, [
          $.Single, $jsilcore.TypeRef("System.Array", [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$asm15.TypeRef("System.Collections.Generic.List`1", [$asm07.TypeRef("Fusee.Math.Core.float3")])]), $jsilcore.TypeRef("JSIL.Reference", [$asm15.TypeRef("System.Collections.Generic.List`1", [$asm07.TypeRef("Fusee.Math.Core.float3")])])
        ]), 
      CurveSegment_SplitCurve
    );

    $.Field({Static:false, Public:true }, "Vertices", $asm15.TypeRef("System.Collections.Generic.IList`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Math.Core.CurveSegment+<CalcUniformPolyline>d__3 */ 

(function $lCalcUniformPolyline$gd__3$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm15.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm15.System.Threading.Thread)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm15.System.Collections.Generic.List$b1.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.Fusee.Math.Core.float3)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize(System.Array.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm07.Fusee.Math.Core.CurveSegment)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm15.System.NotSupportedException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm15.TypeRef("System.Collections.Generic.List`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm07.TypeRef("Fusee.Math.Core.float3")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm15.TypeRef("System.NotSupportedException"), null))) ();
  };


  function $lCalcUniformPolyline$gd__3__ctor ($l$g1__state) {
    this.$l$g1__state = ($l$g1__state | 0);
    this.$l$gl__initialThreadId = ($T01().get_CurrentThread().get_ManagedThreadId() | 0);
  }; 

  function $lCalcUniformPolyline$gd__3_MoveNext () {

    var $label0 = 0;
  $labelgroup0: 
    while (true) {
      switch ($label0) {
        case 0: /* $entry0 */ 
          switch (this.$l$g1__state) {
            case 0: 
              this.$l$g1__state = -1;
              var expr_3D = $S00().Construct();
              $S01().CallVirtual("Add", null, expr_3D, this.startPoint.MemberwiseClone());
              this.$lcontrolPoints$g5__1 = expr_3D;
              $T02().prototype.AddRange.call(this.$lcontrolPoints$g5__1, this.$l$g4__this.Vertices);
              this.$li$g5__2 = 0;
              $label0 = 1 /* goto IL_19B */ ;
              continue $labelgroup0;

            case 1: 
              this.$l$g1__state = -1;
              this.$lverts$g5__3 = JSIL.Array.New($T03(), (((this.degree | 0) + 1) | 0));
              this.$lj$g5__4 = 0;

              while ((this.$lj$g5__4 | 0) < (this.$lverts$g5__3.length | 0)) {
                this.$lverts$g5__3[this.$lj$g5__4] = (this.$lcontrolPoints$g5__1).get_Item((((this.$li$g5__2 | 0) + (this.$lj$g5__4 | 0)) | 0)).MemberwiseClone();
                var num = (this.$lj$g5__4 | 0);
                this.$lj$g5__4 = ((num + 1) | 0);
              }
              this.$lj$g5__5 = 1;
              break;

            case 2: 
              this.$l$g1__state = -1;
              num = (this.$lj$g5__5 | 0);
              this.$lj$g5__5 = ((num + 1) | 0);
              break;

            case 3: 
              this.$l$g1__state = -1;
              return false;

            default: 
              return false;

          }
          if ((this.$lj$g5__5 | 0) < (this.segmentsPerCurve | 0)) {
            this.$lt$g5__6 = +((+(this.$lj$g5__5) / +(this.segmentsPerCurve)));
            this.$lpoint$g5__7 = (this.$l$g4__this).CalcPoint(this.$lt$g5__6, this.$lverts$g5__3).MemberwiseClone();
            this.$l$g2__current = this.$lpoint$g5__7.MemberwiseClone();
            this.$l$g1__state = 2;
            return true;
          }
          this.$lverts$g5__3 = null;
          this.$li$g5__2 = (((this.$li$g5__2 | 0) + (this.degree | 0)) | 0);

          $label0 = 1 /* goto IL_19B */ ;
          continue $labelgroup0;
        case 1: /* IL_19B */ 
          if ((this.$li$g5__2 | 0) >= ((((this.$lcontrolPoints$g5__1).get_Count() | 0) - (this.degree | 0)) | 0)) {
            this.$l$g2__current = (this.$lcontrolPoints$g5__1).get_Item(((((this.$lcontrolPoints$g5__1).get_Count() | 0) - 1) | 0)).MemberwiseClone();
            this.$l$g1__state = 3;
            return true;
          }
          this.$l$g2__current = (this.$lcontrolPoints$g5__1).get_Item(this.$li$g5__2).MemberwiseClone();
          this.$l$g1__state = 1;
          return true;

          break $labelgroup0;
      }
    }
  }; 

  function $lCalcUniformPolyline$gd__3_System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator () {
    if (!(((this.$l$g1__state | 0) !== -2) || ((this.$l$gl__initialThreadId | 0) !== ($T01().get_CurrentThread().get_ManagedThreadId() | 0)))) {
      this.$l$g1__state = 0;
      var $lCalcUniformPolyline$gd__ = this;
    } else {
      $lCalcUniformPolyline$gd__ = new $thisType(0);
      $lCalcUniformPolyline$gd__.$l$g4__this = this.$l$g4__this;
    }
    $lCalcUniformPolyline$gd__.startPoint = this.$l$g3__startPoint.MemberwiseClone();
    $lCalcUniformPolyline$gd__.segmentsPerCurve = (this.$l$g3__segmentsPerCurve | 0);
    $lCalcUniformPolyline$gd__.degree = (this.$l$g3__degree | 0);
    return $lCalcUniformPolyline$gd__;
  }; 

  function $lCalcUniformPolyline$gd__3_System_Collections_Generic_IEnumerator$lFusee_Math_Core_float3$g_get_Current () {
    return this.$l$g2__current;
  }; 

  function $lCalcUniformPolyline$gd__3_System_Collections_IEnumerable_GetEnumerator () {
    return this.System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator();
  }; 

  function $lCalcUniformPolyline$gd__3_System_Collections_IEnumerator_get_Current () {
    return this.$l$g2__current;
  }; 

  function $lCalcUniformPolyline$gd__3_System_Collections_IEnumerator_Reset () {
    throw $S02().Construct();
  }; 

  function $lCalcUniformPolyline$gd__3_System_IDisposable_Dispose () {
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.Object"), 
      Name: "Fusee.Math.Core.CurveSegment+<CalcUniformPolyline>d__3", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Int32), 
      $lCalcUniformPolyline$gd__3__ctor
    )
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "MoveNext", 
      JSIL.MethodSignature.Return($.Boolean), 
      $lCalcUniformPolyline$gd__3_MoveNext
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "MoveNext");

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerable$lFusee.Math.Core.float3$g.GetEnumerator", 
      JSIL.MethodSignature.Return($asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")])), 
      $lCalcUniformPolyline$gd__3_System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator
    )
      .Overrides($asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), "GetEnumerator")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lFusee.Math.Core.float3$g.get_Current", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float3")), 
      $lCalcUniformPolyline$gd__3_System_Collections_Generic_IEnumerator$lFusee_Math_Core_float3$g_get_Current
    )
      .Overrides($asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), "get_Current")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerable.GetEnumerator", 
      JSIL.MethodSignature.Return($asm15.TypeRef("System.Collections.IEnumerator")), 
      $lCalcUniformPolyline$gd__3_System_Collections_IEnumerable_GetEnumerator
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerable"), "GetEnumerator")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.get_Current", 
      JSIL.MethodSignature.Return($.Object), 
      $lCalcUniformPolyline$gd__3_System_Collections_IEnumerator_get_Current
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "get_Current")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Reset", 
      JSIL.MethodSignature.Void, 
      $lCalcUniformPolyline$gd__3_System_Collections_IEnumerator_Reset
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "Reset")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.IDisposable.Dispose", 
      JSIL.MethodSignature.Void, 
      $lCalcUniformPolyline$gd__3_System_IDisposable_Dispose
    )
      .Overrides($asm15.TypeRef("System.IDisposable"), "Dispose")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Field({Static:false, Public:false}, "$l$g1__state", $.Int32);

    $.Field({Static:false, Public:false}, "$l$g2__current", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:false}, "$l$gl__initialThreadId", $.Int32);

    $.Field({Static:false, Public:false}, "startPoint", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:true }, "$l$g3__startPoint", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:false}, "segmentsPerCurve", $.Int32);

    $.Field({Static:false, Public:true }, "$l$g3__segmentsPerCurve", $.Int32);

    $.Field({Static:false, Public:false}, "degree", $.Int32);

    $.Field({Static:false, Public:true }, "$l$g3__degree", $.Int32);

    $.Field({Static:false, Public:true }, "$l$g4__this", $asm07.TypeRef("Fusee.Math.Core.CurveSegment"));

    $.Field({Static:false, Public:false}, "$lcontrolPoints$g5__1", $asm15.TypeRef("System.Collections.Generic.List`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]));

    $.Field({Static:false, Public:false}, "$li$g5__2", $.Int32);

    $.Field({Static:false, Public:false}, "$lverts$g5__3", $jsilcore.TypeRef("System.Array", [$asm07.TypeRef("Fusee.Math.Core.float3")]));

    $.Field({Static:false, Public:false}, "$lj$g5__4", $.Int32);

    $.Field({Static:false, Public:false}, "$lj$g5__5", $.Int32);

    $.Field({Static:false, Public:false}, "$lt$g5__6", $.Single);

    $.Field({Static:false, Public:false}, "$lpoint$g5__7", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lFusee.Math.Core.float3$g.Current", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Current", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
      /* 1 */ $asm15.TypeRef("System.Collections.IEnumerable"), 
      /* 2 */ $asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
      /* 3 */ $asm15.TypeRef("System.Collections.IEnumerator"), 
      /* 4 */ $asm15.TypeRef("System.IDisposable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class Fusee.Math.Core.CurveSegment+<CalcAdaptivePolylineWAngle>d__4 */ 

(function $lCalcAdaptivePolylineWAngle$gd__4$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm15.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm15.System.Threading.Thread)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm15.System.IDisposable)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm15.System.Exception)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm15.System.Collections.Generic.List$b1.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm15.System.Boolean)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm15.System.Collections.Generic.List$b1_Enumerator.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm07.Fusee.Math.Core.float3)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize(System.Array.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm07.Fusee.Math.Core.CurveSegment)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm15.System.NotSupportedException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm15.TypeRef("System.Collections.Generic.List`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm07.TypeRef("Fusee.Math.Core.float3")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm15.TypeRef("System.NotSupportedException"), null))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm15.System.IDisposable.Dispose)) ();
  };


  function $lCalcAdaptivePolylineWAngle$gd__4__ctor ($l$g1__state) {
    this.$l$g1__state = ($l$g1__state | 0);
    this.$l$gl__initialThreadId = ($T01().get_CurrentThread().get_ManagedThreadId() | 0);
  }; 

  function $lCalcAdaptivePolylineWAngle$gd__4_$l$gm__Finally1 () {
    this.$l$g1__state = -1;
    $IM00().Call(this.$l$gs__6, null);
  }; 

  function $lCalcAdaptivePolylineWAngle$gd__4_MoveNext ($exception) {
    try {

      var $label0 = 0;
    $labelgroup0: 
      while (true) {
        switch ($label0) {
          case 0: /* $entry0 */ 
            var num = (this.$l$g1__state | 0);
            if (num === 0) {
              this.$l$g1__state = -1;
              var expr_2E = $S00().Construct();
              $S01().CallVirtual("Add", null, expr_2E, this.startPoint.MemberwiseClone());
              this.$lcontrolPoints$g5__1 = expr_2E;
              $T04().prototype.AddRange.call(this.$lcontrolPoints$g5__1, this.$l$g4__this.Vertices);
              this.$li$g5__2 = 0;
              $label0 = 2 /* goto IL_188 */ ;
              continue $labelgroup0;
            }
            if (num !== 1) {
              var result = false;
              return result;
            }
            this.$l$g1__state = -3;

            $label0 = 1 /* goto IL_146 */ ;
            continue $labelgroup0;
          case 1: /* IL_146 */ 
            if ($T06().prototype.MoveNext.call(this.$l$gs__6)) {
              this.$lvert$g5__7 = $T06().prototype.get_Current.call(this.$l$gs__6).MemberwiseClone();
              this.$l$g2__current = this.$lvert$g5__7.MemberwiseClone();
              this.$l$g1__state = 1;
              result = true;
              return result;
            }
            this.$l$gm__Finally1();
            this.$l$gs__6 = new ($T06())();
            this.$lverts$g5__3 = null;
            this.$lvertList$g5__4 = null;
            this.$li$g5__2 = (((this.$li$g5__2 | 0) + (this.degree | 0)) | 0);

            $label0 = 2 /* goto IL_188 */ ;
            continue $labelgroup0;
          case 2: /* IL_188 */ 
            if ((this.$li$g5__2 | 0) < ((((this.$lcontrolPoints$g5__1).get_Count() | 0) - (this.degree | 0)) | 0)) {
              this.$lverts$g5__3 = JSIL.Array.New($T07(), (((this.degree | 0) + 1) | 0));
              this.$lj$g5__5 = 0;

              while ((this.$lj$g5__5 | 0) < (this.$lverts$g5__3.length | 0)) {
                this.$lverts$g5__3[this.$lj$g5__5] = (this.$lcontrolPoints$g5__1).get_Item((((this.$li$g5__2 | 0) + (this.$lj$g5__5 | 0)) | 0)).MemberwiseClone();
                var num2 = (this.$lj$g5__5 | 0);
                this.$lj$g5__5 = ((num2 + 1) | 0);
              }
              this.$lvertList$g5__4 = $S00().Construct();
              (this.$l$g4__this).AdaptiveSamplingWAngle(this.$lverts$g5__3, this.angle, /* ref */ new JSIL.MemberReference(this, "$lvertList$g5__4"));
              this.$l$gs__6 = $T04().prototype.GetEnumerator.call(this.$lvertList$g5__4);
              this.$l$g1__state = -3;
              $label0 = 1 /* goto IL_146 */ ;
              continue $labelgroup0;
            }
            result = false;

            break $labelgroup0;
        }
      }
    } catch ($exception) {
      this.System_IDisposable_Dispose();
      throw $exception;
    }
    return result;
  }; 

  function $lCalcAdaptivePolylineWAngle$gd__4_System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator () {
    if (!(((this.$l$g1__state | 0) !== -2) || ((this.$l$gl__initialThreadId | 0) !== ($T01().get_CurrentThread().get_ManagedThreadId() | 0)))) {
      this.$l$g1__state = 0;
      var $lCalcAdaptivePolylineWAngle$gd__ = this;
    } else {
      $lCalcAdaptivePolylineWAngle$gd__ = new $thisType(0);
      $lCalcAdaptivePolylineWAngle$gd__.$l$g4__this = this.$l$g4__this;
    }
    $lCalcAdaptivePolylineWAngle$gd__.startPoint = this.$l$g3__startPoint.MemberwiseClone();
    $lCalcAdaptivePolylineWAngle$gd__.angle = (this.$l$g3__angle | 0);
    $lCalcAdaptivePolylineWAngle$gd__.degree = (this.$l$g3__degree | 0);
    return $lCalcAdaptivePolylineWAngle$gd__;
  }; 

  function $lCalcAdaptivePolylineWAngle$gd__4_System_Collections_Generic_IEnumerator$lFusee_Math_Core_float3$g_get_Current () {
    return this.$l$g2__current;
  }; 

  function $lCalcAdaptivePolylineWAngle$gd__4_System_Collections_IEnumerable_GetEnumerator () {
    return this.System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator();
  }; 

  function $lCalcAdaptivePolylineWAngle$gd__4_System_Collections_IEnumerator_get_Current () {
    return this.$l$g2__current;
  }; 

  function $lCalcAdaptivePolylineWAngle$gd__4_System_Collections_IEnumerator_Reset () {
    throw $S02().Construct();
  }; 

  function $lCalcAdaptivePolylineWAngle$gd__4_System_IDisposable_Dispose () {
    var num = (this.$l$g1__state | 0);
    if ((num === -3) || (num === 1)) {
      try {
      } finally {
        this.$l$gm__Finally1();
      }
    }
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.Object"), 
      Name: "Fusee.Math.Core.CurveSegment+<CalcAdaptivePolylineWAngle>d__4", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Int32), 
      $lCalcAdaptivePolylineWAngle$gd__4__ctor
    )
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false}, "$l$gm__Finally1", 
      JSIL.MethodSignature.Void, 
      $lCalcAdaptivePolylineWAngle$gd__4_$l$gm__Finally1
    );

    $.Method({Static:false, Public:false, Virtual:true }, "MoveNext", 
      JSIL.MethodSignature.Return($.Boolean), 
      $lCalcAdaptivePolylineWAngle$gd__4_MoveNext
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "MoveNext");

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerable$lFusee.Math.Core.float3$g.GetEnumerator", 
      JSIL.MethodSignature.Return($asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")])), 
      $lCalcAdaptivePolylineWAngle$gd__4_System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator
    )
      .Overrides($asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), "GetEnumerator")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lFusee.Math.Core.float3$g.get_Current", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float3")), 
      $lCalcAdaptivePolylineWAngle$gd__4_System_Collections_Generic_IEnumerator$lFusee_Math_Core_float3$g_get_Current
    )
      .Overrides($asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), "get_Current")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerable.GetEnumerator", 
      JSIL.MethodSignature.Return($asm15.TypeRef("System.Collections.IEnumerator")), 
      $lCalcAdaptivePolylineWAngle$gd__4_System_Collections_IEnumerable_GetEnumerator
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerable"), "GetEnumerator")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.get_Current", 
      JSIL.MethodSignature.Return($.Object), 
      $lCalcAdaptivePolylineWAngle$gd__4_System_Collections_IEnumerator_get_Current
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "get_Current")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Reset", 
      JSIL.MethodSignature.Void, 
      $lCalcAdaptivePolylineWAngle$gd__4_System_Collections_IEnumerator_Reset
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "Reset")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.IDisposable.Dispose", 
      JSIL.MethodSignature.Void, 
      $lCalcAdaptivePolylineWAngle$gd__4_System_IDisposable_Dispose
    )
      .Overrides($asm15.TypeRef("System.IDisposable"), "Dispose")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Field({Static:false, Public:false}, "$l$g1__state", $.Int32);

    $.Field({Static:false, Public:false}, "$l$g2__current", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:false}, "$l$gl__initialThreadId", $.Int32);

    $.Field({Static:false, Public:false}, "startPoint", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:true }, "$l$g3__startPoint", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:false}, "angle", $.Int32);

    $.Field({Static:false, Public:true }, "$l$g3__angle", $.Int32);

    $.Field({Static:false, Public:false}, "degree", $.Int32);

    $.Field({Static:false, Public:true }, "$l$g3__degree", $.Int32);

    $.Field({Static:false, Public:true }, "$l$g4__this", $asm07.TypeRef("Fusee.Math.Core.CurveSegment"));

    $.Field({Static:false, Public:false}, "$lcontrolPoints$g5__1", $asm15.TypeRef("System.Collections.Generic.List`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]));

    $.Field({Static:false, Public:false}, "$li$g5__2", $.Int32);

    $.Field({Static:false, Public:false}, "$lverts$g5__3", $jsilcore.TypeRef("System.Array", [$asm07.TypeRef("Fusee.Math.Core.float3")]));

    $.Field({Static:false, Public:false}, "$lvertList$g5__4", $asm15.TypeRef("System.Collections.Generic.List`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]));

    $.Field({Static:false, Public:false}, "$lj$g5__5", $.Int32);

    $.Field({Static:false, Public:false}, "$l$gs__6", $asm15.TypeRef("System.Collections.Generic.List`1+Enumerator", [$asm07.TypeRef("Fusee.Math.Core.float3")]));

    $.Field({Static:false, Public:false}, "$lvert$g5__7", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lFusee.Math.Core.float3$g.Current", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Current", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
      /* 1 */ $asm15.TypeRef("System.Collections.IEnumerable"), 
      /* 2 */ $asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
      /* 3 */ $asm15.TypeRef("System.Collections.IEnumerator"), 
      /* 4 */ $asm15.TypeRef("System.IDisposable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class Fusee.Math.Core.CurveSegment+<CalcAdaptivePolylineWArcreage>d__5 */ 

(function $lCalcAdaptivePolylineWArcreage$gd__5$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm15.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm15.System.Threading.Thread)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm15.System.IDisposable)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm15.System.Exception)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm15.System.Collections.Generic.List$b1.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm15.System.Boolean)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm15.System.Collections.Generic.List$b1_Enumerator.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm07.Fusee.Math.Core.float3)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize(System.Array.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm07.Fusee.Math.Core.CurveSegment)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm15.System.NotSupportedException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm15.TypeRef("System.Collections.Generic.List`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm07.TypeRef("Fusee.Math.Core.float3")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm15.TypeRef("System.NotSupportedException"), null))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm15.System.IDisposable.Dispose)) ();
  };


  function $lCalcAdaptivePolylineWArcreage$gd__5__ctor ($l$g1__state) {
    this.$l$g1__state = ($l$g1__state | 0);
    this.$l$gl__initialThreadId = ($T01().get_CurrentThread().get_ManagedThreadId() | 0);
  }; 

  function $lCalcAdaptivePolylineWArcreage$gd__5_$l$gm__Finally1 () {
    this.$l$g1__state = -1;
    $IM00().Call(this.$l$gs__6, null);
  }; 

  function $lCalcAdaptivePolylineWArcreage$gd__5_MoveNext ($exception) {
    try {

      var $label0 = 0;
    $labelgroup0: 
      while (true) {
        switch ($label0) {
          case 0: /* $entry0 */ 
            var num = (this.$l$g1__state | 0);
            if (num === 0) {
              this.$l$g1__state = -1;
              var expr_2E = $S00().Construct();
              $S01().CallVirtual("Add", null, expr_2E, this.startPoint.MemberwiseClone());
              this.$lcontrolPoints$g5__1 = expr_2E;
              $T04().prototype.AddRange.call(this.$lcontrolPoints$g5__1, this.$l$g4__this.Vertices);
              this.$li$g5__2 = 0;
              $label0 = 2 /* goto IL_188 */ ;
              continue $labelgroup0;
            }
            if (num !== 1) {
              var result = false;
              return result;
            }
            this.$l$g1__state = -3;

            $label0 = 1 /* goto IL_146 */ ;
            continue $labelgroup0;
          case 1: /* IL_146 */ 
            if ($T06().prototype.MoveNext.call(this.$l$gs__6)) {
              this.$lvert$g5__7 = $T06().prototype.get_Current.call(this.$l$gs__6).MemberwiseClone();
              this.$l$g2__current = this.$lvert$g5__7.MemberwiseClone();
              this.$l$g1__state = 1;
              result = true;
              return result;
            }
            this.$l$gm__Finally1();
            this.$l$gs__6 = new ($T06())();
            this.$lverts$g5__3 = null;
            this.$lvertList$g5__4 = null;
            this.$li$g5__2 = (((this.$li$g5__2 | 0) + (this.degree | 0)) | 0);

            $label0 = 2 /* goto IL_188 */ ;
            continue $labelgroup0;
          case 2: /* IL_188 */ 
            if ((this.$li$g5__2 | 0) < ((((this.$lcontrolPoints$g5__1).get_Count() | 0) - (this.degree | 0)) | 0)) {
              this.$lverts$g5__3 = JSIL.Array.New($T07(), (((this.degree | 0) + 1) | 0));
              this.$lj$g5__5 = 0;

              while ((this.$lj$g5__5 | 0) < (this.$lverts$g5__3.length | 0)) {
                this.$lverts$g5__3[this.$lj$g5__5] = (this.$lcontrolPoints$g5__1).get_Item((((this.$li$g5__2 | 0) + (this.$lj$g5__5 | 0)) | 0)).MemberwiseClone();
                var num2 = (this.$lj$g5__5 | 0);
                this.$lj$g5__5 = ((num2 + 1) | 0);
              }
              this.$lvertList$g5__4 = $S00().Construct();
              (this.$l$g4__this).AdaptiveSamplingWArcreage(this.$lverts$g5__3, this.acreage, /* ref */ new JSIL.MemberReference(this, "$lvertList$g5__4"));
              this.$l$gs__6 = $T04().prototype.GetEnumerator.call(this.$lvertList$g5__4);
              this.$l$g1__state = -3;
              $label0 = 1 /* goto IL_146 */ ;
              continue $labelgroup0;
            }
            result = false;

            break $labelgroup0;
        }
      }
    } catch ($exception) {
      this.System_IDisposable_Dispose();
      throw $exception;
    }
    return result;
  }; 

  function $lCalcAdaptivePolylineWArcreage$gd__5_System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator () {
    if (!(((this.$l$g1__state | 0) !== -2) || ((this.$l$gl__initialThreadId | 0) !== ($T01().get_CurrentThread().get_ManagedThreadId() | 0)))) {
      this.$l$g1__state = 0;
      var $lCalcAdaptivePolylineWArcreage$gd__ = this;
    } else {
      $lCalcAdaptivePolylineWArcreage$gd__ = new $thisType(0);
      $lCalcAdaptivePolylineWArcreage$gd__.$l$g4__this = this.$l$g4__this;
    }
    $lCalcAdaptivePolylineWArcreage$gd__.startPoint = this.$l$g3__startPoint.MemberwiseClone();
    $lCalcAdaptivePolylineWArcreage$gd__.acreage = +this.$l$g3__acreage;
    $lCalcAdaptivePolylineWArcreage$gd__.degree = (this.$l$g3__degree | 0);
    return $lCalcAdaptivePolylineWArcreage$gd__;
  }; 

  function $lCalcAdaptivePolylineWArcreage$gd__5_System_Collections_Generic_IEnumerator$lFusee_Math_Core_float3$g_get_Current () {
    return this.$l$g2__current;
  }; 

  function $lCalcAdaptivePolylineWArcreage$gd__5_System_Collections_IEnumerable_GetEnumerator () {
    return this.System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator();
  }; 

  function $lCalcAdaptivePolylineWArcreage$gd__5_System_Collections_IEnumerator_get_Current () {
    return this.$l$g2__current;
  }; 

  function $lCalcAdaptivePolylineWArcreage$gd__5_System_Collections_IEnumerator_Reset () {
    throw $S02().Construct();
  }; 

  function $lCalcAdaptivePolylineWArcreage$gd__5_System_IDisposable_Dispose () {
    var num = (this.$l$g1__state | 0);
    if ((num === -3) || (num === 1)) {
      try {
      } finally {
        this.$l$gm__Finally1();
      }
    }
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.Object"), 
      Name: "Fusee.Math.Core.CurveSegment+<CalcAdaptivePolylineWArcreage>d__5", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Int32), 
      $lCalcAdaptivePolylineWArcreage$gd__5__ctor
    )
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false}, "$l$gm__Finally1", 
      JSIL.MethodSignature.Void, 
      $lCalcAdaptivePolylineWArcreage$gd__5_$l$gm__Finally1
    );

    $.Method({Static:false, Public:false, Virtual:true }, "MoveNext", 
      JSIL.MethodSignature.Return($.Boolean), 
      $lCalcAdaptivePolylineWArcreage$gd__5_MoveNext
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "MoveNext");

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerable$lFusee.Math.Core.float3$g.GetEnumerator", 
      JSIL.MethodSignature.Return($asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")])), 
      $lCalcAdaptivePolylineWArcreage$gd__5_System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator
    )
      .Overrides($asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), "GetEnumerator")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lFusee.Math.Core.float3$g.get_Current", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float3")), 
      $lCalcAdaptivePolylineWArcreage$gd__5_System_Collections_Generic_IEnumerator$lFusee_Math_Core_float3$g_get_Current
    )
      .Overrides($asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), "get_Current")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerable.GetEnumerator", 
      JSIL.MethodSignature.Return($asm15.TypeRef("System.Collections.IEnumerator")), 
      $lCalcAdaptivePolylineWArcreage$gd__5_System_Collections_IEnumerable_GetEnumerator
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerable"), "GetEnumerator")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.get_Current", 
      JSIL.MethodSignature.Return($.Object), 
      $lCalcAdaptivePolylineWArcreage$gd__5_System_Collections_IEnumerator_get_Current
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "get_Current")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Reset", 
      JSIL.MethodSignature.Void, 
      $lCalcAdaptivePolylineWArcreage$gd__5_System_Collections_IEnumerator_Reset
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "Reset")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.IDisposable.Dispose", 
      JSIL.MethodSignature.Void, 
      $lCalcAdaptivePolylineWArcreage$gd__5_System_IDisposable_Dispose
    )
      .Overrides($asm15.TypeRef("System.IDisposable"), "Dispose")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Field({Static:false, Public:false}, "$l$g1__state", $.Int32);

    $.Field({Static:false, Public:false}, "$l$g2__current", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:false}, "$l$gl__initialThreadId", $.Int32);

    $.Field({Static:false, Public:false}, "startPoint", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:true }, "$l$g3__startPoint", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:false}, "acreage", $.Single);

    $.Field({Static:false, Public:true }, "$l$g3__acreage", $.Single);

    $.Field({Static:false, Public:false}, "degree", $.Int32);

    $.Field({Static:false, Public:true }, "$l$g3__degree", $.Int32);

    $.Field({Static:false, Public:true }, "$l$g4__this", $asm07.TypeRef("Fusee.Math.Core.CurveSegment"));

    $.Field({Static:false, Public:false}, "$lcontrolPoints$g5__1", $asm15.TypeRef("System.Collections.Generic.List`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]));

    $.Field({Static:false, Public:false}, "$li$g5__2", $.Int32);

    $.Field({Static:false, Public:false}, "$lverts$g5__3", $jsilcore.TypeRef("System.Array", [$asm07.TypeRef("Fusee.Math.Core.float3")]));

    $.Field({Static:false, Public:false}, "$lvertList$g5__4", $asm15.TypeRef("System.Collections.Generic.List`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]));

    $.Field({Static:false, Public:false}, "$lj$g5__5", $.Int32);

    $.Field({Static:false, Public:false}, "$l$gs__6", $asm15.TypeRef("System.Collections.Generic.List`1+Enumerator", [$asm07.TypeRef("Fusee.Math.Core.float3")]));

    $.Field({Static:false, Public:false}, "$lvert$g5__7", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lFusee.Math.Core.float3$g.Current", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Current", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
      /* 1 */ $asm15.TypeRef("System.Collections.IEnumerable"), 
      /* 2 */ $asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
      /* 3 */ $asm15.TypeRef("System.Collections.IEnumerator"), 
      /* 4 */ $asm15.TypeRef("System.IDisposable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class Fusee.Math.Core.LinearSegment */ 

(function LinearSegment$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.Fusee.Math.Core.CurveSegment)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm07.Fusee.Math.Core.float3)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm15.System.Int32)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.Fusee.Math.Core.LinearSegment_$lCalcUniformPolyline$gd__0)) ();
  };


  function LinearSegment__ctor () {
    $T00().prototype._ctor.call(this);
  }; 

  function LinearSegment_CalcUniformPolyline (startPoint, segmentsPerCurve, degree) {
    var expr_07 = new ($T03())(-2);
    expr_07.$l$g4__this = this;
    expr_07.$l$g3__startPoint = startPoint.MemberwiseClone();
    expr_07.$l$g3__segmentsPerCurve = (segmentsPerCurve | 0);
    expr_07.$l$g3__degree = (degree | 0);
    return expr_07;
  }; 

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("Fusee.Math.Core.CurveSegment"), 
      Name: "Fusee.Math.Core.LinearSegment", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      LinearSegment__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "CalcUniformPolyline", 
      new JSIL.MethodSignature($asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), [
          $asm07.TypeRef("Fusee.Math.Core.float3"), $.Int32, 
          $.Int32
        ]), 
      LinearSegment_CalcUniformPolyline
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Math.Core.LinearSegment+<CalcUniformPolyline>d__0 */ 

(function $lCalcUniformPolyline$gd__0$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm15.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm15.System.Threading.Thread)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm15.System.Collections.Generic.List$b1.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.Fusee.Math.Core.float3)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize(System.Array.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm15.System.NotSupportedException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm15.TypeRef("System.Collections.Generic.List`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm07.TypeRef("Fusee.Math.Core.float3")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [$asm15.TypeRef("System.Single"), $asm07.TypeRef("Fusee.Math.Core.float3")]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.ConstructorSignature($asm15.TypeRef("System.NotSupportedException"), null))) ();
  };


  function $lCalcUniformPolyline$gd__0__ctor ($l$g1__state) {
    this.$l$g1__state = ($l$g1__state | 0);
    this.$l$gl__initialThreadId = ($T01().get_CurrentThread().get_ManagedThreadId() | 0);
  }; 

  function $lCalcUniformPolyline$gd__0_MoveNext () {

    var $label0 = 0;
  $labelgroup0: 
    while (true) {
      switch ($label0) {
        case 0: /* $entry0 */ 
          switch (this.$l$g1__state) {
            case 0: 
              this.$l$g1__state = -1;
              var expr_3D = $S00().Construct();
              $S01().CallVirtual("Add", null, expr_3D, this.startPoint.MemberwiseClone());
              this.$lcontrolPoints$g5__1 = expr_3D;
              $T02().prototype.AddRange.call(this.$lcontrolPoints$g5__1, this.$l$g4__this.Vertices);
              this.$li$g5__2 = 0;
              $label0 = 1 /* goto IL_1C3 */ ;
              continue $labelgroup0;

            case 1: 
              this.$l$g1__state = -1;
              this.$lverts$g5__3 = JSIL.Array.New($T03(), (((this.degree | 0) + 1) | 0));
              this.$lj$g5__4 = 0;

              while ((this.$lj$g5__4 | 0) < (this.$lverts$g5__3.length | 0)) {
                this.$lverts$g5__3[this.$lj$g5__4] = (this.$lcontrolPoints$g5__1).get_Item((((this.$li$g5__2 | 0) + (this.$lj$g5__4 | 0)) | 0)).MemberwiseClone();
                var num = (this.$lj$g5__4 | 0);
                this.$lj$g5__4 = ((num + 1) | 0);
              }
              this.$lj$g5__5 = 1;
              break;

            case 2: 
              this.$l$g1__state = -1;
              num = (this.$lj$g5__5 | 0);
              this.$lj$g5__5 = ((num + 1) | 0);
              break;

            case 3: 
              this.$l$g1__state = -1;
              return false;

            default: 
              return false;

          }
          if ((this.$lj$g5__5 | 0) < (this.segmentsPerCurve | 0)) {
            this.$lt$g5__6 = +((+(this.$lj$g5__5) / +(this.segmentsPerCurve)));
            this.$lpoint$g5__7 = $T03().op_Addition(
              $S02().CallStatic($T03(), "op_Multiply", null, 1 - +this.$lt$g5__6, this.$lverts$g5__3[0].MemberwiseClone()).MemberwiseClone(), 
              $S02().CallStatic($T03(), "op_Multiply", null, this.$lt$g5__6, this.$lverts$g5__3[1].MemberwiseClone())
            );
            this.$l$g2__current = this.$lpoint$g5__7.MemberwiseClone();
            this.$l$g1__state = 2;
            return true;
          }
          this.$lverts$g5__3 = null;
          this.$li$g5__2 = (((this.$li$g5__2 | 0) + (this.degree | 0)) | 0);

          $label0 = 1 /* goto IL_1C3 */ ;
          continue $labelgroup0;
        case 1: /* IL_1C3 */ 
          if ((this.$li$g5__2 | 0) >= ((((this.$lcontrolPoints$g5__1).get_Count() | 0) - (this.degree | 0)) | 0)) {
            this.$l$g2__current = (this.$lcontrolPoints$g5__1).get_Item(((((this.$lcontrolPoints$g5__1).get_Count() | 0) - 1) | 0)).MemberwiseClone();
            this.$l$g1__state = 3;
            return true;
          }
          this.$l$g2__current = (this.$lcontrolPoints$g5__1).get_Item(this.$li$g5__2).MemberwiseClone();
          this.$l$g1__state = 1;
          return true;

          break $labelgroup0;
      }
    }
  }; 

  function $lCalcUniformPolyline$gd__0_System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator () {
    if (!(((this.$l$g1__state | 0) !== -2) || ((this.$l$gl__initialThreadId | 0) !== ($T01().get_CurrentThread().get_ManagedThreadId() | 0)))) {
      this.$l$g1__state = 0;
      var $lCalcUniformPolyline$gd__ = this;
    } else {
      $lCalcUniformPolyline$gd__ = new $thisType(0);
      $lCalcUniformPolyline$gd__.$l$g4__this = this.$l$g4__this;
    }
    $lCalcUniformPolyline$gd__.startPoint = this.$l$g3__startPoint.MemberwiseClone();
    $lCalcUniformPolyline$gd__.segmentsPerCurve = (this.$l$g3__segmentsPerCurve | 0);
    $lCalcUniformPolyline$gd__.degree = (this.$l$g3__degree | 0);
    return $lCalcUniformPolyline$gd__;
  }; 

  function $lCalcUniformPolyline$gd__0_System_Collections_Generic_IEnumerator$lFusee_Math_Core_float3$g_get_Current () {
    return this.$l$g2__current;
  }; 

  function $lCalcUniformPolyline$gd__0_System_Collections_IEnumerable_GetEnumerator () {
    return this.System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator();
  }; 

  function $lCalcUniformPolyline$gd__0_System_Collections_IEnumerator_get_Current () {
    return this.$l$g2__current;
  }; 

  function $lCalcUniformPolyline$gd__0_System_Collections_IEnumerator_Reset () {
    throw $S03().Construct();
  }; 

  function $lCalcUniformPolyline$gd__0_System_IDisposable_Dispose () {
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.Object"), 
      Name: "Fusee.Math.Core.LinearSegment+<CalcUniformPolyline>d__0", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Int32), 
      $lCalcUniformPolyline$gd__0__ctor
    )
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "MoveNext", 
      JSIL.MethodSignature.Return($.Boolean), 
      $lCalcUniformPolyline$gd__0_MoveNext
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "MoveNext");

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerable$lFusee.Math.Core.float3$g.GetEnumerator", 
      JSIL.MethodSignature.Return($asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")])), 
      $lCalcUniformPolyline$gd__0_System_Collections_Generic_IEnumerable$lFusee_Math_Core_float3$g_GetEnumerator
    )
      .Overrides($asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), "GetEnumerator")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lFusee.Math.Core.float3$g.get_Current", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float3")), 
      $lCalcUniformPolyline$gd__0_System_Collections_Generic_IEnumerator$lFusee_Math_Core_float3$g_get_Current
    )
      .Overrides($asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), "get_Current")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerable.GetEnumerator", 
      JSIL.MethodSignature.Return($asm15.TypeRef("System.Collections.IEnumerator")), 
      $lCalcUniformPolyline$gd__0_System_Collections_IEnumerable_GetEnumerator
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerable"), "GetEnumerator")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.get_Current", 
      JSIL.MethodSignature.Return($.Object), 
      $lCalcUniformPolyline$gd__0_System_Collections_IEnumerator_get_Current
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "get_Current")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Reset", 
      JSIL.MethodSignature.Void, 
      $lCalcUniformPolyline$gd__0_System_Collections_IEnumerator_Reset
    )
      .Overrides($asm15.TypeRef("System.Collections.IEnumerator"), "Reset")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "System.IDisposable.Dispose", 
      JSIL.MethodSignature.Void, 
      $lCalcUniformPolyline$gd__0_System_IDisposable_Dispose
    )
      .Overrides($asm15.TypeRef("System.IDisposable"), "Dispose")
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerHiddenAttribute"));

    $.Field({Static:false, Public:false}, "$l$g1__state", $.Int32);

    $.Field({Static:false, Public:false}, "$l$g2__current", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:false}, "$l$gl__initialThreadId", $.Int32);

    $.Field({Static:false, Public:false}, "startPoint", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:true }, "$l$g3__startPoint", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:false}, "segmentsPerCurve", $.Int32);

    $.Field({Static:false, Public:true }, "$l$g3__segmentsPerCurve", $.Int32);

    $.Field({Static:false, Public:false}, "degree", $.Int32);

    $.Field({Static:false, Public:true }, "$l$g3__degree", $.Int32);

    $.Field({Static:false, Public:true }, "$l$g4__this", $asm07.TypeRef("Fusee.Math.Core.LinearSegment"));

    $.Field({Static:false, Public:false}, "$lcontrolPoints$g5__1", $asm15.TypeRef("System.Collections.Generic.List`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]));

    $.Field({Static:false, Public:false}, "$li$g5__2", $.Int32);

    $.Field({Static:false, Public:false}, "$lverts$g5__3", $jsilcore.TypeRef("System.Array", [$asm07.TypeRef("Fusee.Math.Core.float3")]));

    $.Field({Static:false, Public:false}, "$lj$g5__4", $.Int32);

    $.Field({Static:false, Public:false}, "$lj$g5__5", $.Int32);

    $.Field({Static:false, Public:false}, "$lt$g5__6", $.Single);

    $.Field({Static:false, Public:false}, "$lpoint$g5__7", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lFusee.Math.Core.float3$g.Current", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Current", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm15.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
      /* 1 */ $asm15.TypeRef("System.Collections.IEnumerable"), 
      /* 2 */ $asm15.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
      /* 3 */ $asm15.TypeRef("System.Collections.IEnumerator"), 
      /* 4 */ $asm15.TypeRef("System.IDisposable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class Fusee.Math.Core.BezierConicSegment */ 

(function BezierConicSegment$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.Fusee.Math.Core.CurveSegment)) ();
  };


  function BezierConicSegment__ctor () {
    $T00().prototype._ctor.call(this);
  }; 

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("Fusee.Math.Core.CurveSegment"), 
      Name: "Fusee.Math.Core.BezierConicSegment", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      BezierConicSegment__ctor
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Math.Core.BezierCubicSegment */ 

(function BezierCubicSegment$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.Fusee.Math.Core.CurveSegment)) ();
  };


  function BezierCubicSegment__ctor () {
    $T00().prototype._ctor.call(this);
  }; 

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("Fusee.Math.Core.CurveSegment"), 
      Name: "Fusee.Math.Core.BezierCubicSegment", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      BezierCubicSegment__ctor
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Math.Core.double2 */ 

(function double2$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm15.System.Double)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm07.Fusee.Math.Core.double3)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm07.Fusee.Math.Core.double4)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm15.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm15.System.Boolean)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm15.System.Math)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm07.Fusee.Math.Core.M)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm07.Fusee.Math.Core.Converter$b2.Of($asm15.System.String, $asm07.Fusee.Math.Core.double2))) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm15.System.String)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm07.Fusee.Math.Core.QuaternionD)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.double2"), [$asm15.TypeRef("System.Double"), $asm15.TypeRef("System.Double")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.double2"), [$asm15.TypeRef("System.Double"), $asm07.TypeRef("Fusee.Math.Core.double2")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double2")]), $asm15.TypeRef("System.Double"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double2")])
      ]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double2")]), $asm15.TypeRef("System.Double"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double2")])
      ]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double2")]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double2")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double2")])
      ]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm15.TypeRef("System.Double"), [$asm15.TypeRef("System.Double")]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double2")]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double2")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double2")])
      ]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.QuaternionD")]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.QuaternionD")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.QuaternionD")])
      ]))) ();
  };


  function double2__ctor$00 (x, y) {
    this.x = +x;
    this.y = +y;
  }; 

  function double2__ctor$01 (v) {
    this.x = +v.x;
    this.y = +v.y;
  }; 

  function double2__ctor$02 (v) {
    this.x = +v.x;
    this.y = +v.y;
  }; 

  function double2__ctor$03 (v) {
    this.x = +v.x;
    this.y = +v.y;
  }; 

  function double2_Add$04 (right) {
    this.x = +this.x + +right.x;
    this.y = +this.y + +right.y;
  }; 

  function double2_Add$05 (/* ref */ right) {
    this.x = +this.x + +right.get().x;
    this.y = +this.y + +right.get().y;
  }; 

  function double2_Add$06 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Add(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  }; 

  function double2_Add$07 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x + +b.get().x), (+a.get().y + +b.get().y)));
  }; 

  function double2_Barycentric (a, b, c, u, v) {
    return $thisType.op_Addition(
      $thisType.op_Addition(
        $S01().CallStatic($thisType, "op_Multiply", null, u, a.MemberwiseClone()).MemberwiseClone(), 
        $S01().CallStatic($thisType, "op_Multiply", null, v, b.MemberwiseClone())
      ).MemberwiseClone(), 
      $S01().CallStatic($thisType, "op_Multiply", null, (1 - +u) - +v, c.MemberwiseClone())
    );
  }; 

  function double2_Clamp$08 (vec, min, max) {
    vec.x = +(
      (+vec.x < +min.x)
         ? min.x
         : (
          (+vec.x > +max.x)
             ? max.x
             : vec.x)
    )
    ;
    vec.y = +(
      (+vec.y < +min.y)
         ? min.y
         : (
          (+vec.y > +max.y)
             ? max.y
             : vec.y)
    )
    ;
    return vec;
  }; 

  function double2_Clamp$09 (/* ref */ vec, /* ref */ min, /* ref */ max, /* ref */ result) {
    result.get().x = +(
      (+vec.get().x < +min.get().x)
         ? min.get().x
         : (
          (+vec.get().x > +max.get().x)
             ? max.get().x
             : vec.get().x)
    )
    ;
    result.get().y = +(
      (+vec.get().y < +min.get().y)
         ? min.get().y
         : (
          (+vec.get().y > +max.get().y)
             ? max.get().y
             : vec.get().y)
    )
    ;
  }; 

  function double2_ComponentMax$0A (a, b) {
    a.x = +(
      (+a.x > +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y > +b.y)
         ? a.y
         : b.y)
    ;
    return a;
  }; 

  function double2_ComponentMax$0B (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x > +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y > +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
  }; 

  function double2_ComponentMin$0C (a, b) {
    a.x = +(
      (+a.x < +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y < +b.y)
         ? a.y
         : b.y)
    ;
    return a;
  }; 

  function double2_ComponentMin$0D (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x < +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y < +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
  }; 

  function double2_Div$0E (f) {
    var mult = +((1 / +f));
    this.x = +this.x * mult;
    this.y = +this.y * mult;
  }; 

  function double2_Div$0F (a, f) {
    var mult = +((1 / +f));
    a.x = +a.x * mult;
    a.y = +a.y * mult;
    return a;
  }; 

  function double2_Div$10 (/* ref */ a, f, /* ref */ result) {
    var mult = +((1 / +f));
    result.get().x = +a.get().x * mult;
    result.get().y = +a.get().y * mult;
  }; 

  function double2_Divide$11 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S02().CallStatic($thisType, "Divide", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  }; 

  function double2_Divide$12 (/* ref */ vector, scale, /* ref */ result) {
    $S03().CallStatic($thisType, "Multiply", null, /* ref */ vector, +((1 / +scale)), /* ref */ result);
  }; 

  function double2_Divide$13 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S04().CallStatic($thisType, "Divide", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  }; 

  function double2_Divide$14 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct(+((+vector.get().x / +scale.get().x)), +((+vector.get().y / +scale.get().y))));
  }; 

  function double2_Dot$15 (left, right) {
    return ((+left.x * +right.x) + (+left.y * +right.y));
  }; 

  function double2_Dot$16 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set((+left.get().x * +right.get().x) + (+left.get().y * +right.get().y));
  }; 

  function double2_Object_Equals (obj) {
    var flag = !$thisType.$Is(obj);
    return (!flag && this.Equals($thisType.$Cast(obj)));
  }; 

  function double2_Equals$17 (other) {
    return ((+this.x === +other.x) && (+this.y === +other.y));
  }; 

  function double2_get_Length () {
    return Math.sqrt(((+this.x * +this.x) + (+this.y * +this.y)));
  }; 

  function double2_get_LengthFast () {
    return +((1 / +$S05().CallStatic($T06(), "InverseSqrtFast", null, (+this.x * +this.x) + (+this.y * +this.y))));
  }; 

  function double2_get_LengthSquared () {
    return ((+this.x * +this.x) + (+this.y * +this.y));
  }; 

  function double2_get_Parse () {
    return $thisType.double2$Parse$value;
  }; 

  function double2_get_PerpendicularLeft () {
    return $S00().Construct(-this.y, this.x);
  }; 

  function double2_get_PerpendicularRight () {
    return $S00().Construct(this.y, -this.x);
  }; 

  function double2_GetBarycentric (a, b, c, point, /* ref */ u, /* ref */ v) {
    var cb = $thisType.op_Subtraction(b.MemberwiseClone(), c);
    var cp = $thisType.op_Subtraction(point.MemberwiseClone(), c);
    var ca = $thisType.op_Subtraction(a.MemberwiseClone(), c);
    var denom = (+cb.y * +ca.x) - (+cb.x * +ca.y);
    u.set(+((((+cb.y * +cp.x) - (+cb.x * +cp.y)) / denom)));
    v.set(+((((+ca.x * +cp.y) - (+ca.y * +cp.x)) / denom)));
  }; 

  function double2_GetHashCode () {
    return (((this.x).GetHashCode() | 0) ^ ((this.y).GetHashCode() | 0));
  }; 

  function double2_IsTriangleCW (a, b, c) {
    var cb = $thisType.op_Subtraction(b.MemberwiseClone(), c);
    var ca = $thisType.op_Subtraction(a.MemberwiseClone(), c);
    var z = (+ca.x * +cb.y) - (+ca.y * +cb.x);
    return (z < 0);
  }; 

  function double2_Lerp$18 (a, b, blend) {
    a.x = (+blend * (+b.x - +a.x)) + +a.x;
    a.y = (+blend * (+b.y - +a.y)) + +a.y;
    return a;
  }; 

  function double2_Lerp$19 (/* ref */ a, /* ref */ b, blend, /* ref */ result) {
    result.get().x = (+blend * (+b.get().x - +a.get().x)) + +a.get().x;
    result.get().y = (+blend * (+b.get().y - +a.get().y)) + +a.get().y;
  }; 

  function double2_Max (left, right) {
    return (
      (+left.get_LengthSquared() >= +right.get_LengthSquared())
         ? left
         : right)
    ;
  }; 

  function double2_Min (left, right) {
    return (
      (+left.get_LengthSquared() < +right.get_LengthSquared())
         ? left
         : right)
    ;
  }; 

  function double2_Mult$1A (f) {
    this.x = +this.x * +f;
    this.y = +this.y * +f;
  }; 

  function double2_Mult$1B (a, f) {
    a.x = +a.x * +f;
    a.y = +a.y * +f;
    return a;
  }; 

  function double2_Mult$1C (/* ref */ a, f, /* ref */ result) {
    result.get().x = +a.get().x * +f;
    result.get().y = +a.get().y * +f;
  }; 

  function double2_Multiply$1D ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S03().CallStatic($thisType, "Multiply", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  }; 

  function double2_Multiply$1E (/* ref */ vector, scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale), (+vector.get().y * +scale)));
  }; 

  function double2_Multiply$1F ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S06().CallStatic($thisType, "Multiply", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  }; 

  function double2_Multiply$20 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale.get().x), (+vector.get().y * +scale.get().y)));
  }; 

  function double2_Normalize$21 () {
    var scale = +((1 / +this.get_Length()));
    this.x = +this.x * scale;
    this.y = +this.y * scale;
  }; 

  function double2_Normalize$22 (vec) {
    var scale = +((1 / +vec.get_Length()));
    vec.x = +vec.x * scale;
    vec.y = +vec.y * scale;
    return vec;
  }; 

  function double2_Normalize$23 (/* ref */ vec, /* ref */ result) {
    var scale = +((1 / +(vec.get()).get_Length()));
    result.get().x = +vec.get().x * scale;
    result.get().y = +vec.get().y * scale;
  }; 

  function double2_NormalizeFast$24 () {
    var scale = +$S05().CallStatic($T06(), "InverseSqrtFast", null, (+this.x * +this.x) + (+this.y * +this.y));
    this.x = +this.x * scale;
    this.y = +this.y * scale;
  }; 

  function double2_NormalizeFast$25 (vec) {
    var scale = +$S05().CallStatic($T06(), "InverseSqrtFast", null, (+vec.x * +vec.x) + (+vec.y * +vec.y));
    vec.x = +vec.x * scale;
    vec.y = +vec.y * scale;
    return vec;
  }; 

  function double2_NormalizeFast$26 (/* ref */ vec, /* ref */ result) {
    var scale = +$S05().CallStatic($T06(), "InverseSqrtFast", null, (+vec.get().x * +vec.get().x) + (+vec.get().y * +vec.get().y));
    result.get().x = +vec.get().x * scale;
    result.get().y = +vec.get().y * scale;
  }; 

  function double2_op_Addition (left, right) {
    left.x = +left.x + +right.x;
    left.y = +left.y + +right.y;
    return left;
  }; 

  function double2_op_Division (vec, scale) {
    var mult = +((1 / +scale));
    vec.x = +vec.x * mult;
    vec.y = +vec.y * mult;
    return vec;
  }; 

  function double2_op_Equality (left, right) {
    return left.Equals(right);
  }; 

  function double2_op_Inequality (left, right) {
    return !left.Equals(right);
  }; 

  function double2_op_Multiply$27 (vec, scale) {
    vec.x = +vec.x * +scale;
    vec.y = +vec.y * +scale;
    return vec;
  }; 

  function double2_op_Multiply$28 (scale, vec) {
    vec.x = +vec.x * +scale;
    vec.y = +vec.y * +scale;
    return vec;
  }; 

  function double2_op_Subtraction (left, right) {
    left.x = +left.x - +right.x;
    left.y = +left.y - +right.y;
    return left;
  }; 

  function double2_op_UnaryNegation (vec) {
    vec.x = -vec.x;
    vec.y = -vec.y;
    return vec;
  }; 

  function double2_Scale$29 (sx, sy) {
    this.x = +this.x * +sx;
    this.y = +this.y * +sy;
  }; 

  function double2_Scale$2A (scale) {
    this.x = +this.x * +scale.x;
    this.y = +this.y * +scale.y;
  }; 

  function double2_Scale$2B (/* ref */ scale) {
    this.x = +this.x * +scale.get().x;
    this.y = +this.y * +scale.get().y;
  }; 

  function double2_set_Parse (value) {
    $thisType.double2$Parse$value = value;
  }; 

  function double2_Sub$2C (right) {
    this.x = +this.x - +right.x;
    this.y = +this.y - +right.y;
  }; 

  function double2_Sub$2D (/* ref */ right) {
    this.x = +this.x - +right.get().x;
    this.y = +this.y - +right.get().y;
  }; 

  function double2_Sub$2E (a, b) {
    a.x = +a.x - +b.x;
    a.y = +a.y - +b.y;
    return a;
  }; 

  function double2_Sub$2F (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +a.get().x - +b.get().x;
    result.get().y = +a.get().y - +b.get().y;
  }; 

  function double2_Subtract$30 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Subtract(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  }; 

  function double2_Subtract$31 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x - +b.get().x), (+a.get().y - +b.get().y)));
  }; 

  function double2_ToArray () {
    return JSIL.Array.New($T00(), [this.x, this.y]);
  }; 

  function double2_toString () {
    return $T08().Format("({0}, {1})", JSIL.Array.New($T03(), [$T00().$Box(this.x), $T00().$Box(this.y)]));
  }; 

  function double2_Transform$32 ($vec, $quat) {
    var quat = new JSIL.BoxedVariable($quat.MemberwiseClone());
    var vec = new JSIL.BoxedVariable($vec.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Transform(/* ref */ vec, /* ref */ quat, /* ref */ result);
    return result.get();
  }; 

  function double2_Transform$33 (/* ref */ vec, /* ref */ quat, /* ref */ result) {
    var i = new JSIL.BoxedVariable(new ($T09())());
    var v = new JSIL.BoxedVariable(new ($T09())());
    var t = new JSIL.BoxedVariable(new ($T09())());
    $T09().prototype._ctor.call(v.get().MemberwiseClone(), vec.get().x, vec.get().y, 0, 0);
    $T09().Invert(/* ref */ quat, /* ref */ i);
    $S07().CallStatic($T09(), "Multiply", null, /* ref */ quat, /* ref */ v, /* ref */ t);
    $S07().CallStatic($T09(), "Multiply", null, /* ref */ t, /* ref */ i, /* ref */ v);
    result.set($S00().Construct((v.get()).get_x(), (v.get()).get_y()));
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.Core.double2", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 2, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Double, $.Double]), 
      double2__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Type), 
      double2__ctor$01
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"));

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.double3")), 
      double2__ctor$02
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"));

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.double4")), 
      double2__ctor$03
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"));

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($.Type), 
      double2_Add$04
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      double2_Add$05
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double2_Add$06
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Add$07
    );

    $.Method({Static:true , Public:true }, "Barycentric", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type, $.Double, 
          $.Double
        ]), 
      double2_Barycentric
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type
        ]), 
      double2_Clamp$08
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Clamp$09
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double2_ComponentMax$0A
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_ComponentMax$0B
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double2_ComponentMin$0C
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_ComponentMin$0D
    );

    $.Method({Static:false, Public:true }, "Div", 
      JSIL.MethodSignature.Action($.Double), 
      double2_Div$0E
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double2_Div$0F
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Div$10
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double2_Divide$11
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Divide$12
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double2_Divide$13
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Divide$14
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature($.Double, [$.Type, $.Type]), 
      double2_Dot$15
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Double])
        ]), 
      double2_Dot$16
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      double2_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type]), 
      double2_Equals$17
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      JSIL.MethodSignature.Return($.Double), 
      double2_get_Length
    );

    $.Method({Static:false, Public:true }, "get_LengthFast", 
      JSIL.MethodSignature.Return($.Double), 
      double2_get_LengthFast
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      JSIL.MethodSignature.Return($.Double), 
      double2_get_LengthSquared
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type])), 
      double2_get_Parse
    )
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_PerpendicularLeft", 
      JSIL.MethodSignature.Return($.Type), 
      double2_get_PerpendicularLeft
    );

    $.Method({Static:false, Public:true }, "get_PerpendicularRight", 
      JSIL.MethodSignature.Return($.Type), 
      double2_get_PerpendicularRight
    );

    $.Method({Static:true , Public:true }, "GetBarycentric", 
      new JSIL.MethodSignature(null, [
          $.Type, $.Type, 
          $.Type, $.Type, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Double]), $jsilcore.TypeRef("JSIL.Reference", [$.Double])
        ]), 
      double2_GetBarycentric
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      double2_GetHashCode
    );

    $.Method({Static:true , Public:true }, "IsTriangleCW", 
      new JSIL.MethodSignature($.Boolean, [
          $.Type, $.Type, 
          $.Type
        ]), 
      double2_IsTriangleCW
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Double
        ]), 
      double2_Lerp$18
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Lerp$19
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double2_Max
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double2_Min
    );

    $.Method({Static:false, Public:true }, "Mult", 
      JSIL.MethodSignature.Action($.Double), 
      double2_Mult$1A
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double2_Mult$1B
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Mult$1C
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double2_Multiply$1D
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Multiply$1E
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double2_Multiply$1F
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Multiply$20
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      JSIL.MethodSignature.Void, 
      double2_Normalize$21
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double2_Normalize$22
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double2_Normalize$23
    );

    $.Method({Static:false, Public:true }, "NormalizeFast", 
      JSIL.MethodSignature.Void, 
      double2_NormalizeFast$24
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double2_NormalizeFast$25
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double2_NormalizeFast$26
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double2_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Division", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double2_op_Division
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      double2_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      double2_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double2_op_Multiply$27
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Double, $.Type]), 
      double2_op_Multiply$28
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double2_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "op_UnaryNegation", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double2_op_UnaryNegation
    );

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [$.Double, $.Double]), 
      double2_Scale$29
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($.Type), 
      double2_Scale$2A
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      double2_Scale$2B
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "set_Parse", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type])), 
      double2_set_Parse
    )
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($.Type), 
      double2_Sub$2C
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      double2_Sub$2D
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double2_Sub$2E
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Sub$2F
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double2_Subtract$30
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Subtract$31
    );

    $.Method({Static:false, Public:true }, "ToArray", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Double])), 
      double2_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      double2_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm07.TypeRef("Fusee.Math.Core.QuaternionD")]), 
      double2_Transform$32
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.QuaternionD")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Transform$33
    );

    $.Field({Static:false, Public:true }, "x", $.Double);

    $.Field({Static:false, Public:true }, "y", $.Double);

    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitX", $.Type);

    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitY", $.Type);

    $.Field({Static:true , Public:true , ReadOnly:true }, "Zero", $.Type);

    $.Field({Static:true , Public:true , ReadOnly:true }, "One", $.Type);

    $.Field({Static:true , Public:false}, "double2$Parse$value", $asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type]))
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"))
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerBrowsableAttribute"), function () { return [$asm15.System.Diagnostics.DebuggerBrowsableState.Never]; });


    function double2__cctor () {
      $thisType.UnitX = new $thisType();
      $thisType.UnitY = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.One = new $thisType();
      $thisType.UnitX = $S00().Construct(1, 0);
      $thisType.UnitY = $S00().Construct(0, 1);
      $thisType.Zero = $S00().Construct(0, 0);
      $thisType.One = $S00().Construct(1, 1);
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      double2__cctor
    );

    $.Property({Static:false, Public:true }, "Length", $.Double);

    $.Property({Static:false, Public:true }, "LengthFast", $.Double);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Double);

    $.Property({Static:false, Public:true }, "PerpendicularRight", $.Type);

    $.Property({Static:false, Public:true }, "PerpendicularLeft", $.Type);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type]));

    $.ImplementInterfaces(
      /* 0 */ $asm15.TypeRef("System.IEquatable`1", [$.Type])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Math.Core.double3 */ 

(function double3$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm15.System.Double)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm07.Fusee.Math.Core.double2)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm07.Fusee.Math.Core.double4)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm15.System.Math)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm15.System.Object)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm15.System.Boolean)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm07.Fusee.Math.Core.M)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm07.Fusee.Math.Core.Converter$b2.Of($asm15.System.String, $asm07.Fusee.Math.Core.double3))) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm15.System.String)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm07.Fusee.Math.Core.double4x4)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm07.Fusee.Math.Core.QuaternionD)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.double3"), [
        $asm15.TypeRef("System.Double"), $asm15.TypeRef("System.Double"), 
        $asm15.TypeRef("System.Double")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.double3"), [$asm15.TypeRef("System.Double"), $asm07.TypeRef("Fusee.Math.Core.double3")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double3")]), $asm15.TypeRef("System.Double"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double3")])
      ]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double3")]), $asm15.TypeRef("System.Double"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double3")])
      ]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double3")]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double3")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double3")])
      ]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm15.TypeRef("System.Double"), [$asm15.TypeRef("System.Double")]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.double2"), [$asm15.TypeRef("System.Double"), $asm15.TypeRef("System.Double")]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double3")]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double3")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double3")])
      ]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double3")]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4x4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double3")])
      ]))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4x4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4")])
      ]))) ();
  };
  var $S0A = function () {
    return ($S0A = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double3")]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.QuaternionD")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double3")])
      ]))) ();
  };
  var $S0B = function () {
    return ($S0B = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.double3"), [$asm07.TypeRef("Fusee.Math.Core.double4")]))) ();
  };
  var $S0C = function () {
    return ($S0C = JSIL.Memoize(JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.double3")))) ();
  };


  function double3__ctor$00 (x, y, z) {
    this.x = +x;
    this.y = +y;
    this.z = +z;
  }; 

  function double3__ctor$01 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = 0;
  }; 

  function double3__ctor$02 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
  }; 

  function double3__ctor$03 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
  }; 

  function double3_Add$04 (right) {
    this.x = +this.x + +right.x;
    this.y = +this.y + +right.y;
    this.z = +this.z + +right.z;
  }; 

  function double3_Add$05 (/* ref */ right) {
    this.x = +this.x + +right.get().x;
    this.y = +this.y + +right.get().y;
    this.z = +this.z + +right.get().z;
  }; 

  function double3_Add$06 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Add(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  }; 

  function double3_Add$07 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x + +b.get().x), (+a.get().y + +b.get().y), (+a.get().z + +b.get().z)));
  }; 

  function double3_Barycentric (a, b, c, u, v) {
    return $thisType.op_Addition(
      $thisType.op_Addition(
        $S01().CallStatic($thisType, "op_Multiply", null, u, a.MemberwiseClone()).MemberwiseClone(), 
        $S01().CallStatic($thisType, "op_Multiply", null, v, b.MemberwiseClone())
      ).MemberwiseClone(), 
      $S01().CallStatic($thisType, "op_Multiply", null, (1 - +u) - +v, c.MemberwiseClone())
    );
  }; 

  function double3_CalculateAngle$08 (first, second) {
    return Math.acos(+((+$thisType.Dot(first, second) / (+first.get_Length() * +second.get_Length()))));
  }; 

  function double3_CalculateAngle$09 (/* ref */ first, /* ref */ second, /* ref */ result) {
    var temp = new JSIL.BoxedVariable(0);
    $thisType.Dot(/* ref */ first, /* ref */ second, /* ref */ temp);
    result.set((Math.acos(+((+temp.get() / (+(first.get()).get_Length() * +(second.get()).get_Length()))))));
  }; 

  function double3_Clamp$0A (vec, min, max) {
    vec.x = +(
      (+vec.x < +min.x)
         ? min.x
         : (
          (+vec.x > +max.x)
             ? max.x
             : vec.x)
    )
    ;
    vec.y = +(
      (+vec.y < +min.y)
         ? min.y
         : (
          (+vec.y > +max.y)
             ? max.y
             : vec.y)
    )
    ;
    vec.z = +(
      (+vec.z < +min.z)
         ? min.z
         : (
          (+vec.z > +max.z)
             ? max.z
             : vec.z)
    )
    ;
    return vec;
  }; 

  function double3_Clamp$0B (/* ref */ vec, /* ref */ min, /* ref */ max, /* ref */ result) {
    result.get().x = +(
      (+vec.get().x < +min.get().x)
         ? min.get().x
         : (
          (+vec.get().x > +max.get().x)
             ? max.get().x
             : vec.get().x)
    )
    ;
    result.get().y = +(
      (+vec.get().y < +min.get().y)
         ? min.get().y
         : (
          (+vec.get().y > +max.get().y)
             ? max.get().y
             : vec.get().y)
    )
    ;
    result.get().z = +(
      (+vec.get().z < +min.get().z)
         ? min.get().z
         : (
          (+vec.get().z > +max.get().z)
             ? max.get().z
             : vec.get().z)
    )
    ;
  }; 

  function double3_ComponentMax$0C (a, b) {
    a.x = +(
      (+a.x > +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y > +b.y)
         ? a.y
         : b.y)
    ;
    a.z = +(
      (+a.z > +b.z)
         ? a.z
         : b.z)
    ;
    return a;
  }; 

  function double3_ComponentMax$0D (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x > +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y > +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
    result.get().z = +(
      (+a.get().z > +b.get().z)
         ? a.get().z
         : b.get().z)
    ;
  }; 

  function double3_ComponentMin$0E (a, b) {
    a.x = +(
      (+a.x < +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y < +b.y)
         ? a.y
         : b.y)
    ;
    a.z = +(
      (+a.z < +b.z)
         ? a.z
         : b.z)
    ;
    return a;
  }; 

  function double3_ComponentMin$0F (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x < +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y < +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
    result.get().z = +(
      (+a.get().z < +b.get().z)
         ? a.get().z
         : b.get().z)
    ;
  }; 

  function double3_Cross$10 ($left, $right) {
    var right = new JSIL.BoxedVariable($right);
    var left = new JSIL.BoxedVariable($left);
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Cross(/* ref */ left, /* ref */ right, /* ref */ result);
    return result.get();
  }; 

  function double3_Cross$11 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S00().Construct(((+left.get().y * +right.get().z) - (+left.get().z * +right.get().y)), ((+left.get().z * +right.get().x) - (+left.get().x * +right.get().z)), ((+left.get().x * +right.get().y) - (+left.get().y * +right.get().x))));
  }; 

  function double3_Div$12 (f) {
    var mult = +((1 / +f));
    this.x = +this.x * mult;
    this.y = +this.y * mult;
    this.z = +this.z * mult;
  }; 

  function double3_Div$13 (a, f) {
    var mult = +((1 / +f));
    a.x = +a.x * mult;
    a.y = +a.y * mult;
    a.z = +a.z * mult;
    return a;
  }; 

  function double3_Div$14 (/* ref */ a, f, /* ref */ result) {
    var mult = +((1 / +f));
    result.get().x = +a.get().x * mult;
    result.get().y = +a.get().y * mult;
    result.get().z = +a.get().z * mult;
  }; 

  function double3_Divide$15 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S02().CallStatic($thisType, "Divide", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  }; 

  function double3_Divide$16 (/* ref */ vector, scale, /* ref */ result) {
    $S03().CallStatic($thisType, "Multiply", null, /* ref */ vector, +((1 / +scale)), /* ref */ result);
  }; 

  function double3_Divide$17 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S04().CallStatic($thisType, "Divide", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  }; 

  function double3_Divide$18 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct(+((+vector.get().x / +scale.get().x)), +((+vector.get().y / +scale.get().y)), +((+vector.get().z / +scale.get().z))));
  }; 

  function double3_Dot$19 (left, right) {
    return (((+left.x * +right.x) + (+left.y * +right.y)) + (+left.z * +right.z));
  }; 

  function double3_Dot$1A (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set(((+left.get().x * +right.get().x) + (+left.get().y * +right.get().y)) + (+left.get().z * +right.get().z));
  }; 

  function double3_Object_Equals (obj) {
    var flag = !$thisType.$Is(obj);
    return (!flag && this.Equals($thisType.$Cast(obj)));
  }; 

  function double3_Equals$1B (other) {
    return (!((+this.x !== +other.x) || 
        (+this.y !== +other.y)) && (+this.z === +other.z));
  }; 

  function double3_get_b () {
    return this.z;
  }; 

  function double3_get_g () {
    return this.y;
  }; 

  function double3_get_Length () {
    return Math.sqrt((((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z)));
  }; 

  function double3_get_LengthFast () {
    return +((1 / +$S05().CallStatic($T06(), "InverseSqrtFast", null, ((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z))));
  }; 

  function double3_get_LengthSquared () {
    return (((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z));
  }; 

  function double3_get_Parse () {
    return $thisType.double3$Parse$value;
  }; 

  function double3_get_r () {
    return this.x;
  }; 

  function double3_get_xy () {
    return $S06().Construct(this.x, this.y);
  }; 

  function double3_GetBarycentric (a, b, c, point, /* ref */ u, /* ref */ v) {
    var v2 = $thisType.op_Subtraction(b.MemberwiseClone(), c);
    var v3 = $thisType.op_Subtraction(a.MemberwiseClone(), c);
    var v4 = $thisType.op_Subtraction(point.MemberwiseClone(), c);
    var d0 = +$thisType.Dot(v2, v2);
    var d = +$thisType.Dot(v2, v3);
    var d2 = +$thisType.Dot(v3, v3);
    var d3 = +$thisType.Dot(v4, v2);
    var d4 = +$thisType.Dot(v4, v3);
    var denom = (d0 * d2) - (d * d);
    u.set(+((((d0 * d4) - (d * d3)) / denom)));
    v.set(+((((d2 * d3) - (d * d4)) / denom)));
  }; 

  function double3_GetHashCode () {
    return ((((this.x).GetHashCode() | 0) ^ ((this.y).GetHashCode() | 0)) ^ ((this.z).GetHashCode() | 0));
  }; 

  function double3_Lerp$1C (a, b, blend) {
    a.x = (+blend * (+b.x - +a.x)) + +a.x;
    a.y = (+blend * (+b.y - +a.y)) + +a.y;
    a.z = (+blend * (+b.z - +a.z)) + +a.z;
    return a;
  }; 

  function double3_Lerp$1D (/* ref */ a, /* ref */ b, blend, /* ref */ result) {
    result.get().x = (+blend * (+b.get().x - +a.get().x)) + +a.get().x;
    result.get().y = (+blend * (+b.get().y - +a.get().y)) + +a.get().y;
    result.get().z = (+blend * (+b.get().z - +a.get().z)) + +a.get().z;
  }; 

  function double3_Max (left, right) {
    return (
      (+left.get_LengthSquared() >= +right.get_LengthSquared())
         ? left
         : right)
    ;
  }; 

  function double3_Min (left, right) {
    return (
      (+left.get_LengthSquared() < +right.get_LengthSquared())
         ? left
         : right)
    ;
  }; 

  function double3_Mult$1E (f) {
    this.x = +this.x * +f;
    this.y = +this.y * +f;
    this.z = +this.z * +f;
  }; 

  function double3_Mult$1F (a, f) {
    a.x = +a.x * +f;
    a.y = +a.y * +f;
    a.z = +a.z * +f;
    return a;
  }; 

  function double3_Mult$20 (/* ref */ a, f, /* ref */ result) {
    result.get().x = +a.get().x * +f;
    result.get().y = +a.get().y * +f;
    result.get().z = +a.get().z * +f;
  }; 

  function double3_Multiply$21 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S03().CallStatic($thisType, "Multiply", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  }; 

  function double3_Multiply$22 (/* ref */ vector, scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale), (+vector.get().y * +scale), (+vector.get().z * +scale)));
  }; 

  function double3_Multiply$23 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S07().CallStatic($thisType, "Multiply", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  }; 

  function double3_Multiply$24 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale.get().x), (+vector.get().y * +scale.get().y), (+vector.get().z * +scale.get().z)));
  }; 

  function double3_Normalize$25 () {
    var scale = +((1 / +this.get_Length()));
    this.x = +this.x * scale;
    this.y = +this.y * scale;
    this.z = +this.z * scale;
  }; 

  function double3_Normalize$26 (vec) {
    var scale = +((1 / +vec.get_Length()));
    vec.x = +vec.x * scale;
    vec.y = +vec.y * scale;
    vec.z = +vec.z * scale;
    return vec;
  }; 

  function double3_Normalize$27 (/* ref */ vec, /* ref */ result) {
    var scale = +((1 / +(vec.get()).get_Length()));
    result.get().x = +vec.get().x * scale;
    result.get().y = +vec.get().y * scale;
    result.get().z = +vec.get().z * scale;
  }; 

  function double3_NormalizeFast$28 () {
    var scale = +$S05().CallStatic($T06(), "InverseSqrtFast", null, ((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z));
    this.x = +this.x * scale;
    this.y = +this.y * scale;
    this.z = +this.z * scale;
  }; 

  function double3_NormalizeFast$29 (vec) {
    var scale = +$S05().CallStatic($T06(), "InverseSqrtFast", null, ((+vec.x * +vec.x) + (+vec.y * +vec.y)) + (+vec.z * +vec.z));
    vec.x = +vec.x * scale;
    vec.y = +vec.y * scale;
    vec.z = +vec.z * scale;
    return vec;
  }; 

  function double3_NormalizeFast$2A (/* ref */ vec, /* ref */ result) {
    var scale = +$S05().CallStatic($T06(), "InverseSqrtFast", null, ((+vec.get().x * +vec.get().x) + (+vec.get().y * +vec.get().y)) + (+vec.get().z * +vec.get().z));
    result.get().x = +vec.get().x * scale;
    result.get().y = +vec.get().y * scale;
    result.get().z = +vec.get().z * scale;
  }; 

  function double3_op_Addition (left, right) {
    left.x = +left.x + +right.x;
    left.y = +left.y + +right.y;
    left.z = +left.z + +right.z;
    return left;
  }; 

  function double3_op_Division (vec, scale) {
    var mult = +((1 / +scale));
    vec.x = +vec.x * mult;
    vec.y = +vec.y * mult;
    vec.z = +vec.z * mult;
    return vec;
  }; 

  function double3_op_Equality (left, right) {
    return left.Equals(right);
  }; 

  function double3_op_Inequality (left, right) {
    return !left.Equals(right);
  }; 

  function double3_op_Multiply$2B (vec, scale) {
    vec.x = +vec.x * +scale;
    vec.y = +vec.y * +scale;
    vec.z = +vec.z * +scale;
    return vec;
  }; 

  function double3_op_Multiply$2C (scale, vec) {
    vec.x = +vec.x * +scale;
    vec.y = +vec.y * +scale;
    vec.z = +vec.z * +scale;
    return vec;
  }; 

  function double3_op_Subtraction (left, right) {
    left.x = +left.x - +right.x;
    left.y = +left.y - +right.y;
    left.z = +left.z - +right.z;
    return left;
  }; 

  function double3_op_UnaryNegation (vec) {
    vec.x = -vec.x;
    vec.y = -vec.y;
    vec.z = -vec.z;
    return vec;
  }; 

  function double3_Scale$2D (sx, sy, sz) {
    this.x = +this.x * +sx;
    this.y = +this.y * +sy;
    this.z = +this.z * +sz;
  }; 

  function double3_Scale$2E (scale) {
    this.x = +this.x * +scale.x;
    this.y = +this.y * +scale.y;
    this.z = +this.z * +scale.z;
  }; 

  function double3_Scale$2F (/* ref */ scale) {
    this.x = +this.x * +scale.get().x;
    this.y = +this.y * +scale.get().y;
    this.z = +this.z * +scale.get().z;
  }; 

  function double3_set_b (value) {
    this.z = +value;
  }; 

  function double3_set_g (value) {
    this.y = +value;
  }; 

  function double3_set_Parse (value) {
    $thisType.double3$Parse$value = value;
  }; 

  function double3_set_r (value) {
    this.x = +value;
  }; 

  function double3_set_xy (value) {
    this.x = +value.x;
    this.y = +value.y;
  }; 

  function double3_Sub$30 (right) {
    this.x = +this.x - +right.x;
    this.y = +this.y - +right.y;
    this.z = +this.z - +right.z;
  }; 

  function double3_Sub$31 (/* ref */ right) {
    this.x = +this.x - +right.get().x;
    this.y = +this.y - +right.get().y;
    this.z = +this.z - +right.get().z;
  }; 

  function double3_Sub$32 (a, b) {
    a.x = +a.x - +b.x;
    a.y = +a.y - +b.y;
    a.z = +a.z - +b.z;
    return a;
  }; 

  function double3_Sub$33 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +a.get().x - +b.get().x;
    result.get().y = +a.get().y - +b.get().y;
    result.get().z = +a.get().z - +b.get().z;
  }; 

  function double3_Subtract$34 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Subtract(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  }; 

  function double3_Subtract$35 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x - +b.get().x), (+a.get().y - +b.get().y), (+a.get().z - +b.get().z)));
  }; 

  function double3_ToArray () {
    return JSIL.Array.New($T00(), [this.x, this.y, this.z]);
  }; 

  function double3_toString () {
    return $T08().Format("({0}, {1}, {2})", JSIL.Array.New($T04(), [$T00().$Box(this.x), $T00().$Box(this.y), $T00().$Box(this.z)]));
  }; 

  function double3_Transform$36 ($vec, $mat) {
    var mat = new JSIL.BoxedVariable($mat.MemberwiseClone());
    var vec = new JSIL.BoxedVariable($vec.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $S08().CallStatic($thisType, "Transform", null, /* ref */ vec, /* ref */ mat, /* ref */ result);
    return result.get();
  }; 

  function double3_Transform$37 (/* ref */ vec, /* ref */ mat, /* ref */ result) {
    var v4 = new JSIL.BoxedVariable(new ($T02())());
    $T02().prototype._ctor.call(v4.get().MemberwiseClone(), vec.get().x, vec.get().y, vec.get().z, 1);
    $S09().CallStatic($T02(), "Transform", null, /* ref */ v4, /* ref */ mat, /* ref */ v4);
    result.set((v4.get()).get_xyz().MemberwiseClone());
  }; 

  function double3_Transform$38 ($vec, $quat) {
    var quat = new JSIL.BoxedVariable($quat.MemberwiseClone());
    var vec = new JSIL.BoxedVariable($vec.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $S0A().CallStatic($thisType, "Transform", null, /* ref */ vec, /* ref */ quat, /* ref */ result);
    return result.get();
  }; 

  function double3_Transform$39 (/* ref */ vec, /* ref */ quat, /* ref */ result) {
    var temp = new JSIL.BoxedVariable(new $thisType());
    var temp2 = new JSIL.BoxedVariable(new $thisType());
    var xyz = new JSIL.BoxedVariable((quat.get()).get_xyz().MemberwiseClone());
    $thisType.Cross(/* ref */ xyz, /* ref */ vec, /* ref */ temp);
    $S03().CallStatic($thisType, "Multiply", null, /* ref */ vec, (quat.get()).get_w(), /* ref */ temp2);
    $thisType.Add(/* ref */ temp, /* ref */ temp2, /* ref */ temp);
    $thisType.Cross(/* ref */ xyz, /* ref */ temp, /* ref */ temp);
    $S03().CallStatic($thisType, "Multiply", null, /* ref */ temp, 2, /* ref */ temp);
    $thisType.Add(/* ref */ vec, /* ref */ temp, /* ref */ result);
  }; 

  function double3_TransformNormal$3A (norm, mat) {
    mat.Invert();
    return $thisType.TransformNormalInverse(norm.MemberwiseClone(), mat);
  }; 

  function double3_TransformNormal$3B (/* ref */ norm, /* ref */ mat, /* ref */ result) {
    var Inverse = new JSIL.BoxedVariable($T09().Invert(mat.get().MemberwiseClone()).MemberwiseClone());
    $thisType.TransformNormalInverse(/* ref */ norm, /* ref */ Inverse, /* ref */ result);
  }; 

  function double3_TransformNormalInverse$3C (norm, invMat) {
    var i = new $thisType();
    i.x = +$thisType.Dot(norm, $S0B().Construct(invMat.Row0));
    i.y = +$thisType.Dot(norm, $S0B().Construct(invMat.Row1));
    i.z = +$thisType.Dot(norm, $S0B().Construct(invMat.Row2));
    return i;
  }; 

  function double3_TransformNormalInverse$3D (/* ref */ norm, /* ref */ invMat, /* ref */ result) {
    result.get().x = ((+norm.get().x * +invMat.get().Row0.x) + (+norm.get().y * +invMat.get().Row0.y)) + (+norm.get().z * +invMat.get().Row0.z);
    result.get().y = ((+norm.get().x * +invMat.get().Row1.x) + (+norm.get().y * +invMat.get().Row1.y)) + (+norm.get().z * +invMat.get().Row1.z);
    result.get().z = ((+norm.get().x * +invMat.get().Row2.x) + (+norm.get().y * +invMat.get().Row2.y)) + (+norm.get().z * +invMat.get().Row2.z);
  }; 

  function double3_TransformPerspective$3E ($vec, $mat) {
    var mat = new JSIL.BoxedVariable($mat.MemberwiseClone());
    var vec = new JSIL.BoxedVariable($vec.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.TransformPerspective(/* ref */ vec, /* ref */ mat, /* ref */ result);
    return result.get();
  }; 

  function double3_TransformPerspective$3F (/* ref */ vec, /* ref */ mat, /* ref */ result) {
    var v = new JSIL.BoxedVariable(new ($T02())());
    $S0C().Call($T02().prototype, "_ctor", null, v.get().MemberwiseClone(), vec.get());
    $S09().CallStatic($T02(), "Transform", null, /* ref */ v, /* ref */ mat, /* ref */ v);
    result.get().x = +((+v.get().x / +v.get().w));
    result.get().y = +((+v.get().y / +v.get().w));
    result.get().z = +((+v.get().z / +v.get().w));
  }; 

  function double3_TransformPosition$40 (pos, mat) {
    var p = new $thisType();
    p.x = +$thisType.Dot(pos, $S0B().Construct(mat.get_Column0())) + +mat.Row3.x;
    p.y = +$thisType.Dot(pos, $S0B().Construct(mat.get_Column1())) + +mat.Row3.y;
    p.z = +$thisType.Dot(pos, $S0B().Construct(mat.get_Column2())) + +mat.Row3.z;
    return p;
  }; 

  function double3_TransformPosition$41 (/* ref */ pos, /* ref */ mat, /* ref */ result) {
    result.get().x = (((+pos.get().x * +mat.get().Row0.x) + (+pos.get().y * +mat.get().Row1.x)) + (+pos.get().z * +mat.get().Row2.x)) + +mat.get().Row3.x;
    result.get().y = (((+pos.get().x * +mat.get().Row0.y) + (+pos.get().y * +mat.get().Row1.y)) + (+pos.get().z * +mat.get().Row2.y)) + +mat.get().Row3.y;
    result.get().z = (((+pos.get().x * +mat.get().Row0.z) + (+pos.get().y * +mat.get().Row1.z)) + (+pos.get().z * +mat.get().Row2.z)) + +mat.get().Row3.z;
  }; 

  function double3_TransformVector$42 (vec, mat) {
    var v = new $thisType();
    v.x = +$thisType.Dot(vec, $S0B().Construct(mat.get_Column0()));
    v.y = +$thisType.Dot(vec, $S0B().Construct(mat.get_Column1()));
    v.z = +$thisType.Dot(vec, $S0B().Construct(mat.get_Column2()));
    return v;
  }; 

  function double3_TransformVector$43 (/* ref */ vec, /* ref */ mat, /* ref */ result) {
    result.get().x = ((+vec.get().x * +mat.get().Row0.x) + (+vec.get().y * +mat.get().Row1.x)) + (+vec.get().z * +mat.get().Row2.x);
    result.get().y = ((+vec.get().x * +mat.get().Row0.y) + (+vec.get().y * +mat.get().Row1.y)) + (+vec.get().z * +mat.get().Row2.y);
    result.get().z = ((+vec.get().x * +mat.get().Row0.z) + (+vec.get().y * +mat.get().Row1.z)) + (+vec.get().z * +mat.get().Row2.z);
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.Core.double3", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 3, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double
        ]), 
      double3__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.double2")), 
      double3__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Type), 
      double3__ctor$02
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.double4")), 
      double3__ctor$03
    );

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($.Type), 
      double3_Add$04
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      double3_Add$05
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_Add$06
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Add$07
    );

    $.Method({Static:true , Public:true }, "Barycentric", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type, $.Double, 
          $.Double
        ]), 
      double3_Barycentric
    );

    $.Method({Static:true , Public:true }, "CalculateAngle", 
      new JSIL.MethodSignature($.Double, [$.Type, $.Type]), 
      double3_CalculateAngle$08
    );

    $.Method({Static:true , Public:true }, "CalculateAngle", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Double])
        ]), 
      double3_CalculateAngle$09
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type
        ]), 
      double3_Clamp$0A
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Clamp$0B
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_ComponentMax$0C
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_ComponentMax$0D
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_ComponentMin$0E
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_ComponentMin$0F
    );

    $.Method({Static:true , Public:true }, "Cross", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_Cross$10
    );

    $.Method({Static:true , Public:true }, "Cross", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Cross$11
    );

    $.Method({Static:false, Public:true }, "Div", 
      JSIL.MethodSignature.Action($.Double), 
      double3_Div$12
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double3_Div$13
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Div$14
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double3_Divide$15
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Divide$16
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_Divide$17
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Divide$18
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature($.Double, [$.Type, $.Type]), 
      double3_Dot$19
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Double])
        ]), 
      double3_Dot$1A
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      double3_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type]), 
      double3_Equals$1B
    );

    $.Method({Static:false, Public:true }, "get_b", 
      JSIL.MethodSignature.Return($.Double), 
      double3_get_b
    );

    $.Method({Static:false, Public:true }, "get_g", 
      JSIL.MethodSignature.Return($.Double), 
      double3_get_g
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      JSIL.MethodSignature.Return($.Double), 
      double3_get_Length
    );

    $.Method({Static:false, Public:true }, "get_LengthFast", 
      JSIL.MethodSignature.Return($.Double), 
      double3_get_LengthFast
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      JSIL.MethodSignature.Return($.Double), 
      double3_get_LengthSquared
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type])), 
      double3_get_Parse
    )
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_r", 
      JSIL.MethodSignature.Return($.Double), 
      double3_get_r
    );

    $.Method({Static:false, Public:true }, "get_xy", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.double2")), 
      double3_get_xy
    );

    $.Method({Static:true , Public:true }, "GetBarycentric", 
      new JSIL.MethodSignature(null, [
          $.Type, $.Type, 
          $.Type, $.Type, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Double]), $jsilcore.TypeRef("JSIL.Reference", [$.Double])
        ]), 
      double3_GetBarycentric
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      double3_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Double
        ]), 
      double3_Lerp$1C
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Lerp$1D
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_Max
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_Min
    );

    $.Method({Static:false, Public:true }, "Mult", 
      JSIL.MethodSignature.Action($.Double), 
      double3_Mult$1E
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double3_Mult$1F
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Mult$20
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double3_Multiply$21
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Multiply$22
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_Multiply$23
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Multiply$24
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      JSIL.MethodSignature.Void, 
      double3_Normalize$25
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double3_Normalize$26
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double3_Normalize$27
    );

    $.Method({Static:false, Public:true }, "NormalizeFast", 
      JSIL.MethodSignature.Void, 
      double3_NormalizeFast$28
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double3_NormalizeFast$29
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double3_NormalizeFast$2A
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Division", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double3_op_Division
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      double3_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      double3_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double3_op_Multiply$2B
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Double, $.Type]), 
      double3_op_Multiply$2C
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "op_UnaryNegation", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double3_op_UnaryNegation
    );

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double
        ]), 
      double3_Scale$2D
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($.Type), 
      double3_Scale$2E
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      double3_Scale$2F
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "set_b", 
      JSIL.MethodSignature.Action($.Double), 
      double3_set_b
    );

    $.Method({Static:false, Public:true }, "set_g", 
      JSIL.MethodSignature.Action($.Double), 
      double3_set_g
    );

    $.Method({Static:true , Public:true }, "set_Parse", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type])), 
      double3_set_Parse
    )
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "set_r", 
      JSIL.MethodSignature.Action($.Double), 
      double3_set_r
    );

    $.Method({Static:false, Public:true }, "set_xy", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.double2")), 
      double3_set_xy
    );

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($.Type), 
      double3_Sub$30
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      double3_Sub$31
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_Sub$32
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Sub$33
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_Subtract$34
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Subtract$35
    );

    $.Method({Static:false, Public:true }, "ToArray", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Double])), 
      double3_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      double3_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm07.TypeRef("Fusee.Math.Core.double4x4")]), 
      double3_Transform$36
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Transform$37
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm07.TypeRef("Fusee.Math.Core.QuaternionD")]), 
      double3_Transform$38
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.QuaternionD")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Transform$39
    );

    $.Method({Static:true , Public:true }, "TransformNormal", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm07.TypeRef("Fusee.Math.Core.double4x4")]), 
      double3_TransformNormal$3A
    );

    $.Method({Static:true , Public:true }, "TransformNormal", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_TransformNormal$3B
    );

    $.Method({Static:true , Public:true }, "TransformNormalInverse", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm07.TypeRef("Fusee.Math.Core.double4x4")]), 
      double3_TransformNormalInverse$3C
    );

    $.Method({Static:true , Public:true }, "TransformNormalInverse", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_TransformNormalInverse$3D
    );

    $.Method({Static:true , Public:true }, "TransformPerspective", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm07.TypeRef("Fusee.Math.Core.double4x4")]), 
      double3_TransformPerspective$3E
    );

    $.Method({Static:true , Public:true }, "TransformPerspective", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_TransformPerspective$3F
    );

    $.Method({Static:true , Public:true }, "TransformPosition", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm07.TypeRef("Fusee.Math.Core.double4x4")]), 
      double3_TransformPosition$40
    );

    $.Method({Static:true , Public:true }, "TransformPosition", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_TransformPosition$41
    );

    $.Method({Static:true , Public:true }, "TransformVector", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm07.TypeRef("Fusee.Math.Core.double4x4")]), 
      double3_TransformVector$42
    );

    $.Method({Static:true , Public:true }, "TransformVector", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_TransformVector$43
    );

    $.Field({Static:false, Public:true }, "x", $.Double);

    $.Field({Static:false, Public:true }, "y", $.Double);

    $.Field({Static:false, Public:true }, "z", $.Double);

    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitX", $.Type);

    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitY", $.Type);

    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitZ", $.Type);

    $.Field({Static:true , Public:true , ReadOnly:true }, "Zero", $.Type);

    $.Field({Static:true , Public:true , ReadOnly:true }, "One", $.Type);

    $.Field({Static:true , Public:false}, "double3$Parse$value", $asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type]))
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"))
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerBrowsableAttribute"), function () { return [$asm15.System.Diagnostics.DebuggerBrowsableState.Never]; });


    function double3__cctor () {
      $thisType.UnitX = new $thisType();
      $thisType.UnitY = new $thisType();
      $thisType.UnitZ = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.One = new $thisType();
      $thisType.UnitX = $S00().Construct(1, 0, 0);
      $thisType.UnitY = $S00().Construct(0, 1, 0);
      $thisType.UnitZ = $S00().Construct(0, 0, 1);
      $thisType.Zero = $S00().Construct(0, 0, 0);
      $thisType.One = $S00().Construct(1, 1, 1);
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      double3__cctor
    );

    $.Property({Static:false, Public:true }, "Length", $.Double);

    $.Property({Static:false, Public:true }, "LengthFast", $.Double);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Double);

    $.Property({Static:false, Public:true }, "xy", $asm07.TypeRef("Fusee.Math.Core.double2"));

    $.Property({Static:false, Public:true }, "r", $.Double);

    $.Property({Static:false, Public:true }, "g", $.Double);

    $.Property({Static:false, Public:true }, "b", $.Double);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type]));

    $.ImplementInterfaces(
      /* 0 */ $asm15.TypeRef("System.IEquatable`1", [$.Type])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Math.Core.double4 */ 

(function double4$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm15.System.Double)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm07.Fusee.Math.Core.double2)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm07.Fusee.Math.Core.double3)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm15.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm15.System.Boolean)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm15.System.Math)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm07.Fusee.Math.Core.M)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm07.Fusee.Math.Core.Converter$b2.Of($asm15.System.String, $asm07.Fusee.Math.Core.double4))) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm15.System.String)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm07.Fusee.Math.Core.double4x4)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm07.Fusee.Math.Core.QuaternionD)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.double4"), [
        $asm15.TypeRef("System.Double"), $asm15.TypeRef("System.Double"), 
        $asm15.TypeRef("System.Double"), $asm15.TypeRef("System.Double")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.double4"), [$asm15.TypeRef("System.Double"), $asm07.TypeRef("Fusee.Math.Core.double4")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4")]), $asm15.TypeRef("System.Double"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4")])
      ]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4")]), $asm15.TypeRef("System.Double"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4")])
      ]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4")])
      ]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm15.TypeRef("System.Double"), [$asm15.TypeRef("System.Double")]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.double2"), [$asm15.TypeRef("System.Double"), $asm15.TypeRef("System.Double")]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.double3"), [
        $asm15.TypeRef("System.Double"), $asm15.TypeRef("System.Double"), 
        $asm15.TypeRef("System.Double")
      ]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4")])
      ]))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4x4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4")])
      ]))) ();
  };
  var $S0A = function () {
    return ($S0A = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.QuaternionD")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4")])
      ]))) ();
  };
  var $S0B = function () {
    return ($S0B = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.QuaternionD")]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.QuaternionD")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.QuaternionD")])
      ]))) ();
  };


  function double4__ctor$00 (x, y, z, w) {
    this.x = +x;
    this.y = +y;
    this.z = +z;
    this.w = +w;
  }; 

  function double4__ctor$01 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = 0;
    this.w = 0;
  }; 

  function double4__ctor$02 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
    this.w = 0;
  }; 

  function double4__ctor$03 (v, ww) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
    this.w = +ww;
  }; 

  function double4__ctor$04 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
    this.w = +v.w;
  }; 

  function double4_Add$05 (right) {
    this.x = +this.x + +right.x;
    this.y = +this.y + +right.y;
    this.z = +this.z + +right.z;
    this.w = +this.w + +right.w;
  }; 

  function double4_Add$06 (/* ref */ right) {
    this.x = +this.x + +right.get().x;
    this.y = +this.y + +right.get().y;
    this.z = +this.z + +right.get().z;
    this.w = +this.w + +right.get().w;
  }; 

  function double4_Add$07 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Add(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  }; 

  function double4_Add$08 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x + +b.get().x), (+a.get().y + +b.get().y), (+a.get().z + +b.get().z), (+a.get().w + +b.get().w)));
  }; 

  function double4_BaryCentric (a, b, c, u, v) {
    return $thisType.op_Addition(
      $thisType.op_Addition(
        $S01().CallStatic($thisType, "op_Multiply", null, u, a.MemberwiseClone()).MemberwiseClone(), 
        $S01().CallStatic($thisType, "op_Multiply", null, v, b.MemberwiseClone())
      ).MemberwiseClone(), 
      $S01().CallStatic($thisType, "op_Multiply", null, (1 - +u) - +v, c.MemberwiseClone())
    );
  }; 

  function double4_Clamp$09 (vec, min, max) {
    vec.x = +(
      (+vec.x < +min.x)
         ? min.x
         : (
          (+vec.x > +max.x)
             ? max.x
             : vec.x)
    )
    ;
    vec.y = +(
      (+vec.y < +min.y)
         ? min.y
         : (
          (+vec.y > +max.y)
             ? max.y
             : vec.y)
    )
    ;
    vec.z = +(
      (+vec.x < +min.z)
         ? min.z
         : (
          (+vec.z > +max.z)
             ? max.z
             : vec.z)
    )
    ;
    vec.w = +(
      (+vec.y < +min.w)
         ? min.w
         : (
          (+vec.w > +max.w)
             ? max.w
             : vec.w)
    )
    ;
    return vec;
  }; 

  function double4_Clamp$0A (/* ref */ vec, /* ref */ min, /* ref */ max, /* ref */ result) {
    result.get().x = +(
      (+vec.get().x < +min.get().x)
         ? min.get().x
         : (
          (+vec.get().x > +max.get().x)
             ? max.get().x
             : vec.get().x)
    )
    ;
    result.get().y = +(
      (+vec.get().y < +min.get().y)
         ? min.get().y
         : (
          (+vec.get().y > +max.get().y)
             ? max.get().y
             : vec.get().y)
    )
    ;
    result.get().z = +(
      (+vec.get().x < +min.get().z)
         ? min.get().z
         : (
          (+vec.get().z > +max.get().z)
             ? max.get().z
             : vec.get().z)
    )
    ;
    result.get().w = +(
      (+vec.get().y < +min.get().w)
         ? min.get().w
         : (
          (+vec.get().w > +max.get().w)
             ? max.get().w
             : vec.get().w)
    )
    ;
  }; 

  function double4_Div$0B (f) {
    var mult = +((1 / +f));
    this.x = +this.x * mult;
    this.y = +this.y * mult;
    this.z = +this.z * mult;
    this.w = +this.w * mult;
  }; 

  function double4_Div$0C (a, f) {
    var mult = +((1 / +f));
    a.x = +a.x * mult;
    a.y = +a.y * mult;
    a.z = +a.z * mult;
    a.w = +a.w * mult;
    return a;
  }; 

  function double4_Div$0D (/* ref */ a, f, /* ref */ result) {
    var mult = +((1 / +f));
    result.get().x = +a.get().x * mult;
    result.get().y = +a.get().y * mult;
    result.get().z = +a.get().z * mult;
    result.get().w = +a.get().w * mult;
  }; 

  function double4_Divide$0E ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S02().CallStatic($thisType, "Divide", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  }; 

  function double4_Divide$0F (/* ref */ vector, scale, /* ref */ result) {
    $S03().CallStatic($thisType, "Multiply", null, /* ref */ vector, +((1 / +scale)), /* ref */ result);
  }; 

  function double4_Divide$10 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S04().CallStatic($thisType, "Divide", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  }; 

  function double4_Divide$11 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct(+((+vector.get().x / +scale.get().x)), +((+vector.get().y / +scale.get().y)), +((+vector.get().z / +scale.get().z)), +((+vector.get().w / +scale.get().w))));
  }; 

  function double4_Dot$12 (left, right) {
    return ((((+left.x * +right.x) + (+left.y * +right.y)) + (+left.z * +right.z)) + (+left.w * +right.w));
  }; 

  function double4_Dot$13 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set((((+left.get().x * +right.get().x) + (+left.get().y * +right.get().y)) + (+left.get().z * +right.get().z)) + (+left.get().w * +right.get().w));
  }; 

  function double4_Object_Equals (obj) {
    var flag = !$thisType.$Is(obj);
    return (!flag && this.Equals($thisType.$Cast(obj)));
  }; 

  function double4_Equals$14 (other) {
    return (!((+this.x !== +other.x) || 
        (+this.y !== +other.y) || 
        (+this.z !== +other.z)) && (+this.w === +other.w));
  }; 

  function double4_get_a () {
    return this.w;
  }; 

  function double4_get_b () {
    return this.z;
  }; 

  function double4_get_g () {
    return this.y;
  }; 

  function double4_get_Length () {
    return Math.sqrt(((((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z)) + (+this.w * +this.w)));
  }; 

  function double4_get_LengthFast () {
    return +((1 / +$S05().CallStatic($T06(), "InverseSqrtFast", null, (((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z)) + (+this.w * +this.w))));
  }; 

  function double4_get_LengthSquared () {
    return ((((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z)) + (+this.w * +this.w));
  }; 

  function double4_get_Parse () {
    return $thisType.double4$Parse$value;
  }; 

  function double4_get_r () {
    return this.x;
  }; 

  function double4_get_rgb () {
    return this.get_xyz();
  }; 

  function double4_get_xy () {
    return $S06().Construct(this.x, this.y);
  }; 

  function double4_get_xyz () {
    return $S07().Construct(this.x, this.y, this.z);
  }; 

  function double4_GetHashCode () {
    return (((((this.x).GetHashCode() | 0) ^ ((this.y).GetHashCode() | 0)) ^ ((this.z).GetHashCode() | 0)) ^ ((this.w).GetHashCode() | 0));
  }; 

  function double4_Lerp$15 (a, b, blend) {
    a.x = (+blend * (+b.x - +a.x)) + +a.x;
    a.y = (+blend * (+b.y - +a.y)) + +a.y;
    a.z = (+blend * (+b.z - +a.z)) + +a.z;
    a.w = (+blend * (+b.w - +a.w)) + +a.w;
    return a;
  }; 

  function double4_Lerp$16 (/* ref */ a, /* ref */ b, blend, /* ref */ result) {
    result.get().x = (+blend * (+b.get().x - +a.get().x)) + +a.get().x;
    result.get().y = (+blend * (+b.get().y - +a.get().y)) + +a.get().y;
    result.get().z = (+blend * (+b.get().z - +a.get().z)) + +a.get().z;
    result.get().w = (+blend * (+b.get().w - +a.get().w)) + +a.get().w;
  }; 

  function double4_Max$17 (a, b) {
    a.x = +(
      (+a.x > +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y > +b.y)
         ? a.y
         : b.y)
    ;
    a.z = +(
      (+a.z > +b.z)
         ? a.z
         : b.z)
    ;
    a.w = +(
      (+a.w > +b.w)
         ? a.w
         : b.w)
    ;
    return a;
  }; 

  function double4_Max$18 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x > +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y > +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
    result.get().z = +(
      (+a.get().z > +b.get().z)
         ? a.get().z
         : b.get().z)
    ;
    result.get().w = +(
      (+a.get().w > +b.get().w)
         ? a.get().w
         : b.get().w)
    ;
  }; 

  function double4_Min$19 (a, b) {
    a.x = +(
      (+a.x < +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y < +b.y)
         ? a.y
         : b.y)
    ;
    a.z = +(
      (+a.z < +b.z)
         ? a.z
         : b.z)
    ;
    a.w = +(
      (+a.w < +b.w)
         ? a.w
         : b.w)
    ;
    return a;
  }; 

  function double4_Min$1A (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x < +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y < +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
    result.get().z = +(
      (+a.get().z < +b.get().z)
         ? a.get().z
         : b.get().z)
    ;
    result.get().w = +(
      (+a.get().w < +b.get().w)
         ? a.get().w
         : b.get().w)
    ;
  }; 

  function double4_Mult$1B (f) {
    this.x = +this.x * +f;
    this.y = +this.y * +f;
    this.z = +this.z * +f;
    this.w = +this.w * +f;
  }; 

  function double4_Mult$1C (a, f) {
    a.x = +a.x * +f;
    a.y = +a.y * +f;
    a.z = +a.z * +f;
    a.w = +a.w * +f;
    return a;
  }; 

  function double4_Mult$1D (/* ref */ a, f, /* ref */ result) {
    result.get().x = +a.get().x * +f;
    result.get().y = +a.get().y * +f;
    result.get().z = +a.get().z * +f;
    result.get().w = +a.get().w * +f;
  }; 

  function double4_Multiply$1E ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S03().CallStatic($thisType, "Multiply", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  }; 

  function double4_Multiply$1F (/* ref */ vector, scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale), (+vector.get().y * +scale), (+vector.get().z * +scale), (+vector.get().w * +scale)));
  }; 

  function double4_Multiply$20 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S08().CallStatic($thisType, "Multiply", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  }; 

  function double4_Multiply$21 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale.get().x), (+vector.get().y * +scale.get().y), (+vector.get().z * +scale.get().z), (+vector.get().w * +scale.get().w)));
  }; 

  function double4_Normalize$22 () {
    var scale = +((1 / +this.get_Length()));
    this.x = +this.x * scale;
    this.y = +this.y * scale;
    this.z = +this.z * scale;
    this.w = +this.w * scale;
  }; 

  function double4_Normalize$23 (vec) {
    var scale = +((1 / +vec.get_Length()));
    vec.x = +vec.x * scale;
    vec.y = +vec.y * scale;
    vec.z = +vec.z * scale;
    vec.w = +vec.w * scale;
    return vec;
  }; 

  function double4_Normalize$24 (/* ref */ vec, /* ref */ result) {
    var scale = +((1 / +(vec.get()).get_Length()));
    result.get().x = +vec.get().x * scale;
    result.get().y = +vec.get().y * scale;
    result.get().z = +vec.get().z * scale;
    result.get().w = +vec.get().w * scale;
  }; 

  function double4_NormalizeFast$25 () {
    var scale = +$S05().CallStatic($T06(), "InverseSqrtFast", null, (((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z)) + (+this.w * +this.w));
    this.x = +this.x * scale;
    this.y = +this.y * scale;
    this.z = +this.z * scale;
    this.w = +this.w * scale;
  }; 

  function double4_NormalizeFast$26 (vec) {
    var scale = +$S05().CallStatic($T06(), "InverseSqrtFast", null, (((+vec.x * +vec.x) + (+vec.y * +vec.y)) + (+vec.z * +vec.z)) + (+vec.w * +vec.w));
    vec.x = +vec.x * scale;
    vec.y = +vec.y * scale;
    vec.z = +vec.z * scale;
    vec.w = +vec.w * scale;
    return vec;
  }; 

  function double4_NormalizeFast$27 (/* ref */ vec, /* ref */ result) {
    var scale = +$S05().CallStatic($T06(), "InverseSqrtFast", null, (((+vec.get().x * +vec.get().x) + (+vec.get().y * +vec.get().y)) + (+vec.get().z * +vec.get().z)) + (+vec.get().w * +vec.get().w));
    result.get().x = +vec.get().x * scale;
    result.get().y = +vec.get().y * scale;
    result.get().z = +vec.get().z * scale;
    result.get().w = +vec.get().w * scale;
  }; 

  function double4_op_Addition (left, right) {
    left.x = +left.x + +right.x;
    left.y = +left.y + +right.y;
    left.z = +left.z + +right.z;
    left.w = +left.w + +right.w;
    return left;
  }; 

  function double4_op_Division (vec, scale) {
    var mult = +((1 / +scale));
    vec.x = +vec.x * mult;
    vec.y = +vec.y * mult;
    vec.z = +vec.z * mult;
    vec.w = +vec.w * mult;
    return vec;
  }; 

  function double4_op_Equality (left, right) {
    return left.Equals(right);
  }; 

  function double4_op_Inequality (left, right) {
    return !left.Equals(right);
  }; 

  function double4_op_Multiply$28 (vec, scale) {
    vec.x = +vec.x * +scale;
    vec.y = +vec.y * +scale;
    vec.z = +vec.z * +scale;
    vec.w = +vec.w * +scale;
    return vec;
  }; 

  function double4_op_Multiply$29 (scale, vec) {
    vec.x = +vec.x * +scale;
    vec.y = +vec.y * +scale;
    vec.z = +vec.z * +scale;
    vec.w = +vec.w * +scale;
    return vec;
  }; 

  function double4_op_Subtraction (left, right) {
    left.x = +left.x - +right.x;
    left.y = +left.y - +right.y;
    left.z = +left.z - +right.z;
    left.w = +left.w - +right.w;
    return left;
  }; 

  function double4_op_UnaryNegation (vec) {
    vec.x = -vec.x;
    vec.y = -vec.y;
    vec.z = -vec.z;
    vec.w = -vec.w;
    return vec;
  }; 

  function double4_Scale$2A (sx, sy, sz, sw) {
    this.x = +this.x * +sx;
    this.y = +this.y * +sy;
    this.z = +this.z * +sz;
    this.w = +this.w * +sw;
  }; 

  function double4_Scale$2B (scale) {
    this.x = +this.x * +scale.x;
    this.y = +this.y * +scale.y;
    this.z = +this.z * +scale.z;
    this.w = +this.w * +scale.w;
  }; 

  function double4_Scale$2C (/* ref */ scale) {
    this.x = +this.x * +scale.get().x;
    this.y = +this.y * +scale.get().y;
    this.z = +this.z * +scale.get().z;
    this.w = +this.w * +scale.get().w;
  }; 

  function double4_set_a (value) {
    this.w = +value;
  }; 

  function double4_set_b (value) {
    this.z = +value;
  }; 

  function double4_set_g (value) {
    this.y = +value;
  }; 

  function double4_set_Parse (value) {
    $thisType.double4$Parse$value = value;
  }; 

  function double4_set_r (value) {
    this.x = +value;
  }; 

  function double4_set_rgb (value) {
    (this.xyz = value.MemberwiseClone());
  }; 

  function double4_set_xy (value) {
    this.x = +value.x;
    this.y = +value.y;
  }; 

  function double4_set_xyz (value) {
    this.x = +value.x;
    this.y = +value.y;
    this.z = +value.z;
  }; 

  function double4_Sub$2D (right) {
    this.x = +this.x - +right.x;
    this.y = +this.y - +right.y;
    this.z = +this.z - +right.z;
    this.w = +this.w - +right.w;
  }; 

  function double4_Sub$2E (/* ref */ right) {
    this.x = +this.x - +right.get().x;
    this.y = +this.y - +right.get().y;
    this.z = +this.z - +right.get().z;
    this.w = +this.w - +right.get().w;
  }; 

  function double4_Sub$2F (a, b) {
    a.x = +a.x - +b.x;
    a.y = +a.y - +b.y;
    a.z = +a.z - +b.z;
    a.w = +a.w - +b.w;
    return a;
  }; 

  function double4_Sub$30 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +a.get().x - +b.get().x;
    result.get().y = +a.get().y - +b.get().y;
    result.get().z = +a.get().z - +b.get().z;
    result.get().w = +a.get().w - +b.get().w;
  }; 

  function double4_Subtract$31 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Subtract(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  }; 

  function double4_Subtract$32 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x - +b.get().x), (+a.get().y - +b.get().y), (+a.get().z - +b.get().z), (+a.get().w - +b.get().w)));
  }; 

  function double4_ToArray () {
    return JSIL.Array.New($T00(), [this.x, this.y, this.z, this.w]);
  }; 

  function double4_toString () {
    return $T08().Format("({0}, {1}, {2}, {3})", JSIL.Array.New($T03(), [$T00().$Box(this.x), $T00().$Box(this.y), $T00().$Box(this.z), $T00().$Box(this.w)]));
  }; 

  function double4_Transform$33 ($vec, $mat) {
    var mat = new JSIL.BoxedVariable($mat.MemberwiseClone());
    var vec = new JSIL.BoxedVariable($vec.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $S09().CallStatic($thisType, "Transform", null, /* ref */ vec, /* ref */ mat, /* ref */ result);
    return result.get();
  }; 

  function double4_Transform$34 (/* ref */ vec, /* ref */ mat, /* ref */ result) {
    result.set($S00().Construct(((((+vec.get().x * +mat.get().Row0.x) + (+vec.get().y * +mat.get().Row1.x)) + (+vec.get().z * +mat.get().Row2.x)) + (+vec.get().w * +mat.get().Row3.x)), ((((+vec.get().x * +mat.get().Row0.y) + (+vec.get().y * +mat.get().Row1.y)) + (+vec.get().z * +mat.get().Row2.y)) + (+vec.get().w * +mat.get().Row3.y)), ((((+vec.get().x * +mat.get().Row0.z) + (+vec.get().y * +mat.get().Row1.z)) + (+vec.get().z * +mat.get().Row2.z)) + (+vec.get().w * +mat.get().Row3.z)), ((((+vec.get().x * +mat.get().Row0.w) + (+vec.get().y * +mat.get().Row1.w)) + (+vec.get().z * +mat.get().Row2.w)) + (+vec.get().w * +mat.get().Row3.w))));
  }; 

  function double4_Transform$35 ($vec, $quat) {
    var quat = new JSIL.BoxedVariable($quat.MemberwiseClone());
    var vec = new JSIL.BoxedVariable($vec.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $S0A().CallStatic($thisType, "Transform", null, /* ref */ vec, /* ref */ quat, /* ref */ result);
    return result.get();
  }; 

  function double4_Transform$36 (/* ref */ vec, /* ref */ quat, /* ref */ result) {
    var i = new JSIL.BoxedVariable(new ($T0A())());
    var v = new JSIL.BoxedVariable(new ($T0A())());
    var t = new JSIL.BoxedVariable(new ($T0A())());
    $T0A().prototype._ctor.call(v.get().MemberwiseClone(), vec.get().x, vec.get().y, vec.get().z, vec.get().w);
    $T0A().Invert(/* ref */ quat, /* ref */ i);
    $S0B().CallStatic($T0A(), "Multiply", null, /* ref */ quat, /* ref */ v, /* ref */ t);
    $S0B().CallStatic($T0A(), "Multiply", null, /* ref */ t, /* ref */ i, /* ref */ v);
    result.set($S00().Construct((v.get()).get_x(), (v.get()).get_y(), (v.get()).get_z(), (v.get()).get_w()));
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.Core.double4", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 4, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double
        ]), 
      double4__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.double2")), 
      double4__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.double3")), 
      double4__ctor$02
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("Fusee.Math.Core.double3"), $.Double]), 
      double4__ctor$03
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Type), 
      double4__ctor$04
    );

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($.Type), 
      double4_Add$05
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      double4_Add$06
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4_Add$07
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Add$08
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type, $.Double, 
          $.Double
        ]), 
      double4_BaryCentric
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type
        ]), 
      double4_Clamp$09
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Clamp$0A
    );

    $.Method({Static:false, Public:true }, "Div", 
      JSIL.MethodSignature.Action($.Double), 
      double4_Div$0B
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double4_Div$0C
    );

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Div$0D
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double4_Divide$0E
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Divide$0F
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4_Divide$10
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Divide$11
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature($.Double, [$.Type, $.Type]), 
      double4_Dot$12
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Double])
        ]), 
      double4_Dot$13
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      double4_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type]), 
      double4_Equals$14
    );

    $.Method({Static:false, Public:true }, "get_a", 
      JSIL.MethodSignature.Return($.Double), 
      double4_get_a
    );

    $.Method({Static:false, Public:true }, "get_b", 
      JSIL.MethodSignature.Return($.Double), 
      double4_get_b
    );

    $.Method({Static:false, Public:true }, "get_g", 
      JSIL.MethodSignature.Return($.Double), 
      double4_get_g
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      JSIL.MethodSignature.Return($.Double), 
      double4_get_Length
    );

    $.Method({Static:false, Public:true }, "get_LengthFast", 
      JSIL.MethodSignature.Return($.Double), 
      double4_get_LengthFast
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      JSIL.MethodSignature.Return($.Double), 
      double4_get_LengthSquared
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type])), 
      double4_get_Parse
    )
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_r", 
      JSIL.MethodSignature.Return($.Double), 
      double4_get_r
    );

    $.Method({Static:false, Public:true }, "get_rgb", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.double3")), 
      double4_get_rgb
    );

    $.Method({Static:false, Public:true }, "get_xy", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.double2")), 
      double4_get_xy
    );

    $.Method({Static:false, Public:true }, "get_xyz", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.double3")), 
      double4_get_xyz
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      double4_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Double
        ]), 
      double4_Lerp$15
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Lerp$16
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4_Max$17
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Max$18
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4_Min$19
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Min$1A
    );

    $.Method({Static:false, Public:true }, "Mult", 
      JSIL.MethodSignature.Action($.Double), 
      double4_Mult$1B
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double4_Mult$1C
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Mult$1D
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double4_Multiply$1E
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Multiply$1F
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4_Multiply$20
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Multiply$21
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      JSIL.MethodSignature.Void, 
      double4_Normalize$22
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double4_Normalize$23
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double4_Normalize$24
    );

    $.Method({Static:false, Public:true }, "NormalizeFast", 
      JSIL.MethodSignature.Void, 
      double4_NormalizeFast$25
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double4_NormalizeFast$26
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double4_NormalizeFast$27
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Division", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double4_op_Division
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      double4_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      double4_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double4_op_Multiply$28
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Double, $.Type]), 
      double4_op_Multiply$29
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "op_UnaryNegation", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double4_op_UnaryNegation
    );

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double
        ]), 
      double4_Scale$2A
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($.Type), 
      double4_Scale$2B
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      double4_Scale$2C
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "set_a", 
      JSIL.MethodSignature.Action($.Double), 
      double4_set_a
    );

    $.Method({Static:false, Public:true }, "set_b", 
      JSIL.MethodSignature.Action($.Double), 
      double4_set_b
    );

    $.Method({Static:false, Public:true }, "set_g", 
      JSIL.MethodSignature.Action($.Double), 
      double4_set_g
    );

    $.Method({Static:true , Public:true }, "set_Parse", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type])), 
      double4_set_Parse
    )
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "set_r", 
      JSIL.MethodSignature.Action($.Double), 
      double4_set_r
    );

    $.Method({Static:false, Public:true }, "set_rgb", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.double3")), 
      double4_set_rgb
    );

    $.Method({Static:false, Public:true }, "set_xy", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.double2")), 
      double4_set_xy
    );

    $.Method({Static:false, Public:true }, "set_xyz", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.double3")), 
      double4_set_xyz
    );

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($.Type), 
      double4_Sub$2D
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      double4_Sub$2E
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4_Sub$2F
    );

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Sub$30
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4_Subtract$31
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Subtract$32
    );

    $.Method({Static:false, Public:true }, "ToArray", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Double])), 
      double4_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      double4_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm07.TypeRef("Fusee.Math.Core.double4x4")]), 
      double4_Transform$33
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Transform$34
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm07.TypeRef("Fusee.Math.Core.QuaternionD")]), 
      double4_Transform$35
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.QuaternionD")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Transform$36
    );

    $.Field({Static:false, Public:true }, "x", $.Double);

    $.Field({Static:false, Public:true }, "y", $.Double);

    $.Field({Static:false, Public:true }, "z", $.Double);

    $.Field({Static:false, Public:true }, "w", $.Double);

    $.Field({Static:true , Public:true }, "UnitX", $.Type);

    $.Field({Static:true , Public:true }, "UnitY", $.Type);

    $.Field({Static:true , Public:true }, "UnitZ", $.Type);

    $.Field({Static:true , Public:true }, "UnitW", $.Type);

    $.Field({Static:true , Public:true }, "Zero", $.Type);

    $.Field({Static:true , Public:true , ReadOnly:true }, "One", $.Type);

    $.Field({Static:true , Public:false}, "double4$Parse$value", $asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type]))
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"))
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerBrowsableAttribute"), function () { return [$asm15.System.Diagnostics.DebuggerBrowsableState.Never]; });


    function double4__cctor () {
      $thisType.UnitX = new $thisType();
      $thisType.UnitY = new $thisType();
      $thisType.UnitZ = new $thisType();
      $thisType.UnitW = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.One = new $thisType();
      $thisType.UnitX = $S00().Construct(1, 0, 0, 0);
      $thisType.UnitY = $S00().Construct(0, 1, 0, 0);
      $thisType.UnitZ = $S00().Construct(0, 0, 1, 0);
      $thisType.UnitW = $S00().Construct(0, 0, 0, 1);
      $thisType.Zero = $S00().Construct(0, 0, 0, 0);
      $thisType.One = $S00().Construct(1, 1, 1, 1);
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      double4__cctor
    );

    $.Property({Static:false, Public:true }, "Length", $.Double);

    $.Property({Static:false, Public:true }, "LengthFast", $.Double);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Double);

    $.Property({Static:false, Public:true }, "xy", $asm07.TypeRef("Fusee.Math.Core.double2"));

    $.Property({Static:false, Public:true }, "xyz", $asm07.TypeRef("Fusee.Math.Core.double3"));

    $.Property({Static:false, Public:true }, "r", $.Double);

    $.Property({Static:false, Public:true }, "g", $.Double);

    $.Property({Static:false, Public:true }, "b", $.Double);

    $.Property({Static:false, Public:true }, "rgb", $asm07.TypeRef("Fusee.Math.Core.double3"));

    $.Property({Static:false, Public:true }, "a", $.Double);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type]));

    $.ImplementInterfaces(
      /* 0 */ $asm15.TypeRef("System.IEquatable`1", [$.Type])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Math.Core.double4x4 */ 

(function double4x4$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.Fusee.Math.Core.double4)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm15.System.Double)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm07.Fusee.Math.Core.double3)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm15.System.Math)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm15.System.ArgumentOutOfRangeException)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm15.System.Boolean)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm15.System.Object)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm07.Fusee.Math.Core.Converter$b2.Of($asm15.System.String, $asm07.Fusee.Math.Core.double4x4))) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm15.System.String)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.double4x4"), [
        $asm07.TypeRef("Fusee.Math.Core.double4"), $asm07.TypeRef("Fusee.Math.Core.double4"), 
        $asm07.TypeRef("Fusee.Math.Core.double4"), $asm07.TypeRef("Fusee.Math.Core.double4")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.double4"), [
        $asm15.TypeRef("System.Double"), $asm15.TypeRef("System.Double"), 
        $asm15.TypeRef("System.Double"), $asm15.TypeRef("System.Double")
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.double4x4"), [
        $asm15.TypeRef("System.Double"), $asm15.TypeRef("System.Double"), 
        $asm15.TypeRef("System.Double"), $asm15.TypeRef("System.Double"), 
        $asm15.TypeRef("System.Double"), $asm15.TypeRef("System.Double"), 
        $asm15.TypeRef("System.Double"), $asm15.TypeRef("System.Double"), 
        $asm15.TypeRef("System.Double"), $asm15.TypeRef("System.Double"), 
        $asm15.TypeRef("System.Double"), $asm15.TypeRef("System.Double"), 
        $asm15.TypeRef("System.Double"), $asm15.TypeRef("System.Double"), 
        $asm15.TypeRef("System.Double"), $asm15.TypeRef("System.Double")
      ]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.ConstructorSignature($asm15.TypeRef("System.ArgumentOutOfRangeException"), [$asm15.TypeRef("System.String")]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.double3"), [
        $asm15.TypeRef("System.Double"), $asm15.TypeRef("System.Double"), 
        $asm15.TypeRef("System.Double")
      ]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.double4"), [$asm07.TypeRef("Fusee.Math.Core.double4"), $asm15.TypeRef("System.Double")]))) ();
  };


  function double4x4__ctor$00 (row0, row1, row2, row3) {
    this.Row0 = row0.MemberwiseClone();
    this.Row1 = row1.MemberwiseClone();
    this.Row2 = row2.MemberwiseClone();
    this.Row3 = row3.MemberwiseClone();
  }; 

  function double4x4__ctor$01 (m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    this.Row0 = $S01().Construct(m00, m01, m02, m03);
    this.Row1 = $S01().Construct(m10, m11, m12, m13);
    this.Row2 = $S01().Construct(m20, m21, m22, m23);
    this.Row3 = $S01().Construct(m30, m31, m32, m33);
  }; 

  function double4x4_Add (left, right) {
    return $S02().Construct((+left.get_M11() + +right.get_M11()), (+left.get_M12() + +right.get_M12()), (+left.get_M13() + +right.get_M13()), (+left.get_M14() + +right.get_M14()), (+left.get_M21() + +right.get_M21()), (+left.get_M22() + +right.get_M22()), (+left.get_M23() + +right.get_M23()), (+left.get_M24() + +right.get_M24()), (+left.get_M31() + +right.get_M31()), (+left.get_M32() + +right.get_M32()), (+left.get_M33() + +right.get_M33()), (+left.get_M34() + +right.get_M34()), (+left.get_M41() + +right.get_M41()), (+left.get_M42() + +right.get_M42()), (+left.get_M43() + +right.get_M43()), (+left.get_M44() + +right.get_M44()));
  }; 

  function double4x4_CreateFromAxisAngle$02 (axis, angle, /* ref */ result) {
    var cos = (Math.cos(-angle));
    var sin = (Math.sin(-angle));
    var t = 1 - cos;
    axis.Normalize();
    result.set($S02().Construct((((t * +axis.x) * +axis.x) + cos), (((t * +axis.x) * +axis.y) + (sin * +axis.z)), (((t * +axis.x) * +axis.z) - (sin * +axis.y)), 0, (((t * +axis.x) * +axis.y) - (sin * +axis.z)), (((t * +axis.y) * +axis.y) + cos), (((t * +axis.y) * +axis.z) + (sin * +axis.x)), 0, (((t * +axis.x) * +axis.z) + (sin * +axis.y)), (((t * +axis.y) * +axis.z) - (sin * +axis.x)), (((t * +axis.z) * +axis.z) + cos), 0, 0, 0, 0, 1));
  }; 

  function double4x4_CreateFromAxisAngle$03 (axis, angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateFromAxisAngle(axis.MemberwiseClone(), angle, /* ref */ result);
    return result.get();
  }; 

  function double4x4_CreateOrthographic$04 (width, height, zNear, zFar, /* ref */ result) {
    $thisType.CreateOrthographicOffCenter(
      +((-width / 2)), 
      +((+width / 2)), 
      +((-height / 2)), 
      +((+height / 2)), 
      zNear, 
      zFar, 
      /* ref */ result
    );
  }; 

  function double4x4_CreateOrthographic$05 (width, height, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateOrthographicOffCenter(
      +((-width / 2)), 
      +((+width / 2)), 
      +((-height / 2)), 
      +((+height / 2)), 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  }; 

  function double4x4_CreateOrthographicOffCenter$06 (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    result.set(new $thisType());
    var invRL = +((1 / (+right - +left)));
    var invTB = +((1 / (+top - +bottom)));
    var invFN = +((1 / (+zFar - +zNear)));
    (result.get()).set_M11(2 * invRL);
    (result.get()).set_M22(2 * invTB);
    (result.get()).set_M33(2 * invFN);
    (result.get()).set_M14(-(+right + +left) * invRL);
    (result.get()).set_M24(-(+top + +bottom) * invTB);
    (result.get()).set_M34(-(+zFar + +zNear) * invFN);
    (result.get()).set_M44(1);
  }; 

  function double4x4_CreateOrthographicOffCenter$07 (left, right, bottom, top, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateOrthographicOffCenter(
      left, 
      right, 
      bottom, 
      top, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  }; 

  function double4x4_CreateOrthographicOffCenterRH (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    result.set(new $thisType());
    var invRL = +((1 / (+right - +left)));
    var invTB = +((1 / (+top - +bottom)));
    var invFN = +((1 / (+zFar - +zNear)));
    (result.get()).set_M11(2 * invRL);
    (result.get()).set_M22(2 * invTB);
    (result.get()).set_M33(-2 * invFN);
    (result.get()).set_M14(-(+right + +left) * invRL);
    (result.get()).set_M24(-(+top + +bottom) * invTB);
    (result.get()).set_M34(-(+zFar + +zNear) * invFN);
    (result.get()).set_M44(1);
  }; 

  function double4x4_CreatePerspectiveFieldOfView$08 (fovy, aspect, zNear, zFar, /* ref */ result) {
    if ((+fovy <= 0) || (+fovy > 3.1415926535897931)) {
      throw $S03().Construct("fovy");
    }
    var flag2 = +aspect <= 0;
    if (flag2) {
      throw $S03().Construct("aspect");
    }
    if (+zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (+zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (+zNear >= +zFar) {
      throw $S03().Construct("zNear");
    }
    var yMax = +zNear * (Math.tan((0.5 * +fovy)));
    var xMin = -yMax * +aspect;
    var xMax = yMax * +aspect;
    $thisType.CreatePerspectiveOffCenter(
      xMin, 
      xMax, 
      -yMax, 
      yMax, 
      zNear, 
      zFar, 
      /* ref */ result
    );
  }; 

  function double4x4_CreatePerspectiveFieldOfView$09 (fovy, aspect, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreatePerspectiveFieldOfView(
      fovy, 
      aspect, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  }; 

  function double4x4_CreatePerspectiveFieldOfView_ROW$0A (fovy, aspect, zNear, zFar, /* ref */ result) {
    if ((+fovy <= 0) || (+fovy > 3.1415926535897931)) {
      throw $S03().Construct("fovy");
    }
    var flag2 = +aspect <= 0;
    if (flag2) {
      throw $S03().Construct("aspect");
    }
    if (+zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (+zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (+zNear >= +zFar) {
      throw $S03().Construct("zNear");
    }
    var yMax = +zNear * (Math.tan((0.5 * +fovy)));
    var xMin = -yMax * +aspect;
    var xMax = yMax * +aspect;
    $thisType.CreatePerspectiveOffCenter_ROW(
      xMin, 
      xMax, 
      -yMax, 
      yMax, 
      zNear, 
      zFar, 
      /* ref */ result
    );
  }; 

  function double4x4_CreatePerspectiveFieldOfView_ROW$0B (fovy, aspect, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreatePerspectiveFieldOfView_ROW(
      fovy, 
      aspect, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  }; 

  function double4x4_CreatePerspectiveOffCenter$0C (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    if (+zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    var flag2 = +zFar <= 0;
    if (flag2) {
      throw $S03().Construct("zFar");
    }
    var flag3 = +zNear >= +zFar;
    if (flag3) {
      throw $S03().Construct("zNear");
    }
    var x = +(((2 * +zNear) / (+right - +left)));
    var y = +(((2 * +zNear) / (+top - +bottom)));
    var a = +(((+left + +right) / (+left - +right)));
    var b = +(((+top + +bottom) / (+bottom - +top)));
    var c = +(((+zFar + +zNear) / (+zFar - +zNear)));
    var d = +((-((2 * +zFar) * +zNear) / (+zFar - +zNear)));
    result.set($S02().Construct(x, 0, a, 0, 0, y, b, 0, 0, 0, c, d, 0, 0, 1, 0));
  }; 

  function double4x4_CreatePerspectiveOffCenter$0D (left, right, bottom, top, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreatePerspectiveOffCenter(
      left, 
      right, 
      bottom, 
      top, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  }; 

  function double4x4_CreatePerspectiveOffCenter_ROW (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    var flag = +zNear <= 0;
    if (flag) {
      throw $S03().Construct("zNear");
    }
    var flag2 = +zFar <= 0;
    if (flag2) {
      throw $S03().Construct("zFar");
    }
    var flag3 = +zNear >= +zFar;
    if (flag3) {
      throw $S03().Construct("zNear");
    }
    var x = +(((2 * +zNear) / (+right - +left)));
    var y = +(((2 * +zNear) / (+top - +bottom)));
    var a = +(((+left + +right) / (+left - +right)));
    var b = +(((+top + +bottom) / (+bottom - +top)));
    var c = +(((+zFar + +zNear) / (+zFar - +zNear)));
    var d = +((-((2 * +zFar) * +zNear) / (+zFar - +zNear)));
    result.set($S02().Construct(x, 0, 0, 0, 0, y, 0, 0, a, b, c, 1, 0, 0, d, 0));
  }; 

  function double4x4_CreatePerspectiveOffCenterRH (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    var flag = +zNear <= 0;
    if (flag) {
      throw $S03().Construct("zNear");
    }
    var flag2 = +zFar <= 0;
    if (flag2) {
      throw $S03().Construct("zFar");
    }
    var flag3 = +zNear >= +zFar;
    if (flag3) {
      throw $S03().Construct("zNear");
    }
    var x = +(((2 * +zNear) / (+right - +left)));
    var y = +(((2 * +zNear) / (+top - +bottom)));
    var a = +(((+right + +left) / (+right - +left)));
    var b = +(((+top + +bottom) / (+top - +bottom)));
    var c = +((-(+zFar + +zNear) / (+zFar - +zNear)));
    var d = +((-((2 * +zFar) * +zNear) / (+zFar - +zNear)));
    result.set($S02().Construct(x, 0, a, 0, 0, y, b, 0, 0, 0, c, d, 0, 0, -1, 0));
  }; 

  function double4x4_CreateRotationX$0E (angle, /* ref */ result) {
    var cos = (Math.cos(angle));
    var sin = (Math.sin(angle));
    result.get().Row0 = $T00().UnitX.MemberwiseClone();
    result.get().Row1 = $S01().Construct(0, cos, -sin, 0);
    result.get().Row2 = $S01().Construct(0, sin, cos, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  }; 

  function double4x4_CreateRotationX$0F (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationX(angle, /* ref */ result);
    return result.get();
  }; 

  function double4x4_CreateRotationX_ROW$10 (angle, /* ref */ result) {
    var cos = (Math.cos(angle));
    var sin = (Math.sin(angle));
    result.get().Row0 = $T00().UnitX.MemberwiseClone();
    result.get().Row1 = $S01().Construct(0, cos, sin, 0);
    result.get().Row2 = $S01().Construct(0, -sin, cos, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  }; 

  function double4x4_CreateRotationX_ROW$11 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationX_ROW(angle, /* ref */ result);
    return result.get();
  }; 

  function double4x4_CreateRotationY$12 (angle, /* ref */ result) {
    var cos = (Math.cos(angle));
    var sin = (Math.sin(angle));
    result.get().Row0 = $S01().Construct(cos, 0, sin, 0);
    result.get().Row1 = $T00().UnitY.MemberwiseClone();
    result.get().Row2 = $S01().Construct(-sin, 0, cos, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  }; 

  function double4x4_CreateRotationY$13 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationY(angle, /* ref */ result);
    return result.get();
  }; 

  function double4x4_CreateRotationY_ROW$14 (angle, /* ref */ result) {
    var cos = (Math.cos(angle));
    var sin = (Math.sin(angle));
    result.get().Row0 = $S01().Construct(cos, 0, -sin, 0);
    result.get().Row1 = $T00().UnitY.MemberwiseClone();
    result.get().Row2 = $S01().Construct(sin, 0, cos, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  }; 

  function double4x4_CreateRotationY_ROW$15 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationY_ROW(angle, /* ref */ result);
    return result.get();
  }; 

  function double4x4_CreateRotationZ$16 (angle, /* ref */ result) {
    var cos = (Math.cos(angle));
    var sin = (Math.sin(angle));
    result.get().Row0 = $S01().Construct(cos, -sin, 0, 0);
    result.get().Row1 = $S01().Construct(sin, cos, 0, 0);
    result.get().Row2 = $T00().UnitZ.MemberwiseClone();
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  }; 

  function double4x4_CreateRotationZ$17 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationZ(angle, /* ref */ result);
    return result.get();
  }; 

  function double4x4_CreateTranslation$18 (x, y, z, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    (result.get()).set_M14(x);
    (result.get()).set_M24(y);
    (result.get()).set_M34(z);
  }; 

  function double4x4_CreateTranslation$19 (/* ref */ vector, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    (result.get()).set_M14(vector.get().x);
    (result.get()).set_M24(vector.get().y);
    (result.get()).set_M34(vector.get().z);
  }; 

  function double4x4_CreateTranslation$1A (x, y, z) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateTranslation(x, y, z, /* ref */ result);
    return result.get();
  }; 

  function double4x4_CreateTranslation$1B (vector) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateTranslation(vector.x, vector.y, vector.z, /* ref */ result);
    return result.get();
  }; 

  function double4x4_CreateTranslation_ROW$1C (x, y, z, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    result.get().Row3 = $S01().Construct(x, y, z, 1);
  }; 

  function double4x4_CreateTranslation_ROW$1D (x, y, z) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateTranslation_ROW(x, y, z, /* ref */ result);
    return result.get();
  }; 

  function double4x4_Object_Equals (obj) {
    var flag = !$thisType.$Is(obj);
    return (!flag && this.Equals($thisType.$Cast(obj)));
  }; 

  function double4x4_Equals$1E (other) {
    return (!(!$T00().op_Equality(this.Row0, other.Row0) || 
        !$T00().op_Equality(this.Row1, other.Row1) || 
        !$T00().op_Equality(this.Row2, other.Row2)) && $T00().op_Equality(this.Row3, other.Row3));
  }; 

  function double4x4_get_Column0 () {
    return $S01().Construct(this.Row0.x, this.Row1.x, this.Row2.x, this.Row3.x);
  }; 

  function double4x4_get_Column1 () {
    return $S01().Construct(this.Row0.y, this.Row1.y, this.Row2.y, this.Row3.y);
  }; 

  function double4x4_get_Column2 () {
    return $S01().Construct(this.Row0.z, this.Row1.z, this.Row2.z, this.Row3.z);
  }; 

  function double4x4_get_Column3 () {
    return $S01().Construct(this.Row0.w, this.Row1.w, this.Row2.w, this.Row3.w);
  }; 

  function double4x4_get_Determinant () {
    return ((((((((((((((((((((((((((+this.Row0.x * +this.Row1.y) * +this.Row2.z) * +this.Row3.w) - (((+this.Row0.x * +this.Row1.y) * +this.Row2.w) * +this.Row3.z)) + (((+this.Row0.x * +this.Row1.z) * +this.Row2.w) * +this.Row3.y)) - (((+this.Row0.x * +this.Row1.z) * +this.Row2.y) * +this.Row3.w)) + (((+this.Row0.x * +this.Row1.w) * +this.Row2.y) * +this.Row3.z)) - (((+this.Row0.x * +this.Row1.w) * +this.Row2.z) * +this.Row3.y)) - (((+this.Row0.y * +this.Row1.z) * +this.Row2.w) * +this.Row3.x)) + (((+this.Row0.y * +this.Row1.z) * +this.Row2.x) * +this.Row3.w)) - (((+this.Row0.y * +this.Row1.w) * +this.Row2.x) * +this.Row3.z)) + (((+this.Row0.y * +this.Row1.w) * +this.Row2.z) * +this.Row3.x)) - (((+this.Row0.y * +this.Row1.x) * +this.Row2.z) * +this.Row3.w)) + (((+this.Row0.y * +this.Row1.x) * +this.Row2.w) * +this.Row3.z)) + (((+this.Row0.z * +this.Row1.w) * +this.Row2.x) * +this.Row3.y)) - (((+this.Row0.z * +this.Row1.w) * +this.Row2.y) * +this.Row3.x)) + (((+this.Row0.z * +this.Row1.x) * +this.Row2.y) * +this.Row3.w)) - (((+this.Row0.z * +this.Row1.x) * +this.Row2.w) * +this.Row3.y)) + (((+this.Row0.z * +this.Row1.y) * +this.Row2.w) * +this.Row3.x)) - (((+this.Row0.z * +this.Row1.y) * +this.Row2.x) * +this.Row3.w)) - (((+this.Row0.w * +this.Row1.x) * +this.Row2.y) * +this.Row3.z)) + (((+this.Row0.w * +this.Row1.x) * +this.Row2.z) * +this.Row3.y)) - (((+this.Row0.w * +this.Row1.y) * +this.Row2.z) * +this.Row3.x)) + (((+this.Row0.w * +this.Row1.y) * +this.Row2.x) * +this.Row3.z)) - (((+this.Row0.w * +this.Row1.z) * +this.Row2.x) * +this.Row3.y)) + (((+this.Row0.w * +this.Row1.z) * +this.Row2.y) * +this.Row3.x));
  }; 

  function double4x4_get_IsAffine () {
    return $T00().op_Equality(this.Row3, $T00().UnitW);
  }; 

  function double4x4_get_M11 () {
    return this.Row0.x;
  }; 

  function double4x4_get_M12 () {
    return this.Row0.y;
  }; 

  function double4x4_get_M13 () {
    return this.Row0.z;
  }; 

  function double4x4_get_M14 () {
    return this.Row0.w;
  }; 

  function double4x4_get_M21 () {
    return this.Row1.x;
  }; 

  function double4x4_get_M22 () {
    return this.Row1.y;
  }; 

  function double4x4_get_M23 () {
    return this.Row1.z;
  }; 

  function double4x4_get_M24 () {
    return this.Row1.w;
  }; 

  function double4x4_get_M31 () {
    return this.Row2.x;
  }; 

  function double4x4_get_M32 () {
    return this.Row2.y;
  }; 

  function double4x4_get_M33 () {
    return this.Row2.z;
  }; 

  function double4x4_get_M34 () {
    return this.Row2.w;
  }; 

  function double4x4_get_M41 () {
    return this.Row3.x;
  }; 

  function double4x4_get_M42 () {
    return this.Row3.y;
  }; 

  function double4x4_get_M43 () {
    return this.Row3.z;
  }; 

  function double4x4_get_M44 () {
    return this.Row3.w;
  }; 

  function double4x4_get_Offset () {
    return $S04().Construct(this.Row0.w, this.Row1.w, this.Row2.w);
  }; 

  function double4x4_get_Parse () {
    return $thisType.double4x4$Parse$value;
  }; 

  function double4x4_GetHashCode () {
    return ((((JSIL.ObjectHashCode(this.Row0, !false, $T06().__Type__)) ^ (JSIL.ObjectHashCode(this.Row1, !false, $T06().__Type__))) ^ (JSIL.ObjectHashCode(this.Row2, !false, $T06().__Type__))) ^ (JSIL.ObjectHashCode(this.Row3, !false, $T06().__Type__)));
  }; 

  function double4x4_Invert$1F () {
    JSIL.CopyMembers($thisType.Invert(this).MemberwiseClone(), this);
  }; 

  function double4x4_Invert$20 (mat) {
    var flag = $thisType.op_Equality(mat, $thisType.Identity) || 
    $thisType.op_Equality(mat, $thisType.Zero);
    if (flag) {
      var result = mat.MemberwiseClone();
    } else {
      var isAffine = mat.get_IsAffine();
      if (isAffine) {
        result = $thisType.InvertAffine(mat.MemberwiseClone());
      } else {
        mat.Transpose();
        var tmp0 = +mat.get_M33() * +mat.get_M44();
        var tmp = +mat.get_M34() * +mat.get_M43();
        var tmp2 = +mat.get_M32() * +mat.get_M44();
        var tmp3 = +mat.get_M34() * +mat.get_M42();
        var tmp4 = +mat.get_M32() * +mat.get_M43();
        var tmp5 = +mat.get_M33() * +mat.get_M42();
        var tmp6 = +mat.get_M31() * +mat.get_M44();
        var tmp7 = +mat.get_M34() * +mat.get_M41();
        var tmp8 = +mat.get_M31() * +mat.get_M43();
        var tmp9 = +mat.get_M33() * +mat.get_M41();
        var tmp10 = +mat.get_M31() * +mat.get_M42();
        var tmp11 = +mat.get_M32() * +mat.get_M41();
        var m11 = ((tmp0 * +mat.get_M22()) + (tmp3 * +mat.get_M23())) + (tmp4 * +mat.get_M24());
        m11 -= ((tmp * +mat.get_M22()) + (tmp2 * +mat.get_M23())) + (tmp5 * +mat.get_M24());
        var m12 = ((tmp * +mat.get_M21()) + (tmp6 * +mat.get_M23())) + (tmp9 * +mat.get_M24());
        m12 -= ((tmp0 * +mat.get_M21()) + (tmp7 * +mat.get_M23())) + (tmp8 * +mat.get_M24());
        var m13 = ((tmp2 * +mat.get_M21()) + (tmp7 * +mat.get_M22())) + (tmp10 * +mat.get_M24());
        m13 -= ((tmp3 * +mat.get_M21()) + (tmp6 * +mat.get_M22())) + (tmp11 * +mat.get_M24());
        var m14 = ((tmp5 * +mat.get_M21()) + (tmp8 * +mat.get_M22())) + (tmp11 * +mat.get_M23());
        m14 -= ((tmp4 * +mat.get_M21()) + (tmp9 * +mat.get_M22())) + (tmp10 * +mat.get_M23());
        var m15 = ((tmp * +mat.get_M12()) + (tmp2 * +mat.get_M13())) + (tmp5 * +mat.get_M14());
        m15 -= ((tmp0 * +mat.get_M12()) + (tmp3 * +mat.get_M13())) + (tmp4 * +mat.get_M14());
        var m16 = ((tmp0 * +mat.get_M11()) + (tmp7 * +mat.get_M13())) + (tmp8 * +mat.get_M14());
        m16 -= ((tmp * +mat.get_M11()) + (tmp6 * +mat.get_M13())) + (tmp9 * +mat.get_M14());
        var m17 = ((tmp3 * +mat.get_M11()) + (tmp6 * +mat.get_M12())) + (tmp11 * +mat.get_M14());
        m17 -= ((tmp2 * +mat.get_M11()) + (tmp7 * +mat.get_M12())) + (tmp10 * +mat.get_M14());
        var m18 = ((tmp4 * +mat.get_M11()) + (tmp9 * +mat.get_M12())) + (tmp10 * +mat.get_M13());
        m18 -= ((tmp5 * +mat.get_M11()) + (tmp8 * +mat.get_M12())) + (tmp11 * +mat.get_M13());
        tmp0 = +mat.get_M13() * +mat.get_M24();
        tmp = +mat.get_M14() * +mat.get_M23();
        tmp2 = +mat.get_M12() * +mat.get_M24();
        tmp3 = +mat.get_M14() * +mat.get_M22();
        tmp4 = +mat.get_M12() * +mat.get_M23();
        tmp5 = +mat.get_M13() * +mat.get_M22();
        tmp6 = +mat.get_M11() * +mat.get_M24();
        tmp7 = +mat.get_M14() * +mat.get_M21();
        tmp8 = +mat.get_M11() * +mat.get_M23();
        tmp9 = +mat.get_M13() * +mat.get_M21();
        tmp10 = +mat.get_M11() * +mat.get_M22();
        tmp11 = +mat.get_M12() * +mat.get_M21();
        var m19 = ((tmp0 * +mat.get_M42()) + (tmp3 * +mat.get_M43())) + (tmp4 * +mat.get_M44());
        m19 -= ((tmp * +mat.get_M42()) + (tmp2 * +mat.get_M43())) + (tmp5 * +mat.get_M44());
        var m20 = ((tmp * +mat.get_M41()) + (tmp6 * +mat.get_M43())) + (tmp9 * +mat.get_M44());
        m20 -= ((tmp0 * +mat.get_M41()) + (tmp7 * +mat.get_M43())) + (tmp8 * +mat.get_M44());
        var m21 = ((tmp2 * +mat.get_M41()) + (tmp7 * +mat.get_M42())) + (tmp10 * +mat.get_M44());
        m21 -= ((tmp3 * +mat.get_M41()) + (tmp6 * +mat.get_M42())) + (tmp11 * +mat.get_M44());
        var m22 = ((tmp5 * +mat.get_M41()) + (tmp8 * +mat.get_M42())) + (tmp11 * +mat.get_M43());
        m22 -= ((tmp4 * +mat.get_M41()) + (tmp9 * +mat.get_M42())) + (tmp10 * +mat.get_M43());
        var m23 = ((tmp2 * +mat.get_M33()) + (tmp5 * +mat.get_M34())) + (tmp * +mat.get_M32());
        m23 -= ((tmp4 * +mat.get_M34()) + (tmp0 * +mat.get_M32())) + (tmp3 * +mat.get_M33());
        var m24 = ((tmp8 * +mat.get_M34()) + (tmp0 * +mat.get_M31())) + (tmp7 * +mat.get_M33());
        m24 -= ((tmp6 * +mat.get_M33()) + (tmp9 * +mat.get_M34())) + (tmp * +mat.get_M31());
        var m25 = ((tmp6 * +mat.get_M32()) + (tmp11 * +mat.get_M34())) + (tmp3 * +mat.get_M31());
        m25 -= ((tmp10 * +mat.get_M34()) + (tmp2 * +mat.get_M31())) + (tmp7 * +mat.get_M32());
        var m26 = ((tmp10 * +mat.get_M33()) + (tmp4 * +mat.get_M31())) + (tmp9 * +mat.get_M32());
        m26 -= ((tmp8 * +mat.get_M32()) + (tmp11 * +mat.get_M33())) + (tmp5 * +mat.get_M31());
        var det = (((+mat.get_M11() * m11) + (+mat.get_M12() * m12)) + (+mat.get_M13() * m13)) + (+mat.get_M14() * m14);
        var flag2 = (det > 1.1920930376163597E-07) || 
        (det < -1.1920930376163597E-07);
        if (flag2) {
          det = +((1 / det));
          (mat = mat.MemberwiseClone(), 
            $thisType.prototype._ctor.call(mat, 
              det * m11, 
              det * m12, 
              det * m13, 
              det * m14, 
              det * m15, 
              det * m16, 
              det * m17, 
              det * m18, 
              det * m19, 
              det * m20, 
              det * m21, 
              det * m22, 
              det * m23, 
              det * m24, 
              det * m25, 
              det * m26
            ));
        } else {
          mat.Transpose();
        }
        result = mat.MemberwiseClone();
      }
    }
    return result;
  }; 

  function double4x4_InvertAffine (mat) {
    var val = -(((+mat.get_M11() * +mat.get_M14()) + (+mat.get_M21() * +mat.get_M24())) + (+mat.get_M31() * +mat.get_M34()));
    var val2 = -(((+mat.get_M12() * +mat.get_M14()) + (+mat.get_M22() * +mat.get_M24())) + (+mat.get_M32() * +mat.get_M34()));
    var val3 = -(((+mat.get_M13() * +mat.get_M14()) + (+mat.get_M23() * +mat.get_M24())) + (+mat.get_M33() * +mat.get_M34()));
    return $S00().Construct($S01().Construct(mat.get_M11(), mat.get_M21(), mat.get_M31(), val), $S01().Construct(mat.get_M12(), mat.get_M22(), mat.get_M32(), val2), $S01().Construct(mat.get_M13(), mat.get_M23(), mat.get_M33(), val3), $S01().Construct(0, 0, 0, 1));
  }; 

  function double4x4_LookAt$21 (eye, target, up) {
    var z = $T02().Normalize($T02().op_Subtraction(target.MemberwiseClone(), eye).MemberwiseClone());
    var x = $T02().Normalize($T02().Cross(up.MemberwiseClone(), z.MemberwiseClone()).MemberwiseClone());
    var y = $T02().Cross(z.MemberwiseClone(), x.MemberwiseClone());
    return $S02().Construct(x.x, x.y, x.z, -$T02().Dot(x, eye), y.x, y.y, y.z, -$T02().Dot(y, eye), z.x, z.y, z.z, -$T02().Dot(z, eye), 0, 0, 0, 1);
  }; 

  function double4x4_LookAt$22 (eyeX, eyeY, eyeZ, targetX, targetY, targetZ, upX, upY, upZ) {
    return $thisType.LookAt($S04().Construct(eyeX, eyeY, eyeZ), $S04().Construct(targetX, targetY, targetZ), $S04().Construct(upX, upY, upZ));
  }; 

  function double4x4_LookAt_ROW$23 (eye, target, up) {
    var z = $T02().Normalize($T02().op_Subtraction(target.MemberwiseClone(), eye).MemberwiseClone());
    var x = $T02().Normalize($T02().Cross(up.MemberwiseClone(), z.MemberwiseClone()).MemberwiseClone());
    var y = $T02().Cross(z.MemberwiseClone(), x.MemberwiseClone());
    return $S00().Construct($S01().Construct(x.x, y.x, z.x, 0), $S01().Construct(x.y, y.y, z.y, 0), $S01().Construct(x.z, y.z, z.z, 0), $S01().Construct(-$T02().Dot(x, eye), -$T02().Dot(y, eye), -$T02().Dot(z, eye), 1));
  }; 

  function double4x4_LookAt_ROW$24 (eyeX, eyeY, eyeZ, targetX, targetY, targetZ, upX, upY, upZ) {
    return $thisType.LookAt_ROW($S04().Construct(eyeX, eyeY, eyeZ), $S04().Construct(targetX, targetY, targetZ), $S04().Construct(upX, upY, upZ));
  }; 

  function double4x4_LookAtRH (eye, target, up) {
    var z = $T02().Normalize($T02().op_Subtraction(eye.MemberwiseClone(), target).MemberwiseClone());
    var x = $T02().Normalize($T02().Cross(up.MemberwiseClone(), z.MemberwiseClone()).MemberwiseClone());
    var y = $T02().Cross(z.MemberwiseClone(), x.MemberwiseClone());
    return $S02().Construct(x.x, x.y, x.z, -$T02().Dot(x, eye), y.x, y.y, y.z, -$T02().Dot(y, eye), z.x, z.y, z.z, -$T02().Dot(z, eye), 0, 0, 0, 1);
  }; 

  function double4x4_Mult$25 ($left, $right) {
    var right = new JSIL.BoxedVariable($right);
    var left = new JSIL.BoxedVariable($left);
    var result = new JSIL.BoxedVariable(new $thisType());
    var flag = $thisType.op_Equality(left.get(), $thisType.Identity);
    if (flag) {
      var result2 = right.get().MemberwiseClone();
    } else {
      var flag2 = $thisType.op_Equality(right.get(), $thisType.Identity);
      if (flag2) {
        result2 = left.get().MemberwiseClone();
      } else {
        var flag3 = $thisType.op_Equality(left.get(), $thisType.Zero) || 
        $thisType.op_Equality(right.get(), $thisType.Zero);
        if (flag3) {
          result2 = $thisType.Zero.MemberwiseClone();
        } else {
          var flag4 = (left.get()).get_IsAffine() && 
          (right.get()).get_IsAffine();
          if (flag4) {
            $thisType.MultAffine(/* ref */ left, /* ref */ right, /* ref */ result);
          } else {
            $thisType.Mult(/* ref */ left, /* ref */ right, /* ref */ result);
          }
          result2 = result.get().MemberwiseClone();
        }
      }
    }
    return result2;
  }; 

  function double4x4_Mult$26 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct(((((+(left.get()).get_M11() * +(right.get()).get_M11()) + (+(left.get()).get_M12() * +(right.get()).get_M21())) + (+(left.get()).get_M13() * +(right.get()).get_M31())) + (+(left.get()).get_M14() * +(right.get()).get_M41())), ((((+(left.get()).get_M11() * +(right.get()).get_M12()) + (+(left.get()).get_M12() * +(right.get()).get_M22())) + (+(left.get()).get_M13() * +(right.get()).get_M32())) + (+(left.get()).get_M14() * +(right.get()).get_M42())), ((((+(left.get()).get_M11() * +(right.get()).get_M13()) + (+(left.get()).get_M12() * +(right.get()).get_M23())) + (+(left.get()).get_M13() * +(right.get()).get_M33())) + (+(left.get()).get_M14() * +(right.get()).get_M43())), ((((+(left.get()).get_M11() * +(right.get()).get_M14()) + (+(left.get()).get_M12() * +(right.get()).get_M24())) + (+(left.get()).get_M13() * +(right.get()).get_M34())) + (+(left.get()).get_M14() * +(right.get()).get_M44())), ((((+(left.get()).get_M21() * +(right.get()).get_M11()) + (+(left.get()).get_M22() * +(right.get()).get_M21())) + (+(left.get()).get_M23() * +(right.get()).get_M31())) + (+(left.get()).get_M24() * +(right.get()).get_M41())), ((((+(left.get()).get_M21() * +(right.get()).get_M12()) + (+(left.get()).get_M22() * +(right.get()).get_M22())) + (+(left.get()).get_M23() * +(right.get()).get_M32())) + (+(left.get()).get_M24() * +(right.get()).get_M42())), ((((+(left.get()).get_M21() * +(right.get()).get_M13()) + (+(left.get()).get_M22() * +(right.get()).get_M23())) + (+(left.get()).get_M23() * +(right.get()).get_M33())) + (+(left.get()).get_M24() * +(right.get()).get_M43())), ((((+(left.get()).get_M21() * +(right.get()).get_M14()) + (+(left.get()).get_M22() * +(right.get()).get_M24())) + (+(left.get()).get_M23() * +(right.get()).get_M34())) + (+(left.get()).get_M24() * +(right.get()).get_M44())), ((((+(left.get()).get_M31() * +(right.get()).get_M11()) + (+(left.get()).get_M32() * +(right.get()).get_M21())) + (+(left.get()).get_M33() * +(right.get()).get_M31())) + (+(left.get()).get_M34() * +(right.get()).get_M41())), ((((+(left.get()).get_M31() * +(right.get()).get_M12()) + (+(left.get()).get_M32() * +(right.get()).get_M22())) + (+(left.get()).get_M33() * +(right.get()).get_M32())) + (+(left.get()).get_M34() * +(right.get()).get_M42())), ((((+(left.get()).get_M31() * +(right.get()).get_M13()) + (+(left.get()).get_M32() * +(right.get()).get_M23())) + (+(left.get()).get_M33() * +(right.get()).get_M33())) + (+(left.get()).get_M34() * +(right.get()).get_M43())), ((((+(left.get()).get_M31() * +(right.get()).get_M14()) + (+(left.get()).get_M32() * +(right.get()).get_M24())) + (+(left.get()).get_M33() * +(right.get()).get_M34())) + (+(left.get()).get_M34() * +(right.get()).get_M44())), ((((+(left.get()).get_M41() * +(right.get()).get_M11()) + (+(left.get()).get_M42() * +(right.get()).get_M21())) + (+(left.get()).get_M43() * +(right.get()).get_M31())) + (+(left.get()).get_M44() * +(right.get()).get_M41())), ((((+(left.get()).get_M41() * +(right.get()).get_M12()) + (+(left.get()).get_M42() * +(right.get()).get_M22())) + (+(left.get()).get_M43() * +(right.get()).get_M32())) + (+(left.get()).get_M44() * +(right.get()).get_M42())), ((((+(left.get()).get_M41() * +(right.get()).get_M13()) + (+(left.get()).get_M42() * +(right.get()).get_M23())) + (+(left.get()).get_M43() * +(right.get()).get_M33())) + (+(left.get()).get_M44() * +(right.get()).get_M43())), ((((+(left.get()).get_M41() * +(right.get()).get_M14()) + (+(left.get()).get_M42() * +(right.get()).get_M24())) + (+(left.get()).get_M43() * +(right.get()).get_M34())) + (+(left.get()).get_M44() * +(right.get()).get_M44()))));
  }; 

  function double4x4_MultAffine (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct((((+(left.get()).get_M11() * +(right.get()).get_M11()) + (+(left.get()).get_M12() * +(right.get()).get_M21())) + (+(left.get()).get_M13() * +(right.get()).get_M31())), (((+(left.get()).get_M11() * +(right.get()).get_M12()) + (+(left.get()).get_M12() * +(right.get()).get_M22())) + (+(left.get()).get_M13() * +(right.get()).get_M32())), (((+(left.get()).get_M11() * +(right.get()).get_M13()) + (+(left.get()).get_M12() * +(right.get()).get_M23())) + (+(left.get()).get_M13() * +(right.get()).get_M33())), ((((+(left.get()).get_M11() * +(right.get()).get_M14()) + (+(left.get()).get_M12() * +(right.get()).get_M24())) + (+(left.get()).get_M13() * +(right.get()).get_M34())) + +(left.get()).get_M14()), (((+(left.get()).get_M21() * +(right.get()).get_M11()) + (+(left.get()).get_M22() * +(right.get()).get_M21())) + (+(left.get()).get_M23() * +(right.get()).get_M31())), (((+(left.get()).get_M21() * +(right.get()).get_M12()) + (+(left.get()).get_M22() * +(right.get()).get_M22())) + (+(left.get()).get_M23() * +(right.get()).get_M32())), (((+(left.get()).get_M21() * +(right.get()).get_M13()) + (+(left.get()).get_M22() * +(right.get()).get_M23())) + (+(left.get()).get_M23() * +(right.get()).get_M33())), ((((+(left.get()).get_M21() * +(right.get()).get_M14()) + (+(left.get()).get_M22() * +(right.get()).get_M24())) + (+(left.get()).get_M23() * +(right.get()).get_M34())) + +(left.get()).get_M24()), (((+(left.get()).get_M31() * +(right.get()).get_M11()) + (+(left.get()).get_M32() * +(right.get()).get_M21())) + (+(left.get()).get_M33() * +(right.get()).get_M31())), (((+(left.get()).get_M31() * +(right.get()).get_M12()) + (+(left.get()).get_M32() * +(right.get()).get_M22())) + (+(left.get()).get_M33() * +(right.get()).get_M32())), (((+(left.get()).get_M31() * +(right.get()).get_M13()) + (+(left.get()).get_M32() * +(right.get()).get_M23())) + (+(left.get()).get_M33() * +(right.get()).get_M33())), ((((+(left.get()).get_M31() * +(right.get()).get_M14()) + (+(left.get()).get_M32() * +(right.get()).get_M24())) + (+(left.get()).get_M33() * +(right.get()).get_M34())) + +(left.get()).get_M34()), 0, 0, 0, 1));
  }; 

  function double4x4_op_Addition (left, right) {
    return $thisType.Add(left, right);
  }; 

  function double4x4_op_Equality (left, right) {
    return left.Equals(right);
  }; 

  function double4x4_op_Inequality (left, right) {
    return !left.Equals(right);
  }; 

  function double4x4_op_Multiply$27 (left, right) {
    return $thisType.Mult(left.MemberwiseClone(), right.MemberwiseClone());
  }; 

  function double4x4_op_Multiply$28 (matrix, vector) {
    return $thisType.Transform(matrix, vector);
  }; 

  function double4x4_op_Multiply$29 (vector, matrix) {
    return $thisType.TransformPremult(vector, matrix);
  }; 

  function double4x4_op_Multiply$2A (matrix, vector) {
    return $thisType.TransformPD(matrix, vector);
  }; 

  function double4x4_op_Multiply$2B (vector, matrix) {
    return $thisType.TransformPremultPD(vector, matrix);
  }; 

  function double4x4_op_Subtraction (left, right) {
    return $thisType.Substract(left, right);
  }; 

  function double4x4_Scale$2C (scale) {
    return $thisType.Scale(scale, scale, scale);
  }; 

  function double4x4_Scale$2D (scale) {
    return $thisType.Scale(scale.x, scale.y, scale.z);
  }; 

  function double4x4_Scale$2E (x, y, z) {
    var result = new $thisType();
    result.Row0 = $S05().CallStatic($T00(), "op_Multiply", null, $T00().UnitX.MemberwiseClone(), x);
    result.Row1 = $S05().CallStatic($T00(), "op_Multiply", null, $T00().UnitY.MemberwiseClone(), y);
    result.Row2 = $S05().CallStatic($T00(), "op_Multiply", null, $T00().UnitZ.MemberwiseClone(), z);
    result.Row3 = $T00().UnitW.MemberwiseClone();
    return result;
  }; 

  function double4x4_set_M11 (value) {
    this.Row0.x = +value;
  }; 

  function double4x4_set_M12 (value) {
    this.Row0.y = +value;
  }; 

  function double4x4_set_M13 (value) {
    this.Row0.z = +value;
  }; 

  function double4x4_set_M14 (value) {
    this.Row0.w = +value;
  }; 

  function double4x4_set_M21 (value) {
    this.Row1.x = +value;
  }; 

  function double4x4_set_M22 (value) {
    this.Row1.y = +value;
  }; 

  function double4x4_set_M23 (value) {
    this.Row1.z = +value;
  }; 

  function double4x4_set_M24 (value) {
    this.Row1.w = +value;
  }; 

  function double4x4_set_M31 (value) {
    this.Row2.x = +value;
  }; 

  function double4x4_set_M32 (value) {
    this.Row2.y = +value;
  }; 

  function double4x4_set_M33 (value) {
    this.Row2.z = +value;
  }; 

  function double4x4_set_M34 (value) {
    this.Row2.w = +value;
  }; 

  function double4x4_set_M41 (value) {
    this.Row3.x = +value;
  }; 

  function double4x4_set_M42 (value) {
    this.Row3.y = +value;
  }; 

  function double4x4_set_M43 (value) {
    this.Row3.z = +value;
  }; 

  function double4x4_set_M44 (value) {
    this.Row3.w = +value;
  }; 

  function double4x4_set_Parse (value) {
    $thisType.double4x4$Parse$value = value;
  }; 

  function double4x4_Substract (left, right) {
    return $S02().Construct((+left.get_M11() - +right.get_M11()), (+left.get_M12() - +right.get_M12()), (+left.get_M13() - +right.get_M13()), (+left.get_M14() - +right.get_M14()), (+left.get_M21() - +right.get_M21()), (+left.get_M22() - +right.get_M22()), (+left.get_M23() - +right.get_M23()), (+left.get_M24() - +right.get_M24()), (+left.get_M31() - +right.get_M31()), (+left.get_M32() - +right.get_M32()), (+left.get_M33() - +right.get_M33()), (+left.get_M34() - +right.get_M34()), (+left.get_M41() - +right.get_M41()), (+left.get_M42() - +right.get_M42()), (+left.get_M43() - +right.get_M43()), (+left.get_M44() - +right.get_M44()));
  }; 

  function double4x4_ToArray () {
    return JSIL.Array.New($T01(), [this.get_M11(), this.get_M12(), this.get_M13(), this.get_M14(), this.get_M21(), this.get_M22(), this.get_M23(), this.get_M24(), this.get_M31(), this.get_M32(), this.get_M33(), this.get_M34(), this.get_M41(), this.get_M42(), this.get_M43(), this.get_M44()]);
  }; 

  function double4x4_toString () {
    return $T08().Format("{0}\n{1}\n{2}\n{3}", JSIL.Array.New($T06(), [this.Row0, this.Row1, this.Row2, this.Row3]));
  }; 

  function double4x4_Transform (matrix, vector) {
    return $S01().Construct(((((+matrix.get_M11() * +vector.x) + (+matrix.get_M12() * +vector.y)) + (+matrix.get_M13() * +vector.z)) + (+matrix.get_M14() * +vector.w)), ((((+matrix.get_M21() * +vector.x) + (+matrix.get_M22() * +vector.y)) + (+matrix.get_M23() * +vector.z)) + (+matrix.get_M24() * +vector.w)), ((((+matrix.get_M31() * +vector.x) + (+matrix.get_M32() * +vector.y)) + (+matrix.get_M33() * +vector.z)) + (+matrix.get_M34() * +vector.w)), ((((+matrix.get_M41() * +vector.x) + (+matrix.get_M42() * +vector.y)) + (+matrix.get_M43() * +vector.z)) + (+matrix.get_M44() * +vector.w)));
  }; 

  function double4x4_TransformPD (matrix, vector) {
    var w = (((+matrix.get_M41() * +vector.x) + (+matrix.get_M42() * +vector.y)) + (+matrix.get_M43() * +vector.z)) + +matrix.get_M44();
    return $S04().Construct(+((((((+matrix.get_M11() * +vector.x) + (+matrix.get_M12() * +vector.y)) + (+matrix.get_M13() * +vector.z)) + +matrix.get_M14()) / w)), +((((((+matrix.get_M21() * +vector.x) + (+matrix.get_M22() * +vector.y)) + (+matrix.get_M23() * +vector.z)) + +matrix.get_M24()) / w)), +((((((+matrix.get_M31() * +vector.x) + (+matrix.get_M32() * +vector.y)) + (+matrix.get_M33() * +vector.z)) + +matrix.get_M34()) / w)));
  }; 

  function double4x4_TransformPremult (vector, matrix) {
    return $S01().Construct(((((+matrix.get_M11() * +vector.x) + (+matrix.get_M21() * +vector.y)) + (+matrix.get_M31() * +vector.z)) + (+matrix.get_M41() * +vector.w)), ((((+matrix.get_M12() * +vector.x) + (+matrix.get_M22() * +vector.y)) + (+matrix.get_M32() * +vector.z)) + (+matrix.get_M42() * +vector.w)), ((((+matrix.get_M13() * +vector.x) + (+matrix.get_M23() * +vector.y)) + (+matrix.get_M33() * +vector.z)) + (+matrix.get_M43() * +vector.w)), ((((+matrix.get_M14() * +vector.x) + (+matrix.get_M24() * +vector.y)) + (+matrix.get_M34() * +vector.z)) + (+matrix.get_M44() * +vector.w)));
  }; 

  function double4x4_TransformPremultPD (vector, matrix) {
    var w = (((+matrix.get_M14() * +vector.x) + (+matrix.get_M24() * +vector.y)) + (+matrix.get_M34() * +vector.z)) + +matrix.get_M44();
    return $S04().Construct(+((((((+matrix.get_M11() * +vector.x) + (+matrix.get_M21() * +vector.y)) + (+matrix.get_M31() * +vector.z)) + +matrix.get_M41()) / w)), +((((((+matrix.get_M12() * +vector.x) + (+matrix.get_M22() * +vector.y)) + (+matrix.get_M32() * +vector.z)) + +matrix.get_M42()) / w)), +((((((+matrix.get_M13() * +vector.x) + (+matrix.get_M23() * +vector.y)) + (+matrix.get_M33() * +vector.z)) + +matrix.get_M43()) / w)));
  }; 

  function double4x4_Transpose$2F () {
    JSIL.CopyMembers($thisType.Transpose(this), this);
  }; 

  function double4x4_Transpose$30 (mat) {
    return $S00().Construct(mat.get_Column0().MemberwiseClone(), mat.get_Column1().MemberwiseClone(), mat.get_Column2().MemberwiseClone(), mat.get_Column3().MemberwiseClone());
  }; 

  function double4x4_Transpose$31 (/* ref */ mat, /* ref */ result) {
    result.get().Row0 = (mat.get()).get_Column0().MemberwiseClone();
    result.get().Row1 = (mat.get()).get_Column1().MemberwiseClone();
    result.get().Row2 = (mat.get()).get_Column2().MemberwiseClone();
    result.get().Row3 = (mat.get()).get_Column3().MemberwiseClone();
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.Core.double4x4", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 16, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm07.TypeRef("Fusee.Math.Core.double4"), $asm07.TypeRef("Fusee.Math.Core.double4"), 
          $asm07.TypeRef("Fusee.Math.Core.double4"), $asm07.TypeRef("Fusee.Math.Core.double4")
        ]), 
      double4x4__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double
        ]), 
      double4x4__ctor$01
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4x4_Add
    );

    $.Method({Static:true , Public:true }, "CreateFromAxisAngle", 
      new JSIL.MethodSignature(null, [
          $asm07.TypeRef("Fusee.Math.Core.double3"), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_CreateFromAxisAngle$02
    );

    $.Method({Static:true , Public:true }, "CreateFromAxisAngle", 
      new JSIL.MethodSignature($.Type, [$asm07.TypeRef("Fusee.Math.Core.double3"), $.Double]), 
      double4x4_CreateFromAxisAngle$03
    );

    $.Method({Static:true , Public:true }, "CreateOrthographic", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_CreateOrthographic$04
    );

    $.Method({Static:true , Public:true }, "CreateOrthographic", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double, $.Double
        ]), 
      double4x4_CreateOrthographic$05
    );

    $.Method({Static:true , Public:true }, "CreateOrthographicOffCenter", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_CreateOrthographicOffCenter$06
    );

    $.Method({Static:true , Public:true }, "CreateOrthographicOffCenter", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double
        ]), 
      double4x4_CreateOrthographicOffCenter$07
    );

    $.Method({Static:true , Public:true }, "CreateOrthographicOffCenterRH", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_CreateOrthographicOffCenterRH
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_CreatePerspectiveFieldOfView$08
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double, $.Double
        ]), 
      double4x4_CreatePerspectiveFieldOfView$09
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView_ROW", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_CreatePerspectiveFieldOfView_ROW$0A
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView_ROW", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double, $.Double
        ]), 
      double4x4_CreatePerspectiveFieldOfView_ROW$0B
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenter", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_CreatePerspectiveOffCenter$0C
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenter", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double
        ]), 
      double4x4_CreatePerspectiveOffCenter$0D
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenter_ROW", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_CreatePerspectiveOffCenter_ROW
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenterRH", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_CreatePerspectiveOffCenterRH
    );

    $.Method({Static:true , Public:true }, "CreateRotationX", 
      new JSIL.MethodSignature(null, [$.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double4x4_CreateRotationX$0E
    );

    $.Method({Static:true , Public:true }, "CreateRotationX", 
      new JSIL.MethodSignature($.Type, [$.Double]), 
      double4x4_CreateRotationX$0F
    );

    $.Method({Static:true , Public:true }, "CreateRotationX_ROW", 
      new JSIL.MethodSignature(null, [$.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double4x4_CreateRotationX_ROW$10
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationX_ROW", 
      new JSIL.MethodSignature($.Type, [$.Double]), 
      double4x4_CreateRotationX_ROW$11
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationY", 
      new JSIL.MethodSignature(null, [$.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double4x4_CreateRotationY$12
    );

    $.Method({Static:true , Public:true }, "CreateRotationY", 
      new JSIL.MethodSignature($.Type, [$.Double]), 
      double4x4_CreateRotationY$13
    );

    $.Method({Static:true , Public:true }, "CreateRotationY_ROW", 
      new JSIL.MethodSignature(null, [$.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double4x4_CreateRotationY_ROW$14
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationY_ROW", 
      new JSIL.MethodSignature($.Type, [$.Double]), 
      double4x4_CreateRotationY_ROW$15
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationZ", 
      new JSIL.MethodSignature(null, [$.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double4x4_CreateRotationZ$16
    );

    $.Method({Static:true , Public:true }, "CreateRotationZ", 
      new JSIL.MethodSignature($.Type, [$.Double]), 
      double4x4_CreateRotationZ$17
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_CreateTranslation$18
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double3")]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double4x4_CreateTranslation$19
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double
        ]), 
      double4x4_CreateTranslation$1A
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature($.Type, [$asm07.TypeRef("Fusee.Math.Core.double3")]), 
      double4x4_CreateTranslation$1B
    );

    $.Method({Static:true , Public:true }, "CreateTranslation_ROW", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_CreateTranslation_ROW$1C
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateTranslation_ROW", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double
        ]), 
      double4x4_CreateTranslation_ROW$1D
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      double4x4_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type]), 
      double4x4_Equals$1E
    );

    $.Method({Static:false, Public:true }, "get_Column0", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.double4")), 
      double4x4_get_Column0
    );

    $.Method({Static:false, Public:true }, "get_Column1", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.double4")), 
      double4x4_get_Column1
    );

    $.Method({Static:false, Public:true }, "get_Column2", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.double4")), 
      double4x4_get_Column2
    );

    $.Method({Static:false, Public:true }, "get_Column3", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.double4")), 
      double4x4_get_Column3
    );

    $.Method({Static:false, Public:true }, "get_Determinant", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_Determinant
    );

    $.Method({Static:false, Public:true }, "get_IsAffine", 
      JSIL.MethodSignature.Return($.Boolean), 
      double4x4_get_IsAffine
    );

    $.Method({Static:false, Public:true }, "get_M11", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M11
    );

    $.Method({Static:false, Public:true }, "get_M12", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M12
    );

    $.Method({Static:false, Public:true }, "get_M13", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M13
    );

    $.Method({Static:false, Public:true }, "get_M14", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M14
    );

    $.Method({Static:false, Public:true }, "get_M21", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M21
    );

    $.Method({Static:false, Public:true }, "get_M22", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M22
    );

    $.Method({Static:false, Public:true }, "get_M23", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M23
    );

    $.Method({Static:false, Public:true }, "get_M24", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M24
    );

    $.Method({Static:false, Public:true }, "get_M31", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M31
    );

    $.Method({Static:false, Public:true }, "get_M32", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M32
    );

    $.Method({Static:false, Public:true }, "get_M33", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M33
    );

    $.Method({Static:false, Public:true }, "get_M34", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M34
    );

    $.Method({Static:false, Public:true }, "get_M41", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M41
    );

    $.Method({Static:false, Public:true }, "get_M42", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M42
    );

    $.Method({Static:false, Public:true }, "get_M43", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M43
    );

    $.Method({Static:false, Public:true }, "get_M44", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M44
    );

    $.Method({Static:false, Public:true }, "get_Offset", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.double3")), 
      double4x4_get_Offset
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type])), 
      double4x4_get_Parse
    )
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      double4x4_GetHashCode
    );

    $.Method({Static:false, Public:true }, "Invert", 
      JSIL.MethodSignature.Void, 
      double4x4_Invert$1F
    );

    $.Method({Static:true , Public:true }, "Invert", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double4x4_Invert$20
    );

    $.Method({Static:true , Public:true }, "InvertAffine", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double4x4_InvertAffine
    );

    $.Method({Static:true , Public:true }, "LookAt", 
      new JSIL.MethodSignature($.Type, [
          $asm07.TypeRef("Fusee.Math.Core.double3"), $asm07.TypeRef("Fusee.Math.Core.double3"), 
          $asm07.TypeRef("Fusee.Math.Core.double3")
        ]), 
      double4x4_LookAt$21
    );

    $.Method({Static:true , Public:true }, "LookAt", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double
        ]), 
      double4x4_LookAt$22
    );

    $.Method({Static:true , Public:true }, "LookAt_ROW", 
      new JSIL.MethodSignature($.Type, [
          $asm07.TypeRef("Fusee.Math.Core.double3"), $asm07.TypeRef("Fusee.Math.Core.double3"), 
          $asm07.TypeRef("Fusee.Math.Core.double3")
        ]), 
      double4x4_LookAt_ROW$23
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "LookAt_ROW", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double
        ]), 
      double4x4_LookAt_ROW$24
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "LookAtRH", 
      new JSIL.MethodSignature($.Type, [
          $asm07.TypeRef("Fusee.Math.Core.double3"), $asm07.TypeRef("Fusee.Math.Core.double3"), 
          $asm07.TypeRef("Fusee.Math.Core.double3")
        ]), 
      double4x4_LookAtRH
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4x4_Mult$25
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_Mult$26
    );

    $.Method({Static:true , Public:true }, "MultAffine", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_MultAffine
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4x4_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      double4x4_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      double4x4_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4x4_op_Multiply$27
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.double4"), [$.Type, $asm07.TypeRef("Fusee.Math.Core.double4")]), 
      double4x4_op_Multiply$28
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.double4"), [$asm07.TypeRef("Fusee.Math.Core.double4"), $.Type]), 
      double4x4_op_Multiply$29
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.double3"), [$.Type, $asm07.TypeRef("Fusee.Math.Core.double3")]), 
      double4x4_op_Multiply$2A
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.double3"), [$asm07.TypeRef("Fusee.Math.Core.double3"), $.Type]), 
      double4x4_op_Multiply$2B
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4x4_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "Scale", 
      new JSIL.MethodSignature($.Type, [$.Double]), 
      double4x4_Scale$2C
    );

    $.Method({Static:true , Public:true }, "Scale", 
      new JSIL.MethodSignature($.Type, [$asm07.TypeRef("Fusee.Math.Core.double3")]), 
      double4x4_Scale$2D
    );

    $.Method({Static:true , Public:true }, "Scale", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double
        ]), 
      double4x4_Scale$2E
    );

    $.Method({Static:false, Public:true }, "set_M11", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M11
    );

    $.Method({Static:false, Public:true }, "set_M12", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M12
    );

    $.Method({Static:false, Public:true }, "set_M13", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M13
    );

    $.Method({Static:false, Public:true }, "set_M14", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M14
    );

    $.Method({Static:false, Public:true }, "set_M21", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M21
    );

    $.Method({Static:false, Public:true }, "set_M22", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M22
    );

    $.Method({Static:false, Public:true }, "set_M23", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M23
    );

    $.Method({Static:false, Public:true }, "set_M24", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M24
    );

    $.Method({Static:false, Public:true }, "set_M31", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M31
    );

    $.Method({Static:false, Public:true }, "set_M32", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M32
    );

    $.Method({Static:false, Public:true }, "set_M33", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M33
    );

    $.Method({Static:false, Public:true }, "set_M34", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M34
    );

    $.Method({Static:false, Public:true }, "set_M41", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M41
    );

    $.Method({Static:false, Public:true }, "set_M42", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M42
    );

    $.Method({Static:false, Public:true }, "set_M43", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M43
    );

    $.Method({Static:false, Public:true }, "set_M44", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M44
    );

    $.Method({Static:true , Public:true }, "set_Parse", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type])), 
      double4x4_set_Parse
    )
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:true , Public:true }, "Substract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4x4_Substract
    );

    $.Method({Static:false, Public:false}, "ToArray", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Double])), 
      double4x4_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      double4x4_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.double4"), [$.Type, $asm07.TypeRef("Fusee.Math.Core.double4")]), 
      double4x4_Transform
    );

    $.Method({Static:true , Public:true }, "TransformPD", 
      new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.double3"), [$.Type, $asm07.TypeRef("Fusee.Math.Core.double3")]), 
      double4x4_TransformPD
    );

    $.Method({Static:true , Public:true }, "TransformPremult", 
      new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.double4"), [$asm07.TypeRef("Fusee.Math.Core.double4"), $.Type]), 
      double4x4_TransformPremult
    );

    $.Method({Static:true , Public:true }, "TransformPremultPD", 
      new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.double3"), [$asm07.TypeRef("Fusee.Math.Core.double3"), $.Type]), 
      double4x4_TransformPremultPD
    );

    $.Method({Static:false, Public:true }, "Transpose", 
      JSIL.MethodSignature.Void, 
      double4x4_Transpose$2F
    );

    $.Method({Static:true , Public:true }, "Transpose", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double4x4_Transpose$30
    );

    $.Method({Static:true , Public:true }, "Transpose", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double4x4_Transpose$31
    );

    $.Field({Static:false, Public:true }, "Row0", $asm07.TypeRef("Fusee.Math.Core.double4"))
      .Attribute($asm0F.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [1]; });

    $.Field({Static:false, Public:true }, "Row1", $asm07.TypeRef("Fusee.Math.Core.double4"))
      .Attribute($asm0F.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [2]; });

    $.Field({Static:false, Public:true }, "Row2", $asm07.TypeRef("Fusee.Math.Core.double4"))
      .Attribute($asm0F.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [3]; });

    $.Field({Static:false, Public:true }, "Row3", $asm07.TypeRef("Fusee.Math.Core.double4"))
      .Attribute($asm0F.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [4]; });

    $.Field({Static:true , Public:true }, "Identity", $.Type);

    $.Field({Static:true , Public:true }, "Zero", $.Type);

    $.Field({Static:true , Public:false}, "double4x4$Parse$value", $asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type]))
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"))
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerBrowsableAttribute"), function () { return [$asm15.System.Diagnostics.DebuggerBrowsableState.Never]; });


    function double4x4__cctor () {
      $thisType.Identity = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.Identity = $S00().Construct($T00().UnitX.MemberwiseClone(), $T00().UnitY.MemberwiseClone(), $T00().UnitZ.MemberwiseClone(), $T00().UnitW.MemberwiseClone());
      $thisType.Zero = $S00().Construct($T00().Zero.MemberwiseClone(), $T00().Zero.MemberwiseClone(), $T00().Zero.MemberwiseClone(), $T00().Zero.MemberwiseClone());
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      double4x4__cctor
    );

    $.Property({Static:false, Public:true }, "Determinant", $.Double);

    $.Property({Static:false, Public:true }, "Column0", $asm07.TypeRef("Fusee.Math.Core.double4"));

    $.Property({Static:false, Public:true }, "Column1", $asm07.TypeRef("Fusee.Math.Core.double4"));

    $.Property({Static:false, Public:true }, "Column2", $asm07.TypeRef("Fusee.Math.Core.double4"));

    $.Property({Static:false, Public:true }, "Column3", $asm07.TypeRef("Fusee.Math.Core.double4"));

    $.Property({Static:false, Public:true }, "M11", $.Double);

    $.Property({Static:false, Public:true }, "M12", $.Double);

    $.Property({Static:false, Public:true }, "M13", $.Double);

    $.Property({Static:false, Public:true }, "M14", $.Double);

    $.Property({Static:false, Public:true }, "M21", $.Double);

    $.Property({Static:false, Public:true }, "M22", $.Double);

    $.Property({Static:false, Public:true }, "M23", $.Double);

    $.Property({Static:false, Public:true }, "M24", $.Double);

    $.Property({Static:false, Public:true }, "M31", $.Double);

    $.Property({Static:false, Public:true }, "M32", $.Double);

    $.Property({Static:false, Public:true }, "M33", $.Double);

    $.Property({Static:false, Public:true }, "M34", $.Double);

    $.Property({Static:false, Public:true }, "M41", $.Double);

    $.Property({Static:false, Public:true }, "M42", $.Double);

    $.Property({Static:false, Public:true }, "M43", $.Double);

    $.Property({Static:false, Public:true }, "M44", $.Double);

    $.Property({Static:false, Public:true }, "Offset", $asm07.TypeRef("Fusee.Math.Core.double3"));

    $.Property({Static:false, Public:true }, "IsAffine", $.Boolean);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type]));

    $.ImplementInterfaces(
      /* 0 */ $asm15.TypeRef("System.IEquatable`1", [$.Type])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("ProtoBuf.ProtoContractAttribute"));

})();

/* struct Fusee.Math.Core.float2 */ 

(function float2$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm15.System.Single)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm07.Fusee.Math.Core.float3)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm07.Fusee.Math.Core.float4)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm15.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm15.System.Boolean)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm15.System.Math)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm15.System.Double)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm07.Fusee.Math.Core.M)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm07.Fusee.Math.Core.Converter$b2.Of($asm15.System.String, $asm07.Fusee.Math.Core.float2))) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm15.System.String)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm07.Fusee.Math.Core.Quaternion)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.float2"), [$asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float2"), [$asm15.TypeRef("System.Single"), $asm07.TypeRef("Fusee.Math.Core.float2")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float2")]), $asm15.TypeRef("System.Single"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float2")])
      ]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float2")]), $asm15.TypeRef("System.Single"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float2")])
      ]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float2")]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float2")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float2")])
      ]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm15.TypeRef("System.Single"), [$asm15.TypeRef("System.Single")]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float2")]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float2")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float2")])
      ]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.Quaternion")]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.Quaternion")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.Quaternion")])
      ]))) ();
  };


  function float2__ctor$00 (x, y) {
    this.x = +x;
    this.y = +y;
  }; 

  function float2__ctor$01 (v) {
    this.x = +v.x;
    this.y = +v.y;
  }; 

  function float2__ctor$02 (v) {
    this.x = +v.x;
    this.y = +v.y;
  }; 

  function float2__ctor$03 (v) {
    this.x = +v.x;
    this.y = +v.y;
  }; 

  function float2_Add$04 (right) {
    this.x = +this.x + +right.x;
    this.y = +this.y + +right.y;
  }; 

  function float2_Add$05 (/* ref */ right) {
    this.x = +this.x + +right.get().x;
    this.y = +this.y + +right.get().y;
  }; 

  function float2_Add$06 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Add(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  }; 

  function float2_Add$07 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x + +b.get().x), (+a.get().y + +b.get().y)));
  }; 

  function float2_Barycentric (a, b, c, u, v) {
    return $thisType.op_Addition(
      $thisType.op_Addition(
        $S01().CallStatic($thisType, "op_Multiply", null, u, a.MemberwiseClone()).MemberwiseClone(), 
        $S01().CallStatic($thisType, "op_Multiply", null, v, b.MemberwiseClone())
      ).MemberwiseClone(), 
      $S01().CallStatic($thisType, "op_Multiply", null, (1 - +u) - +v, c.MemberwiseClone())
    );
  }; 

  function float2_Clamp$08 (vec, min, max) {
    vec.x = +(
      (+vec.x < +min.x)
         ? min.x
         : (
          (+vec.x > +max.x)
             ? max.x
             : vec.x)
    )
    ;
    vec.y = +(
      (+vec.y < +min.y)
         ? min.y
         : (
          (+vec.y > +max.y)
             ? max.y
             : vec.y)
    )
    ;
    return vec;
  }; 

  function float2_Clamp$09 (/* ref */ vec, /* ref */ min, /* ref */ max, /* ref */ result) {
    result.get().x = +(
      (+vec.get().x < +min.get().x)
         ? min.get().x
         : (
          (+vec.get().x > +max.get().x)
             ? max.get().x
             : vec.get().x)
    )
    ;
    result.get().y = +(
      (+vec.get().y < +min.get().y)
         ? min.get().y
         : (
          (+vec.get().y > +max.get().y)
             ? max.get().y
             : vec.get().y)
    )
    ;
  }; 

  function float2_ComponentMax$0A (a, b) {
    a.x = +(
      (+a.x > +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y > +b.y)
         ? a.y
         : b.y)
    ;
    return a;
  }; 

  function float2_ComponentMax$0B (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x > +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y > +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
  }; 

  function float2_ComponentMin$0C (a, b) {
    a.x = +(
      (+a.x < +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y < +b.y)
         ? a.y
         : b.y)
    ;
    return a;
  }; 

  function float2_ComponentMin$0D (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x < +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y < +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
  }; 

  function float2_Div$0E (f) {
    var mult = +((1 / +f));
    this.x = +this.x * mult;
    this.y = +this.y * mult;
  }; 

  function float2_Div$0F (a, f) {
    var mult = +((1 / +f));
    a.x = +a.x * mult;
    a.y = +a.y * mult;
    return a;
  }; 

  function float2_Div$10 (/* ref */ a, f, /* ref */ result) {
    var mult = +((1 / +f));
    result.get().x = +a.get().x * mult;
    result.get().y = +a.get().y * mult;
  }; 

  function float2_Divide$11 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S02().CallStatic($thisType, "Divide", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  }; 

  function float2_Divide$12 (/* ref */ vector, scale, /* ref */ result) {
    $S03().CallStatic($thisType, "Multiply", null, /* ref */ vector, +((1 / +scale)), /* ref */ result);
  }; 

  function float2_Divide$13 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S04().CallStatic($thisType, "Divide", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  }; 

  function float2_Divide$14 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct(+((+vector.get().x / +scale.get().x)), +((+vector.get().y / +scale.get().y))));
  }; 

  function float2_Dot$15 (left, right) {
    return ((+left.x * +right.x) + (+left.y * +right.y));
  }; 

  function float2_Dot$16 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set((+left.get().x * +right.get().x) + (+left.get().y * +right.get().y));
  }; 

  function float2_Object_Equals (obj) {
    var flag = !$thisType.$Is(obj);
    return (!flag && this.Equals($thisType.$Cast(obj)));
  }; 

  function float2_Equals$17 (other) {
    return ((+this.x === +other.x) && (+this.y === +other.y));
  }; 

  function float2_get_g () {
    return this.y;
  }; 

  function float2_get_Length () {
    return Math.fround(Math.sqrt((+this.x * +this.x) + (+this.y * +this.y)));
  }; 

  function float2_get_LengthFast () {
    return +((1 / +$S05().CallStatic($T07(), "InverseSqrtFast", null, (+this.x * +this.x) + (+this.y * +this.y))));
  }; 

  function float2_get_LengthSquared () {
    return ((+this.x * +this.x) + (+this.y * +this.y));
  }; 

  function float2_get_Parse () {
    return $thisType.float2$Parse$value;
  }; 

  function float2_get_PerpendicularLeft () {
    return $S00().Construct(-this.y, this.x);
  }; 

  function float2_get_PerpendicularRight () {
    return $S00().Construct(this.y, -this.x);
  }; 

  function float2_get_r () {
    return this.x;
  }; 

  function float2_get_rg () {
    return this.get_xy();
  }; 

  function float2_get_xy () {
    return $S00().Construct(this.x, this.y);
  }; 

  function float2_GetBarycentric (a, b, c, point, /* ref */ u, /* ref */ v) {
    var cb = $thisType.op_Subtraction(b.MemberwiseClone(), c);
    var cp = $thisType.op_Subtraction(point.MemberwiseClone(), c);
    var ca = $thisType.op_Subtraction(a.MemberwiseClone(), c);
    var denom = (+cb.y * +ca.x) - (+cb.x * +ca.y);
    u.set(+((((+cb.y * +cp.x) - (+cb.x * +cp.y)) / denom)));
    v.set(+((((+ca.x * +cp.y) - (+ca.y * +cp.x)) / denom)));
  }; 

  function float2_GetHashCode () {
    return (((this.x).GetHashCode() | 0) ^ ((this.y).GetHashCode() | 0));
  }; 

  function float2_IsTriangleCW (a, b, c) {
    var cb = $thisType.op_Subtraction(b.MemberwiseClone(), c);
    var ca = $thisType.op_Subtraction(a.MemberwiseClone(), c);
    var z = (+ca.x * +cb.y) - (+ca.y * +cb.x);
    return (z < 0);
  }; 

  function float2_Lerp$18 (a, b, blend) {
    a.x = (+blend * (+b.x - +a.x)) + +a.x;
    a.y = (+blend * (+b.y - +a.y)) + +a.y;
    return a;
  }; 

  function float2_Lerp$19 (/* ref */ a, /* ref */ b, blend, /* ref */ result) {
    result.get().x = (+blend * (+b.get().x - +a.get().x)) + +a.get().x;
    result.get().y = (+blend * (+b.get().y - +a.get().y)) + +a.get().y;
  }; 

  function float2_Max (left, right) {
    return (
      (+left.get_LengthSquared() >= +right.get_LengthSquared())
         ? left
         : right)
    ;
  }; 

  function float2_Min (left, right) {
    return (
      (+left.get_LengthSquared() < +right.get_LengthSquared())
         ? left
         : right)
    ;
  }; 

  function float2_Mult$1A (f) {
    this.x = +this.x * +f;
    this.y = +this.y * +f;
  }; 

  function float2_Mult$1B (a, f) {
    a.x = +a.x * +f;
    a.y = +a.y * +f;
    return a;
  }; 

  function float2_Mult$1C (/* ref */ a, f, /* ref */ result) {
    result.get().x = +a.get().x * +f;
    result.get().y = +a.get().y * +f;
  }; 

  function float2_Multiply$1D ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S03().CallStatic($thisType, "Multiply", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  }; 

  function float2_Multiply$1E (/* ref */ vector, scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale), (+vector.get().y * +scale)));
  }; 

  function float2_Multiply$1F ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S06().CallStatic($thisType, "Multiply", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  }; 

  function float2_Multiply$20 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale.get().x), (+vector.get().y * +scale.get().y)));
  }; 

  function float2_Normalize$21 () {
    var scale = +((1 / +this.get_Length()));
    this.x = +this.x * scale;
    this.y = +this.y * scale;
  }; 

  function float2_Normalize$22 (vec) {
    var scale = +((1 / +vec.get_Length()));
    vec.x = +vec.x * scale;
    vec.y = +vec.y * scale;
    return vec;
  }; 

  function float2_Normalize$23 (/* ref */ vec, /* ref */ result) {
    var scale = +((1 / +(vec.get()).get_Length()));
    result.get().x = +vec.get().x * scale;
    result.get().y = +vec.get().y * scale;
  }; 

  function float2_NormalizeFast$24 () {
    var scale = +$S05().CallStatic($T07(), "InverseSqrtFast", null, (+this.x * +this.x) + (+this.y * +this.y));
    this.x = +this.x * scale;
    this.y = +this.y * scale;
  }; 

  function float2_NormalizeFast$25 (vec) {
    var scale = +$S05().CallStatic($T07(), "InverseSqrtFast", null, (+vec.x * +vec.x) + (+vec.y * +vec.y));
    vec.x = +vec.x * scale;
    vec.y = +vec.y * scale;
    return vec;
  }; 

  function float2_NormalizeFast$26 (/* ref */ vec, /* ref */ result) {
    var scale = +$S05().CallStatic($T07(), "InverseSqrtFast", null, (+vec.get().x * +vec.get().x) + (+vec.get().y * +vec.get().y));
    result.get().x = +vec.get().x * scale;
    result.get().y = +vec.get().y * scale;
  }; 

  function float2_op_Addition (left, right) {
    left.x = +left.x + +right.x;
    left.y = +left.y + +right.y;
    return left;
  }; 

  function float2_op_Division (vec, scale) {
    var mult = +((1 / +scale));
    vec.x = +vec.x * mult;
    vec.y = +vec.y * mult;
    return vec;
  }; 

  function float2_op_Equality (left, right) {
    return left.Equals(right);
  }; 

  function float2_op_Inequality (left, right) {
    return !left.Equals(right);
  }; 

  function float2_op_Multiply$27 (vec, scale) {
    vec.x = +vec.x * +scale;
    vec.y = +vec.y * +scale;
    return vec;
  }; 

  function float2_op_Multiply$28 (scale, vec) {
    vec.x = +vec.x * +scale;
    vec.y = +vec.y * +scale;
    return vec;
  }; 

  function float2_op_Multiply$29 (vec1, vec2) {
    vec1.x = +vec1.x * +vec2.x;
    vec1.y = +vec1.y * +vec2.y;
    return vec1;
  }; 

  function float2_op_Subtraction (left, right) {
    left.x = +left.x - +right.x;
    left.y = +left.y - +right.y;
    return left;
  }; 

  function float2_op_UnaryNegation (vec) {
    vec.x = -vec.x;
    vec.y = -vec.y;
    return vec;
  }; 

  function float2_PointInTriangle (a, b, c, point, /* ref */ u, /* ref */ v) {
    $thisType.GetBarycentric(
      a.MemberwiseClone(), 
      b.MemberwiseClone(), 
      c, 
      point.MemberwiseClone(), 
      /* ref */ u, 
      /* ref */ v
    );
    return (!((+u.get() < 0) || 
        (+v.get() < 0)) && ((+u.get() + +v.get()) < 1));
  }; 

  function float2_Scale$2A (sx, sy) {
    this.x = +this.x * +sx;
    this.y = +this.y * +sy;
  }; 

  function float2_Scale$2B (scale) {
    this.x = +this.x * +scale.x;
    this.y = +this.y * +scale.y;
  }; 

  function float2_Scale$2C (/* ref */ scale) {
    this.x = +this.x * +scale.get().x;
    this.y = +this.y * +scale.get().y;
  }; 

  function float2_set_g (value) {
    this.y = +value;
  }; 

  function float2_set_Parse (value) {
    $thisType.float2$Parse$value = value;
  }; 

  function float2_set_r (value) {
    this.x = +value;
  }; 

  function float2_set_rg (value) {
    (this.xy = value.MemberwiseClone());
  }; 

  function float2_set_xy (value) {
    this.x = +value.x;
    this.y = +value.y;
  }; 

  function float2_Sub$2D (right) {
    this.x = +this.x - +right.x;
    this.y = +this.y - +right.y;
  }; 

  function float2_Sub$2E (/* ref */ right) {
    this.x = +this.x - +right.get().x;
    this.y = +this.y - +right.get().y;
  }; 

  function float2_Sub$2F (a, b) {
    a.x = +a.x - +b.x;
    a.y = +a.y - +b.y;
    return a;
  }; 

  function float2_Sub$30 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +a.get().x - +b.get().x;
    result.get().y = +a.get().y - +b.get().y;
  }; 

  function float2_Subtract$31 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Subtract(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  }; 

  function float2_Subtract$32 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x - +b.get().x), (+a.get().y - +b.get().y)));
  }; 

  function float2_ToArray () {
    return JSIL.Array.New($T00(), [this.x, this.y]);
  }; 

  function float2_toString () {
    return $T09().Format("({0}, {1})", JSIL.Array.New($T03(), [$T00().$Box(this.x), $T00().$Box(this.y)]));
  }; 

  function float2_Transform$33 ($vec, $quat) {
    var quat = new JSIL.BoxedVariable($quat.MemberwiseClone());
    var vec = new JSIL.BoxedVariable($vec.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Transform(/* ref */ vec, /* ref */ quat, /* ref */ result);
    return result.get();
  }; 

  function float2_Transform$34 (/* ref */ vec, /* ref */ quat, /* ref */ result) {
    var i = new JSIL.BoxedVariable(new ($T0A())());
    var v = new JSIL.BoxedVariable(new ($T0A())());
    var t = new JSIL.BoxedVariable(new ($T0A())());
    $T0A().prototype._ctor.call(v.get().MemberwiseClone(), vec.get().x, vec.get().y, 0, 0);
    $T0A().Invert(/* ref */ quat, /* ref */ i);
    $S07().CallStatic($T0A(), "Multiply", null, /* ref */ quat, /* ref */ v, /* ref */ t);
    $S07().CallStatic($T0A(), "Multiply", null, /* ref */ t, /* ref */ i, /* ref */ v);
    result.set($S00().Construct((v.get()).get_x(), (v.get()).get_y()));
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.Core.float2", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 2, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Single, $.Single]), 
      float2__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Type), 
      float2__ctor$01
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"));

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.float3")), 
      float2__ctor$02
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"));

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.float4")), 
      float2__ctor$03
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"));

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($.Type), 
      float2_Add$04
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      float2_Add$05
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_Add$06
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Add$07
    );

    $.Method({Static:true , Public:true }, "Barycentric", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type, $.Single, 
          $.Single
        ]), 
      float2_Barycentric
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type
        ]), 
      float2_Clamp$08
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Clamp$09
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_ComponentMax$0A
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_ComponentMax$0B
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_ComponentMin$0C
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_ComponentMin$0D
    );

    $.Method({Static:false, Public:true }, "Div", 
      JSIL.MethodSignature.Action($.Single), 
      float2_Div$0E
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float2_Div$0F
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Div$10
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float2_Divide$11
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Divide$12
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_Divide$13
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Divide$14
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature($.Single, [$.Type, $.Type]), 
      float2_Dot$15
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Single])
        ]), 
      float2_Dot$16
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      float2_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type]), 
      float2_Equals$17
    );

    $.Method({Static:false, Public:true }, "get_g", 
      JSIL.MethodSignature.Return($.Single), 
      float2_get_g
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      JSIL.MethodSignature.Return($.Single), 
      float2_get_Length
    );

    $.Method({Static:false, Public:true }, "get_LengthFast", 
      JSIL.MethodSignature.Return($.Single), 
      float2_get_LengthFast
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      JSIL.MethodSignature.Return($.Single), 
      float2_get_LengthSquared
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type])), 
      float2_get_Parse
    )
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_PerpendicularLeft", 
      JSIL.MethodSignature.Return($.Type), 
      float2_get_PerpendicularLeft
    );

    $.Method({Static:false, Public:true }, "get_PerpendicularRight", 
      JSIL.MethodSignature.Return($.Type), 
      float2_get_PerpendicularRight
    );

    $.Method({Static:false, Public:true }, "get_r", 
      JSIL.MethodSignature.Return($.Single), 
      float2_get_r
    );

    $.Method({Static:false, Public:true }, "get_rg", 
      JSIL.MethodSignature.Return($.Type), 
      float2_get_rg
    );

    $.Method({Static:false, Public:true }, "get_xy", 
      JSIL.MethodSignature.Return($.Type), 
      float2_get_xy
    );

    $.Method({Static:true , Public:true }, "GetBarycentric", 
      new JSIL.MethodSignature(null, [
          $.Type, $.Type, 
          $.Type, $.Type, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Single]), $jsilcore.TypeRef("JSIL.Reference", [$.Single])
        ]), 
      float2_GetBarycentric
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      float2_GetHashCode
    );

    $.Method({Static:true , Public:true }, "IsTriangleCW", 
      new JSIL.MethodSignature($.Boolean, [
          $.Type, $.Type, 
          $.Type
        ]), 
      float2_IsTriangleCW
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Single
        ]), 
      float2_Lerp$18
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Lerp$19
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_Max
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_Min
    );

    $.Method({Static:false, Public:true }, "Mult", 
      JSIL.MethodSignature.Action($.Single), 
      float2_Mult$1A
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float2_Mult$1B
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Mult$1C
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float2_Multiply$1D
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Multiply$1E
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_Multiply$1F
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Multiply$20
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      JSIL.MethodSignature.Void, 
      float2_Normalize$21
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float2_Normalize$22
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float2_Normalize$23
    );

    $.Method({Static:false, Public:true }, "NormalizeFast", 
      JSIL.MethodSignature.Void, 
      float2_NormalizeFast$24
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float2_NormalizeFast$25
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float2_NormalizeFast$26
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Division", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float2_op_Division
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      float2_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      float2_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float2_op_Multiply$27
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Single, $.Type]), 
      float2_op_Multiply$28
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_op_Multiply$29
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "op_UnaryNegation", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float2_op_UnaryNegation
    );

    $.Method({Static:true , Public:true }, "PointInTriangle", 
      new JSIL.MethodSignature($.Boolean, [
          $.Type, $.Type, 
          $.Type, $.Type, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Single]), $jsilcore.TypeRef("JSIL.Reference", [$.Single])
        ]), 
      float2_PointInTriangle
    );

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [$.Single, $.Single]), 
      float2_Scale$2A
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($.Type), 
      float2_Scale$2B
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      float2_Scale$2C
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "set_g", 
      JSIL.MethodSignature.Action($.Single), 
      float2_set_g
    );

    $.Method({Static:true , Public:true }, "set_Parse", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type])), 
      float2_set_Parse
    )
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "set_r", 
      JSIL.MethodSignature.Action($.Single), 
      float2_set_r
    );

    $.Method({Static:false, Public:true }, "set_rg", 
      JSIL.MethodSignature.Action($.Type), 
      float2_set_rg
    );

    $.Method({Static:false, Public:true }, "set_xy", 
      JSIL.MethodSignature.Action($.Type), 
      float2_set_xy
    );

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($.Type), 
      float2_Sub$2D
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      float2_Sub$2E
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_Sub$2F
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Sub$30
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_Subtract$31
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Subtract$32
    );

    $.Method({Static:false, Public:true }, "ToArray", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Single])), 
      float2_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      float2_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm07.TypeRef("Fusee.Math.Core.Quaternion")]), 
      float2_Transform$33
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.Quaternion")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Transform$34
    );

    $.Field({Static:false, Public:true }, "x", $.Single)
      .Attribute($asm0F.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [1]; });

    $.Field({Static:false, Public:true }, "y", $.Single)
      .Attribute($asm0F.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [2]; });

    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitX", $.Type);

    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitY", $.Type);

    $.Field({Static:true , Public:true , ReadOnly:true }, "Zero", $.Type);

    $.Field({Static:true , Public:true , ReadOnly:true }, "One", $.Type);

    $.Field({Static:true , Public:false}, "float2$Parse$value", $asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type]))
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"))
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerBrowsableAttribute"), function () { return [$asm15.System.Diagnostics.DebuggerBrowsableState.Never]; });


    function float2__cctor () {
      $thisType.UnitX = new $thisType();
      $thisType.UnitY = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.One = new $thisType();
      $thisType.UnitX = $S00().Construct(1, 0);
      $thisType.UnitY = $S00().Construct(0, 1);
      $thisType.Zero = $S00().Construct(0, 0);
      $thisType.One = $S00().Construct(1, 1);
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      float2__cctor
    );

    $.Property({Static:false, Public:true }, "Length", $.Single);

    $.Property({Static:false, Public:true }, "LengthFast", $.Single);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Single);

    $.Property({Static:false, Public:true }, "PerpendicularRight", $.Type);

    $.Property({Static:false, Public:true }, "PerpendicularLeft", $.Type);

    $.Property({Static:false, Public:true }, "xy", $.Type);

    $.Property({Static:false, Public:true }, "r", $.Single);

    $.Property({Static:false, Public:true }, "g", $.Single);

    $.Property({Static:false, Public:true }, "rg", $.Type);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type]));

    $.ImplementInterfaces(
      /* 0 */ $asm15.TypeRef("System.IEquatable`1", [$.Type])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("ProtoBuf.ProtoContractAttribute"));

})();

/* struct Fusee.Math.Core.float3 */ 

(function float3$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm15.System.Single)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm07.Fusee.Math.Core.float2)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm07.Fusee.Math.Core.float4)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.Fusee.Math.Core.double3)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm15.System.Boolean)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm15.System.Math)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm15.System.Double)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm15.System.Object)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm07.Fusee.Math.Core.M)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize(System.Array.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm07.Fusee.Math.Core.Converter$b2.Of($asm15.System.String, $asm07.Fusee.Math.Core.float3))) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm15.System.String)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm07.Fusee.Math.Core.float4x4)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm07.Fusee.Math.Core.Quaternion)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [$asm15.TypeRef("System.Single"), $asm07.TypeRef("Fusee.Math.Core.float3")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float3")]), $asm15.TypeRef("System.Single"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float3")])
      ]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float3")]), $asm15.TypeRef("System.Single"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float3")])
      ]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float3")]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float3")])
      ]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm15.TypeRef("System.Single"), [$asm15.TypeRef("System.Single")]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.float2"), [$asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single")]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float3")]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float3")])
      ]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [$asm07.TypeRef("Fusee.Math.Core.double3")]))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [$asm07.TypeRef("Fusee.Math.Core.float3"), $asm15.TypeRef("System.Single")]))) ();
  };
  var $S0A = function () {
    return ($S0A = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.float4"), [
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single")
      ]))) ();
  };
  var $S0B = function () {
    return ($S0B = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float4"), [$asm07.TypeRef("Fusee.Math.Core.float4x4"), $asm07.TypeRef("Fusee.Math.Core.float4")]))) ();
  };
  var $S0C = function () {
    return ($S0C = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [$asm07.TypeRef("Fusee.Math.Core.float4")]))) ();
  };
  var $S0D = function () {
    return ($S0D = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.float4"), [$asm07.TypeRef("Fusee.Math.Core.float3"), $asm15.TypeRef("System.Single")]))) ();
  };


  function float3__ctor$00 (x, y, z) {
    this.x = +x;
    this.y = +y;
    this.z = +z;
  }; 

  function float3__ctor$01 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = 0;
  }; 

  function float3__ctor$02 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
  }; 

  function float3__ctor$03 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
  }; 

  function float3__ctor$04 (d3) {
    this.x = Math.fround(d3.x);
    this.y = Math.fround(d3.y);
    this.z = Math.fround(d3.z);
  }; 

  function float3_Add$05 (right) {
    this.x = +this.x + +right.x;
    this.y = +this.y + +right.y;
    this.z = +this.z + +right.z;
  }; 

  function float3_Add$06 (/* ref */ right) {
    this.x = +this.x + +right.get().x;
    this.y = +this.y + +right.get().y;
    this.z = +this.z + +right.get().z;
  }; 

  function float3_Add$07 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Add(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  }; 

  function float3_Add$08 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x + +b.get().x), (+a.get().y + +b.get().y), (+a.get().z + +b.get().z)));
  }; 

  function float3_Barycentric (a, b, c, u, v) {
    return $thisType.op_Addition(
      $thisType.op_Addition(
        $S01().CallStatic($thisType, "op_Multiply", null, u, a.MemberwiseClone()).MemberwiseClone(), 
        $S01().CallStatic($thisType, "op_Multiply", null, v, b.MemberwiseClone())
      ).MemberwiseClone(), 
      $S01().CallStatic($thisType, "op_Multiply", null, (1 - +u) - +v, c.MemberwiseClone())
    );
  }; 

  function float3_CalculateAngle$09 (first, second) {
    var flag = (+first.get_Length() > 1.192093E-07) && 
    (+second.get_Length() > 1.192093E-07);
    if (flag) {
      var dotP = +((+$thisType.Dot(first, second) / (+first.get_Length() * +second.get_Length())));
      var flag2 = dotP < -1;
      if (flag2) {
        dotP = -1;
      }
      var flag3 = dotP > 1;
      if (flag3) {
        dotP = 1;
      }
      var result = Math.fround(Math.acos(dotP));
    } else {
      result = 0;
    }
    return result;
  }; 

  function float3_CalculateAngle$0A (/* ref */ first, /* ref */ second, /* ref */ result) {
    var temp = new JSIL.BoxedVariable(0);
    $thisType.Dot(/* ref */ first, /* ref */ second, /* ref */ temp);
    var flag = (+(first.get()).get_Length() > 1.192093E-07) && 
    (+(second.get()).get_Length() > 1.192093E-07);
    if (flag) {
      result.set(Math.fround(Math.acos(+(+temp.get() / (+(first.get()).get_Length() * +(second.get()).get_Length())))));
    } else {
      result.set(0);
    }
  }; 

  function float3_Clamp$0B (vec, min, max) {
    vec.x = +(
      (+vec.x < +min.x)
         ? min.x
         : (
          (+vec.x > +max.x)
             ? max.x
             : vec.x)
    )
    ;
    vec.y = +(
      (+vec.y < +min.y)
         ? min.y
         : (
          (+vec.y > +max.y)
             ? max.y
             : vec.y)
    )
    ;
    vec.z = +(
      (+vec.z < +min.z)
         ? min.z
         : (
          (+vec.z > +max.z)
             ? max.z
             : vec.z)
    )
    ;
    return vec;
  }; 

  function float3_Clamp$0C (/* ref */ vec, /* ref */ min, /* ref */ max, /* ref */ result) {
    result.get().x = +(
      (+vec.get().x < +min.get().x)
         ? min.get().x
         : (
          (+vec.get().x > +max.get().x)
             ? max.get().x
             : vec.get().x)
    )
    ;
    result.get().y = +(
      (+vec.get().y < +min.get().y)
         ? min.get().y
         : (
          (+vec.get().y > +max.get().y)
             ? max.get().y
             : vec.get().y)
    )
    ;
    result.get().z = +(
      (+vec.get().z < +min.get().z)
         ? min.get().z
         : (
          (+vec.get().z > +max.get().z)
             ? max.get().z
             : vec.get().z)
    )
    ;
  }; 

  function float3_ComponentMax$0D (a, b) {
    a.x = +(
      (+a.x > +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y > +b.y)
         ? a.y
         : b.y)
    ;
    a.z = +(
      (+a.z > +b.z)
         ? a.z
         : b.z)
    ;
    return a;
  }; 

  function float3_ComponentMax$0E (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x > +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y > +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
    result.get().z = +(
      (+a.get().z > +b.get().z)
         ? a.get().z
         : b.get().z)
    ;
  }; 

  function float3_ComponentMin$0F (a, b) {
    a.x = +(
      (+a.x < +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y < +b.y)
         ? a.y
         : b.y)
    ;
    a.z = +(
      (+a.z < +b.z)
         ? a.z
         : b.z)
    ;
    return a;
  }; 

  function float3_ComponentMin$10 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x < +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y < +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
    result.get().z = +(
      (+a.get().z < +b.get().z)
         ? a.get().z
         : b.get().z)
    ;
  }; 

  function float3_Cross$11 ($left, $right) {
    var right = new JSIL.BoxedVariable($right);
    var left = new JSIL.BoxedVariable($left);
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Cross(/* ref */ left, /* ref */ right, /* ref */ result);
    return result.get();
  }; 

  function float3_Cross$12 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S00().Construct(((+left.get().y * +right.get().z) - (+left.get().z * +right.get().y)), ((+left.get().z * +right.get().x) - (+left.get().x * +right.get().z)), ((+left.get().x * +right.get().y) - (+left.get().y * +right.get().x))));
  }; 

  function float3_Div$13 (f) {
    var flag = +f <= 1.192093E-07;
    if (!flag) {
      var mult = +((1 / +f));
      this.x = +this.x * mult;
      this.y = +this.y * mult;
      this.z = +this.z * mult;
    }
  }; 

  function float3_Div$14 (a, f) {
    var flag = +f <= 1.192093E-07;
    if (flag) {
      var result = $thisType.Zero.MemberwiseClone();
    } else {
      var mult = +((1 / +f));
      a.x = +a.x * mult;
      a.y = +a.y * mult;
      a.z = +a.z * mult;
      result = a.MemberwiseClone();
    }
    return result;
  }; 

  function float3_Div$15 (/* ref */ a, f, /* ref */ result) {
    var flag = +f <= 1.192093E-07;
    if (flag) {
      var mult = +((1 / +f));
      result.get().x = +a.get().x * mult;
      result.get().y = +a.get().y * mult;
      result.get().z = +a.get().z * mult;
    } else {
      result.set($thisType.Zero.MemberwiseClone());
    }
  }; 

  function float3_Divide$16 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S02().CallStatic($thisType, "Divide", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  }; 

  function float3_Divide$17 (/* ref */ vector, scale, /* ref */ result) {
    $S03().CallStatic($thisType, "Multiply", null, /* ref */ vector, +((1 / +scale)), /* ref */ result);
  }; 

  function float3_Divide$18 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S04().CallStatic($thisType, "Divide", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  }; 

  function float3_Divide$19 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct(+((+vector.get().x / +scale.get().x)), +((+vector.get().y / +scale.get().y)), +((+vector.get().z / +scale.get().z))));
  }; 

  function float3_Dot$1A (left, right) {
    return (((+left.x * +right.x) + (+left.y * +right.y)) + (+left.z * +right.z));
  }; 

  function float3_Dot$1B (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set(((+left.get().x * +right.get().x) + (+left.get().y * +right.get().y)) + (+left.get().z * +right.get().z));
  }; 

  function float3_Object_Equals (obj) {
    var flag = !$thisType.$Is(obj);
    return (!flag && this.Equals($thisType.$Cast(obj).MemberwiseClone()));
  }; 

  function float3_Equals$1C (other) {
    return (!(((Math.abs((+this.x - +other.x))) >= 1.192093E-07) || 
        ((Math.abs((+this.y - +other.y))) >= 1.192093E-07)) && ((Math.abs((+this.z - +other.z))) < 1.192093E-07));
  }; 

  function float3_get_b () {
    return this.z;
  }; 

  function float3_get_g () {
    return this.y;
  }; 

  function float3_get_Length () {
    return Math.fround(Math.sqrt(((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z)));
  }; 

  function float3_get_LengthFast () {
    return +((1 / +$S05().CallStatic($T08(), "InverseSqrtFast", null, ((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z))));
  }; 

  function float3_get_LengthSquared () {
    return (((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z));
  }; 

  function float3_get_Parse () {
    return $thisType.float3$Parse$value;
  }; 

  function float3_get_r () {
    return this.x;
  }; 

  function float3_get_xy () {
    return $S06().Construct(this.x, this.y);
  }; 

  function float3_get_xyz () {
    return $S00().Construct(this.x, this.y, this.z);
  }; 

  function float3_GetBarycentric (a, b, c, point, /* ref */ u, /* ref */ v) {
    var v2 = $thisType.op_Subtraction(b.MemberwiseClone(), c);
    var v3 = $thisType.op_Subtraction(a.MemberwiseClone(), c);
    var v4 = $thisType.op_Subtraction(point.MemberwiseClone(), c);
    var d0 = +$thisType.Dot(v2, v2);
    var d = +$thisType.Dot(v2, v3);
    var d2 = +$thisType.Dot(v3, v3);
    var d3 = +$thisType.Dot(v4, v2);
    var d4 = +$thisType.Dot(v4, v3);
    var denom = (d0 * d2) - (d * d);
    u.set(+((((d0 * d4) - (d * d3)) / denom)));
    v.set(+((((d2 * d3) - (d * d4)) / denom)));
  }; 

  function float3_GetHashCode () {
    return ((((this.x).GetHashCode() | 0) ^ ((this.y).GetHashCode() | 0)) ^ ((this.z).GetHashCode() | 0));
  }; 

  function float3_Lerp$1D (a, b, blend) {
    a.x = (+blend * (+b.x - +a.x)) + +a.x;
    a.y = (+blend * (+b.y - +a.y)) + +a.y;
    a.z = (+blend * (+b.z - +a.z)) + +a.z;
    return a;
  }; 

  function float3_Lerp$1E (/* ref */ a, /* ref */ b, blend, /* ref */ result) {
    result.get().x = (+blend * (+b.get().x - +a.get().x)) + +a.get().x;
    result.get().y = (+blend * (+b.get().y - +a.get().y)) + +a.get().y;
    result.get().z = (+blend * (+b.get().z - +a.get().z)) + +a.get().z;
  }; 

  function float3_Max (left, right) {
    return (
      (+left.get_LengthSquared() >= +right.get_LengthSquared())
         ? left
         : right)
    ;
  }; 

  function float3_Min (left, right) {
    return (
      (+left.get_LengthSquared() < +right.get_LengthSquared())
         ? left
         : right)
    ;
  }; 

  function float3_Mult$1F (f) {
    this.x = +this.x * +f;
    this.y = +this.y * +f;
    this.z = +this.z * +f;
  }; 

  function float3_Mult$20 (a, f) {
    a.x = +a.x * +f;
    a.y = +a.y * +f;
    a.z = +a.z * +f;
    return a;
  }; 

  function float3_Mult$21 (/* ref */ a, f, /* ref */ result) {
    result.get().x = +a.get().x * +f;
    result.get().y = +a.get().y * +f;
    result.get().z = +a.get().z * +f;
  }; 

  function float3_Multiply$22 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S03().CallStatic($thisType, "Multiply", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  }; 

  function float3_Multiply$23 (/* ref */ vector, scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale), (+vector.get().y * +scale), (+vector.get().z * +scale)));
  }; 

  function float3_Multiply$24 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S07().CallStatic($thisType, "Multiply", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  }; 

  function float3_Multiply$25 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale.get().x), (+vector.get().y * +scale.get().y), (+vector.get().z * +scale.get().z)));
  }; 

  function float3_Normalize$26 () {
    var flag = +this.get_Length() <= 1.192093E-07;
    if (!flag) {
      var scale = +((1 / +this.get_Length()));
      this.x = +this.x * scale;
      this.y = +this.y * scale;
      this.z = +this.z * scale;
    }
  }; 

  function float3_Normalize$27 (vec) {
    var flag = +vec.get_Length() > 1.192093E-07;
    if (flag) {
      var scale = +((1 / +vec.get_Length()));
      vec.x = +vec.x * scale;
      vec.y = +vec.y * scale;
      vec.z = +vec.z * scale;
    }
    return vec;
  }; 

  function float3_Normalize$28 (/* ref */ vec, /* ref */ result) {
    var flag = +(vec.get()).get_Length() > 1.192093E-07;
    if (flag) {
      var scale = +((1 / +(vec.get()).get_Length()));
      result.get().x = +vec.get().x * scale;
      result.get().y = +vec.get().y * scale;
      result.get().z = +vec.get().z * scale;
    } else {
      result.set(vec.get().MemberwiseClone());
    }
  }; 

  function float3_NormalizeFast$29 () {
    var scale = +$S05().CallStatic($T08(), "InverseSqrtFast", null, ((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z));
    this.x = +this.x * scale;
    this.y = +this.y * scale;
    this.z = +this.z * scale;
  }; 

  function float3_NormalizeFast$2A (vec) {
    var scale = +$S05().CallStatic($T08(), "InverseSqrtFast", null, ((+vec.x * +vec.x) + (+vec.y * +vec.y)) + (+vec.z * +vec.z));
    vec.x = +vec.x * scale;
    vec.y = +vec.y * scale;
    vec.z = +vec.z * scale;
    return vec;
  }; 

  function float3_NormalizeFast$2B (/* ref */ vec, /* ref */ result) {
    var scale = +$S05().CallStatic($T08(), "InverseSqrtFast", null, ((+vec.get().x * +vec.get().x) + (+vec.get().y * +vec.get().y)) + (+vec.get().z * +vec.get().z));
    result.get().x = +vec.get().x * scale;
    result.get().y = +vec.get().y * scale;
    result.get().z = +vec.get().z * scale;
  }; 

  function float3_op_Addition (left, right) {
    left.x = +left.x + +right.x;
    left.y = +left.y + +right.y;
    left.z = +left.z + +right.z;
    return left;
  }; 

  function float3_op_Division (vec, scale) {
    if ((-1.192093E-07 < +scale) && (+scale < 1.192093E-07)) {
      var result = $thisType.Zero.MemberwiseClone();
    } else {
      var mult = +((1 / +scale));
      vec.x = +vec.x * mult;
      vec.y = +vec.y * mult;
      vec.z = +vec.z * mult;
      result = vec.MemberwiseClone();
    }
    return result;
  }; 

  function float3_op_Equality (left, right) {
    return left.Equals(right.MemberwiseClone());
  }; 

  function float3_op_Explicit (d3) {
    return $S08().Construct(d3);
  }; 

  function float3_op_Inequality (left, right) {
    return !left.Equals(right.MemberwiseClone());
  }; 

  function float3_op_Multiply$2C (vec, scale) {
    vec.x = +vec.x * +scale;
    vec.y = +vec.y * +scale;
    vec.z = +vec.z * +scale;
    return vec;
  }; 

  function float3_op_Multiply$2D (scale, vec) {
    vec.x = +vec.x * +scale;
    vec.y = +vec.y * +scale;
    vec.z = +vec.z * +scale;
    return vec;
  }; 

  function float3_op_Multiply$2E (vec1, vec2) {
    vec1.x = +vec1.x * +vec2.x;
    vec1.y = +vec1.y * +vec2.y;
    vec1.z = +vec1.z * +vec2.z;
    return vec1;
  }; 

  function float3_op_Subtraction (left, right) {
    left.x = +left.x - +right.x;
    left.y = +left.y - +right.y;
    left.z = +left.z - +right.z;
    return left;
  }; 

  function float3_op_UnaryNegation (vec) {
    vec.x = -vec.x;
    vec.y = -vec.y;
    vec.z = -vec.z;
    return vec;
  }; 

  function float3_OrthoNormalize (normal, tangent) {
    var ret = JSIL.Array.New($thisType, 2);
    normal = $thisType.Normalize(normal.MemberwiseClone());
    var proj = $S09().CallStatic($thisType, "op_Multiply", null, normal.MemberwiseClone(), $thisType.Dot(tangent, normal));
    tangent = $thisType.op_Subtraction(tangent.MemberwiseClone(), proj);
    tangent = $thisType.Normalize(tangent.MemberwiseClone());
    ret[0] = normal.MemberwiseClone();
    ret[1] = tangent.MemberwiseClone();
    return ret;
  }; 

  function float3_Scale$2F (sx, sy, sz) {
    this.x = +this.x * +sx;
    this.y = +this.y * +sy;
    this.z = +this.z * +sz;
  }; 

  function float3_Scale$30 (scale) {
    this.x = +this.x * +scale.x;
    this.y = +this.y * +scale.y;
    this.z = +this.z * +scale.z;
  }; 

  function float3_Scale$31 (/* ref */ scale) {
    this.x = +this.x * +scale.get().x;
    this.y = +this.y * +scale.get().y;
    this.z = +this.z * +scale.get().z;
  }; 

  function float3_set_b (value) {
    this.z = +value;
  }; 

  function float3_set_g (value) {
    this.y = +value;
  }; 

  function float3_set_Parse (value) {
    $thisType.float3$Parse$value = value;
  }; 

  function float3_set_r (value) {
    this.x = +value;
  }; 

  function float3_set_xy (value) {
    this.x = +value.x;
    this.y = +value.y;
  }; 

  function float3_set_xyz (value) {
    this.x = +value.x;
    this.y = +value.y;
    this.z = +value.z;
  }; 

  function float3_Sub$32 (right) {
    this.x = +this.x - +right.x;
    this.y = +this.y - +right.y;
    this.z = +this.z - +right.z;
  }; 

  function float3_Sub$33 (/* ref */ right) {
    this.x = +this.x - +right.get().x;
    this.y = +this.y - +right.get().y;
    this.z = +this.z - +right.get().z;
  }; 

  function float3_Sub$34 (a, b) {
    a.x = +a.x - +b.x;
    a.y = +a.y - +b.y;
    a.z = +a.z - +b.z;
    return a;
  }; 

  function float3_Sub$35 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +a.get().x - +b.get().x;
    result.get().y = +a.get().y - +b.get().y;
    result.get().z = +a.get().z - +b.get().z;
  }; 

  function float3_Subtract$36 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Subtract(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  }; 

  function float3_Subtract$37 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x - +b.get().x), (+a.get().y - +b.get().y), (+a.get().z - +b.get().z)));
  }; 

  function float3_ToArray () {
    return JSIL.Array.New($T00(), [this.x, this.y, this.z]);
  }; 

  function float3_toString () {
    return $T0B().Format("({0}, {1}, {2})", JSIL.Array.New($T07(), [$T00().$Box(this.x), $T00().$Box(this.y), $T00().$Box(this.z)]));
  }; 

  function float3_Transform$38 (vec, mat) {
    var v4 = $S0A().Construct(vec.x, vec.y, vec.z, 1);
    v4 = $S0B().CallStatic($T0C(), "op_Multiply", null, mat, v4);
    return v4.get_xyz();
  }; 

  function float3_Transform$39 ($vec, $quat) {
    var quat = new JSIL.BoxedVariable($quat.MemberwiseClone());
    var vec = new JSIL.BoxedVariable($vec.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Transform(/* ref */ vec, /* ref */ quat, /* ref */ result);
    return result.get();
  }; 

  function float3_Transform$3A (/* ref */ vec, /* ref */ quat, /* ref */ result) {
    var temp = new JSIL.BoxedVariable(new $thisType());
    var temp2 = new JSIL.BoxedVariable(new $thisType());
    var xyz = new JSIL.BoxedVariable((quat.get()).get_xyz().MemberwiseClone());
    $thisType.Cross(/* ref */ xyz, /* ref */ vec, /* ref */ temp);
    $S03().CallStatic($thisType, "Multiply", null, /* ref */ vec, (quat.get()).get_w(), /* ref */ temp2);
    $thisType.Add(/* ref */ temp, /* ref */ temp2, /* ref */ temp);
    $thisType.Cross(/* ref */ xyz, /* ref */ temp, /* ref */ temp);
    $S03().CallStatic($thisType, "Multiply", null, /* ref */ temp, 2, /* ref */ temp);
    $thisType.Add(/* ref */ vec, /* ref */ temp, /* ref */ result);
  }; 

  function float3_TransformNormal$3B (norm, mat) {
    mat.Invert();
    return $thisType.TransformNormalInverse(norm.MemberwiseClone(), mat);
  }; 

  function float3_TransformNormal$3C (/* ref */ norm, /* ref */ mat, /* ref */ result) {
    var inverse = new JSIL.BoxedVariable($T0C().Invert(mat.get().MemberwiseClone()).MemberwiseClone());
    $thisType.TransformNormalInverse(/* ref */ norm, /* ref */ inverse, /* ref */ result);
  }; 

  function float3_TransformNormalInverse$3D (norm, invMat) {
    var i = new $thisType();
    i.x = +$thisType.Dot(norm, $S0C().Construct(invMat.Row0));
    i.y = +$thisType.Dot(norm, $S0C().Construct(invMat.Row1));
    i.z = +$thisType.Dot(norm, $S0C().Construct(invMat.Row2));
    return i;
  }; 

  function float3_TransformNormalInverse$3E (/* ref */ norm, /* ref */ invMat, /* ref */ result) {
    result.get().x = ((+norm.get().x * +invMat.get().Row0.x) + (+norm.get().y * +invMat.get().Row0.y)) + (+norm.get().z * +invMat.get().Row0.z);
    result.get().y = ((+norm.get().x * +invMat.get().Row1.x) + (+norm.get().y * +invMat.get().Row1.y)) + (+norm.get().z * +invMat.get().Row1.z);
    result.get().z = ((+norm.get().x * +invMat.get().Row2.x) + (+norm.get().y * +invMat.get().Row2.y)) + (+norm.get().z * +invMat.get().Row2.z);
  }; 

  function float3_TransformPerspective (mat) {
    var result = new $thisType();
    var v = $S0D().Construct(this, 1);
    v = $S0B().CallStatic($T0C(), "op_Multiply", null, mat, v);
    var flag = +v.w > 1.192093E-07;
    if (flag) {
      result.x = +((+v.x / +v.w));
      result.y = +((+v.y / +v.w));
      result.z = +((+v.z / +v.w));
    } else {
      result = $thisType.Zero.MemberwiseClone();
    }
    return result;
  }; 

  function float3_TransformPosition$3F (pos, mat) {
    var p = new $thisType();
    p.x = +$thisType.Dot(pos, $S0C().Construct(mat.get_Column0())) + +mat.Row3.x;
    p.y = +$thisType.Dot(pos, $S0C().Construct(mat.get_Column1())) + +mat.Row3.y;
    p.z = +$thisType.Dot(pos, $S0C().Construct(mat.get_Column2())) + +mat.Row3.z;
    return p;
  }; 

  function float3_TransformPosition$40 (/* ref */ pos, /* ref */ mat, /* ref */ result) {
    result.get().x = (((+pos.get().x * +mat.get().Row0.x) + (+pos.get().y * +mat.get().Row1.x)) + (+pos.get().z * +mat.get().Row2.x)) + +mat.get().Row3.x;
    result.get().y = (((+pos.get().x * +mat.get().Row0.y) + (+pos.get().y * +mat.get().Row1.y)) + (+pos.get().z * +mat.get().Row2.y)) + +mat.get().Row3.y;
    result.get().z = (((+pos.get().x * +mat.get().Row0.z) + (+pos.get().y * +mat.get().Row1.z)) + (+pos.get().z * +mat.get().Row2.z)) + +mat.get().Row3.z;
  }; 

  function float3_TransformVector$41 (vec, mat) {
    var v = new $thisType();
    v.x = +$thisType.Dot(vec, $S0C().Construct(mat.get_Column0()));
    v.y = +$thisType.Dot(vec, $S0C().Construct(mat.get_Column1()));
    v.z = +$thisType.Dot(vec, $S0C().Construct(mat.get_Column2()));
    return v;
  }; 

  function float3_TransformVector$42 (/* ref */ vec, /* ref */ mat, /* ref */ result) {
    result.get().x = ((+vec.get().x * +mat.get().Row0.x) + (+vec.get().y * +mat.get().Row1.x)) + (+vec.get().z * +mat.get().Row2.x);
    result.get().y = ((+vec.get().x * +mat.get().Row0.y) + (+vec.get().y * +mat.get().Row1.y)) + (+vec.get().z * +mat.get().Row2.y);
    result.get().z = ((+vec.get().x * +mat.get().Row0.z) + (+vec.get().y * +mat.get().Row1.z)) + (+vec.get().z * +mat.get().Row2.z);
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.Core.float3", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 3, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single
        ]), 
      float3__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.float2")), 
      float3__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Type), 
      float3__ctor$02
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.float4")), 
      float3__ctor$03
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.double3")), 
      float3__ctor$04
    );

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($.Type), 
      float3_Add$05
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      float3_Add$06
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_Add$07
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Add$08
    );

    $.Method({Static:true , Public:true }, "Barycentric", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type, $.Single, 
          $.Single
        ]), 
      float3_Barycentric
    );

    $.Method({Static:true , Public:true }, "CalculateAngle", 
      new JSIL.MethodSignature($.Single, [$.Type, $.Type]), 
      float3_CalculateAngle$09
    );

    $.Method({Static:true , Public:true }, "CalculateAngle", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Single])
        ]), 
      float3_CalculateAngle$0A
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type
        ]), 
      float3_Clamp$0B
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Clamp$0C
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_ComponentMax$0D
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_ComponentMax$0E
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_ComponentMin$0F
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_ComponentMin$10
    );

    $.Method({Static:true , Public:true }, "Cross", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_Cross$11
    );

    $.Method({Static:true , Public:true }, "Cross", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Cross$12
    );

    $.Method({Static:false, Public:true }, "Div", 
      JSIL.MethodSignature.Action($.Single), 
      float3_Div$13
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float3_Div$14
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Div$15
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float3_Divide$16
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Divide$17
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_Divide$18
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Divide$19
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature($.Single, [$.Type, $.Type]), 
      float3_Dot$1A
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Single])
        ]), 
      float3_Dot$1B
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      float3_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type]), 
      float3_Equals$1C
    );

    $.Method({Static:false, Public:true }, "get_b", 
      JSIL.MethodSignature.Return($.Single), 
      float3_get_b
    );

    $.Method({Static:false, Public:true }, "get_g", 
      JSIL.MethodSignature.Return($.Single), 
      float3_get_g
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      JSIL.MethodSignature.Return($.Single), 
      float3_get_Length
    );

    $.Method({Static:false, Public:true }, "get_LengthFast", 
      JSIL.MethodSignature.Return($.Single), 
      float3_get_LengthFast
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      JSIL.MethodSignature.Return($.Single), 
      float3_get_LengthSquared
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type])), 
      float3_get_Parse
    )
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_r", 
      JSIL.MethodSignature.Return($.Single), 
      float3_get_r
    );

    $.Method({Static:false, Public:true }, "get_xy", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float2")), 
      float3_get_xy
    );

    $.Method({Static:false, Public:true }, "get_xyz", 
      JSIL.MethodSignature.Return($.Type), 
      float3_get_xyz
    );

    $.Method({Static:true , Public:true }, "GetBarycentric", 
      new JSIL.MethodSignature(null, [
          $.Type, $.Type, 
          $.Type, $.Type, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Single]), $jsilcore.TypeRef("JSIL.Reference", [$.Single])
        ]), 
      float3_GetBarycentric
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      float3_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Single
        ]), 
      float3_Lerp$1D
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Lerp$1E
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_Max
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_Min
    );

    $.Method({Static:false, Public:true }, "Mult", 
      JSIL.MethodSignature.Action($.Single), 
      float3_Mult$1F
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float3_Mult$20
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Mult$21
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float3_Multiply$22
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Multiply$23
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_Multiply$24
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Multiply$25
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      JSIL.MethodSignature.Void, 
      float3_Normalize$26
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float3_Normalize$27
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float3_Normalize$28
    );

    $.Method({Static:false, Public:true }, "NormalizeFast", 
      JSIL.MethodSignature.Void, 
      float3_NormalizeFast$29
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float3_NormalizeFast$2A
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float3_NormalizeFast$2B
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Division", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float3_op_Division
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      float3_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Explicit", 
      new JSIL.MethodSignature($.Type, [$asm07.TypeRef("Fusee.Math.Core.double3")]), 
      float3_op_Explicit
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      float3_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float3_op_Multiply$2C
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Single, $.Type]), 
      float3_op_Multiply$2D
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_op_Multiply$2E
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "op_UnaryNegation", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float3_op_UnaryNegation
    );

    $.Method({Static:true , Public:true }, "OrthoNormalize", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Type]), [$.Type, $.Type]), 
      float3_OrthoNormalize
    );

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single
        ]), 
      float3_Scale$2F
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($.Type), 
      float3_Scale$30
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      float3_Scale$31
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "set_b", 
      JSIL.MethodSignature.Action($.Single), 
      float3_set_b
    );

    $.Method({Static:false, Public:true }, "set_g", 
      JSIL.MethodSignature.Action($.Single), 
      float3_set_g
    );

    $.Method({Static:true , Public:true }, "set_Parse", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type])), 
      float3_set_Parse
    )
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "set_r", 
      JSIL.MethodSignature.Action($.Single), 
      float3_set_r
    );

    $.Method({Static:false, Public:true }, "set_xy", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.float2")), 
      float3_set_xy
    );

    $.Method({Static:false, Public:true }, "set_xyz", 
      JSIL.MethodSignature.Action($.Type), 
      float3_set_xyz
    );

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($.Type), 
      float3_Sub$32
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      float3_Sub$33
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_Sub$34
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Sub$35
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_Subtract$36
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Subtract$37
    );

    $.Method({Static:false, Public:true }, "ToArray", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Single])), 
      float3_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      float3_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm07.TypeRef("Fusee.Math.Core.float4x4")]), 
      float3_Transform$38
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm07.TypeRef("Fusee.Math.Core.Quaternion")]), 
      float3_Transform$39
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.Quaternion")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Transform$3A
    );

    $.Method({Static:true , Public:true }, "TransformNormal", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm07.TypeRef("Fusee.Math.Core.float4x4")]), 
      float3_TransformNormal$3B
    );

    $.Method({Static:true , Public:true }, "TransformNormal", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_TransformNormal$3C
    );

    $.Method({Static:true , Public:true }, "TransformNormalInverse", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm07.TypeRef("Fusee.Math.Core.float4x4")]), 
      float3_TransformNormalInverse$3D
    );

    $.Method({Static:true , Public:true }, "TransformNormalInverse", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_TransformNormalInverse$3E
    );

    $.Method({Static:false, Public:true }, "TransformPerspective", 
      new JSIL.MethodSignature($.Type, [$asm07.TypeRef("Fusee.Math.Core.float4x4")]), 
      float3_TransformPerspective
    );

    $.Method({Static:true , Public:true }, "TransformPosition", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm07.TypeRef("Fusee.Math.Core.float4x4")]), 
      float3_TransformPosition$3F
    );

    $.Method({Static:true , Public:true }, "TransformPosition", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_TransformPosition$40
    );

    $.Method({Static:true , Public:true }, "TransformVector", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm07.TypeRef("Fusee.Math.Core.float4x4")]), 
      float3_TransformVector$41
    );

    $.Method({Static:true , Public:true }, "TransformVector", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_TransformVector$42
    );

    $.Field({Static:false, Public:true }, "x", $.Single)
      .Attribute($asm0F.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [1]; });

    $.Field({Static:false, Public:true }, "y", $.Single)
      .Attribute($asm0F.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [2]; });

    $.Field({Static:false, Public:true }, "z", $.Single)
      .Attribute($asm0F.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [3]; });

    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitX", $.Type);

    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitY", $.Type);

    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitZ", $.Type);

    $.Field({Static:true , Public:true , ReadOnly:true }, "Zero", $.Type);

    $.Field({Static:true , Public:true , ReadOnly:true }, "One", $.Type);

    $.Field({Static:true , Public:false}, "float3$Parse$value", $asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type]))
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"))
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerBrowsableAttribute"), function () { return [$asm15.System.Diagnostics.DebuggerBrowsableState.Never]; });


    function float3__cctor () {
      $thisType.UnitX = new $thisType();
      $thisType.UnitY = new $thisType();
      $thisType.UnitZ = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.One = new $thisType();
      $thisType.UnitX = $S00().Construct(1, 0, 0);
      $thisType.UnitY = $S00().Construct(0, 1, 0);
      $thisType.UnitZ = $S00().Construct(0, 0, 1);
      $thisType.Zero = $S00().Construct(0, 0, 0);
      $thisType.One = $S00().Construct(1, 1, 1);
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      float3__cctor
    );

    $.Property({Static:false, Public:true }, "Length", $.Single);

    $.Property({Static:false, Public:true }, "LengthFast", $.Single);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Single);

    $.Property({Static:false, Public:true }, "xy", $asm07.TypeRef("Fusee.Math.Core.float2"));

    $.Property({Static:false, Public:true }, "xyz", $.Type);

    $.Property({Static:false, Public:true }, "r", $.Single);

    $.Property({Static:false, Public:true }, "g", $.Single);

    $.Property({Static:false, Public:true }, "b", $.Single);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type]));

    $.ImplementInterfaces(
      /* 0 */ $asm15.TypeRef("System.IEquatable`1", [$.Type])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("ProtoBuf.ProtoContractAttribute"));

})();

/* struct Fusee.Math.Core.float3x3 */ 

(function float3x3$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.Fusee.Math.Core.float3)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm15.System.Single)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm07.Fusee.Math.Core.float4x4)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm15.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm15.System.Boolean)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm15.System.String)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.float3x3"), [
        $asm07.TypeRef("Fusee.Math.Core.float3"), $asm07.TypeRef("Fusee.Math.Core.float3"), 
        $asm07.TypeRef("Fusee.Math.Core.float3")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.float3x3"), [
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single")
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single")
      ]))) ();
  };


  function float3x3__ctor$00 (row0, row1, row2) {
    this.Row0 = row0.MemberwiseClone();
    this.Row1 = row1.MemberwiseClone();
    this.Row2 = row2.MemberwiseClone();
  }; 

  function float3x3__ctor$01 (m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    this.Row0 = $S02().Construct(m00, m01, m02);
    this.Row1 = $S02().Construct(m10, m11, m12);
    this.Row2 = $S02().Construct(m20, m21, m22);
  }; 

  function float3x3__ctor$02 (mat4) {
    this.Row0 = $S02().Construct(mat4.Row0.x, mat4.Row0.y, mat4.Row0.z);
    this.Row1 = $S02().Construct(mat4.Row1.x, mat4.Row1.y, mat4.Row1.z);
    this.Row2 = $S02().Construct(mat4.Row2.x, mat4.Row2.y, mat4.Row2.z);
  }; 

  function float3x3_Add (left, right) {
    return $S01().Construct((+left.get_M11() + +right.get_M11()), (+left.get_M12() + +right.get_M12()), (+left.get_M13() + +right.get_M13()), (+left.get_M21() + +right.get_M21()), (+left.get_M22() + +right.get_M22()), (+left.get_M23() + +right.get_M23()), (+left.get_M31() + +right.get_M31()), (+left.get_M32() + +right.get_M32()), (+left.get_M33() + +right.get_M33()));
  }; 

  function float3x3_Object_Equals (obj) {
    var flag = !$thisType.$Is(obj);
    return (!flag && this.Equals($thisType.$Cast(obj).MemberwiseClone()));
  }; 

  function float3x3_Equals$03 (other) {
    return (!(!$T00().op_Equality(this.Row0.MemberwiseClone(), other.Row0.MemberwiseClone()) || 
        !$T00().op_Equality(this.Row1.MemberwiseClone(), other.Row1.MemberwiseClone())) && $T00().op_Equality(this.Row2.MemberwiseClone(), other.Row2.MemberwiseClone()));
  }; 

  function float3x3_get_Column0 () {
    return $S02().Construct(this.Row0.x, this.Row1.x, this.Row2.x);
  }; 

  function float3x3_get_Column1 () {
    return $S02().Construct(this.Row0.y, this.Row1.y, this.Row2.y);
  }; 

  function float3x3_get_Column2 () {
    return $S02().Construct(this.Row0.z, this.Row1.z, this.Row2.z);
  }; 

  function float3x3_get_Determinant () {
    return (((((((+this.Row0.x * +this.Row1.y) * +this.Row2.z) + ((+this.Row0.y * +this.Row1.z) * +this.Row2.x)) + ((+this.Row0.z * +this.Row1.x) * +this.Row2.y)) - ((+this.Row0.z * +this.Row1.y) * +this.Row2.x)) - ((+this.Row0.y * +this.Row1.x) * +this.Row2.z)) - ((+this.Row0.x * +this.Row1.z) * +this.Row2.y));
  }; 

  function float3x3_get_IsAffine () {
    return $T00().op_Equality(this.get_Column2().MemberwiseClone(), $T00().UnitZ.MemberwiseClone());
  }; 

  function float3x3_get_M11 () {
    return this.Row0.x;
  }; 

  function float3x3_get_M12 () {
    return this.Row0.y;
  }; 

  function float3x3_get_M13 () {
    return this.Row0.z;
  }; 

  function float3x3_get_M21 () {
    return this.Row1.x;
  }; 

  function float3x3_get_M22 () {
    return this.Row1.y;
  }; 

  function float3x3_get_M23 () {
    return this.Row1.z;
  }; 

  function float3x3_get_M31 () {
    return this.Row2.x;
  }; 

  function float3x3_get_M32 () {
    return this.Row2.y;
  }; 

  function float3x3_get_M33 () {
    return this.Row2.z;
  }; 

  function float3x3_GetHashCode () {
    return (((JSIL.ObjectHashCode(this.Row0, !false, $T03().__Type__)) ^ (JSIL.ObjectHashCode(this.Row1, !false, $T03().__Type__))) ^ (JSIL.ObjectHashCode(this.Row2, !false, $T03().__Type__)));
  }; 

  function float3x3_Mult$04 ($left, $right) {
    var right = new JSIL.BoxedVariable($right);
    var left = new JSIL.BoxedVariable($left);
    var result = new JSIL.BoxedVariable(new $thisType());
    var flag = $thisType.op_Equality(left.get().MemberwiseClone(), $thisType.Identity.MemberwiseClone());
    if (flag) {
      var result2 = right.get().MemberwiseClone();
    } else {
      var flag2 = $thisType.op_Equality(right.get().MemberwiseClone(), $thisType.Identity.MemberwiseClone());
      if (flag2) {
        result2 = left.get().MemberwiseClone();
      } else {
        var flag3 = $thisType.op_Equality(left.get().MemberwiseClone(), $thisType.Zero.MemberwiseClone()) || 
        $thisType.op_Equality(right.get().MemberwiseClone(), $thisType.Zero.MemberwiseClone());
        if (flag3) {
          result2 = $thisType.Zero.MemberwiseClone();
        } else {
          $thisType.Mult(/* ref */ left, /* ref */ right, /* ref */ result);
          result2 = result.get().MemberwiseClone();
        }
      }
    }
    return result2;
  }; 

  function float3x3_Mult$05 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S01().Construct((((+(left.get()).get_M11() * +(right.get()).get_M11()) + (+(left.get()).get_M12() * +(right.get()).get_M21())) + (+(left.get()).get_M13() * +(right.get()).get_M31())), (((+(left.get()).get_M11() * +(right.get()).get_M12()) + (+(left.get()).get_M12() * +(right.get()).get_M22())) + (+(left.get()).get_M13() * +(right.get()).get_M32())), (((+(left.get()).get_M11() * +(right.get()).get_M13()) + (+(left.get()).get_M12() * +(right.get()).get_M23())) + (+(left.get()).get_M13() * +(right.get()).get_M33())), (((+(left.get()).get_M21() * +(right.get()).get_M11()) + (+(left.get()).get_M22() * +(right.get()).get_M21())) + (+(left.get()).get_M23() * +(right.get()).get_M31())), (((+(left.get()).get_M21() * +(right.get()).get_M12()) + (+(left.get()).get_M22() * +(right.get()).get_M22())) + (+(left.get()).get_M23() * +(right.get()).get_M32())), (((+(left.get()).get_M21() * +(right.get()).get_M13()) + (+(left.get()).get_M22() * +(right.get()).get_M23())) + (+(left.get()).get_M23() * +(right.get()).get_M33())), (((+(left.get()).get_M31() * +(right.get()).get_M11()) + (+(left.get()).get_M32() * +(right.get()).get_M21())) + (+(left.get()).get_M33() * +(right.get()).get_M31())), (((+(left.get()).get_M31() * +(right.get()).get_M12()) + (+(left.get()).get_M32() * +(right.get()).get_M22())) + (+(left.get()).get_M33() * +(right.get()).get_M32())), (((+(left.get()).get_M31() * +(right.get()).get_M13()) + (+(left.get()).get_M32() * +(right.get()).get_M23())) + (+(left.get()).get_M33() * +(right.get()).get_M33()))));
  }; 

  function float3x3_op_Addition (left, right) {
    return $thisType.Add(left, right);
  }; 

  function float3x3_op_Equality (left, right) {
    return left.Equals(right.MemberwiseClone());
  }; 

  function float3x3_op_Inequality (left, right) {
    return !left.Equals(right.MemberwiseClone());
  }; 

  function float3x3_op_Multiply$06 (left, right) {
    return $thisType.Mult(left.MemberwiseClone(), right.MemberwiseClone());
  }; 

  function float3x3_op_Multiply$07 (matrix, vector) {
    return $S02().Construct((((+matrix.get_Column0().x * +vector.x) + (+matrix.get_Column1().x * +vector.y)) + (+matrix.get_Column2().x * +vector.z)), (((+matrix.get_Column0().y * +vector.x) + (+matrix.get_Column1().y * +vector.y)) + (+matrix.get_Column2().y * +vector.z)), (((+matrix.get_Column0().z * +vector.x) + (+matrix.get_Column1().z * +vector.y)) + (+matrix.get_Column2().z * +vector.z)));
  }; 

  function float3x3_op_Multiply$08 (vector, matrix) {
    return $S02().Construct((((+matrix.get_M11() * +vector.x) + (+matrix.get_M21() * +vector.y)) + (+matrix.get_M31() * +vector.z)), (((+matrix.get_M12() * +vector.x) + (+matrix.get_M22() * +vector.y)) + (+matrix.get_M32() * +vector.z)), (((+matrix.get_M13() * +vector.x) + (+matrix.get_M23() * +vector.y)) + (+matrix.get_M33() * +vector.z)));
  }; 

  function float3x3_op_Subtraction (left, right) {
    return $thisType.Substract(left, right);
  }; 

  function float3x3_set_M11 (value) {
    this.Row0.x = +value;
  }; 

  function float3x3_set_M12 (value) {
    this.Row0.y = +value;
  }; 

  function float3x3_set_M13 (value) {
    this.Row0.z = +value;
  }; 

  function float3x3_set_M21 (value) {
    this.Row1.x = +value;
  }; 

  function float3x3_set_M22 (value) {
    this.Row1.y = +value;
  }; 

  function float3x3_set_M23 (value) {
    this.Row1.z = +value;
  }; 

  function float3x3_set_M31 (value) {
    this.Row2.x = +value;
  }; 

  function float3x3_set_M32 (value) {
    this.Row2.y = +value;
  }; 

  function float3x3_set_M33 (value) {
    this.Row2.z = +value;
  }; 

  function float3x3_Substract (left, right) {
    return $S01().Construct((+left.get_M11() - +right.get_M11()), (+left.get_M12() - +right.get_M12()), (+left.get_M13() - +right.get_M13()), (+left.get_M21() - +right.get_M21()), (+left.get_M22() - +right.get_M22()), (+left.get_M23() - +right.get_M23()), (+left.get_M31() - +right.get_M31()), (+left.get_M32() - +right.get_M32()), (+left.get_M33() - +right.get_M33()));
  }; 

  function float3x3_ToArray () {
    return JSIL.Array.New($T01(), [this.get_M11(), this.get_M12(), this.get_M13(), this.get_M21(), this.get_M22(), this.get_M23(), this.get_M31(), this.get_M32(), this.get_M33()]);
  }; 

  function float3x3_toString () {
    return $T05().Format("{0}\n{1}\n{2}", JSIL.Array.New($T03(), [this.Row0, this.Row1, this.Row2]));
  }; 

  function float3x3_Transpose$09 () {
    JSIL.CopyMembers($thisType.Transpose(this), this);
  }; 

  function float3x3_Transpose$0A (mat) {
    return $S00().Construct(mat.get_Column0().MemberwiseClone(), mat.get_Column1().MemberwiseClone(), mat.get_Column2().MemberwiseClone());
  }; 

  function float3x3_Transpose$0B (/* ref */ mat, /* ref */ result) {
    result.get().Row0 = (mat.get()).get_Column0().MemberwiseClone();
    result.get().Row1 = (mat.get()).get_Column1().MemberwiseClone();
    result.get().Row2 = (mat.get()).get_Column2().MemberwiseClone();
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.Core.float3x3", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 9, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm07.TypeRef("Fusee.Math.Core.float3"), $asm07.TypeRef("Fusee.Math.Core.float3"), 
          $asm07.TypeRef("Fusee.Math.Core.float3")
        ]), 
      float3x3__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single
        ]), 
      float3x3__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.float4x4")), 
      float3x3__ctor$02
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3x3_Add
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      float3x3_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type]), 
      float3x3_Equals$03
    );

    $.Method({Static:false, Public:true }, "get_Column0", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float3")), 
      float3x3_get_Column0
    );

    $.Method({Static:false, Public:true }, "get_Column1", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float3")), 
      float3x3_get_Column1
    );

    $.Method({Static:false, Public:true }, "get_Column2", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float3")), 
      float3x3_get_Column2
    );

    $.Method({Static:false, Public:true }, "get_Determinant", 
      JSIL.MethodSignature.Return($.Single), 
      float3x3_get_Determinant
    );

    $.Method({Static:false, Public:true }, "get_IsAffine", 
      JSIL.MethodSignature.Return($.Boolean), 
      float3x3_get_IsAffine
    );

    $.Method({Static:false, Public:true }, "get_M11", 
      JSIL.MethodSignature.Return($.Single), 
      float3x3_get_M11
    );

    $.Method({Static:false, Public:true }, "get_M12", 
      JSIL.MethodSignature.Return($.Single), 
      float3x3_get_M12
    );

    $.Method({Static:false, Public:true }, "get_M13", 
      JSIL.MethodSignature.Return($.Single), 
      float3x3_get_M13
    );

    $.Method({Static:false, Public:true }, "get_M21", 
      JSIL.MethodSignature.Return($.Single), 
      float3x3_get_M21
    );

    $.Method({Static:false, Public:true }, "get_M22", 
      JSIL.MethodSignature.Return($.Single), 
      float3x3_get_M22
    );

    $.Method({Static:false, Public:true }, "get_M23", 
      JSIL.MethodSignature.Return($.Single), 
      float3x3_get_M23
    );

    $.Method({Static:false, Public:true }, "get_M31", 
      JSIL.MethodSignature.Return($.Single), 
      float3x3_get_M31
    );

    $.Method({Static:false, Public:true }, "get_M32", 
      JSIL.MethodSignature.Return($.Single), 
      float3x3_get_M32
    );

    $.Method({Static:false, Public:true }, "get_M33", 
      JSIL.MethodSignature.Return($.Single), 
      float3x3_get_M33
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      float3x3_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3x3_Mult$04
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3x3_Mult$05
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3x3_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      float3x3_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      float3x3_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3x3_op_Multiply$06
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [$.Type, $asm07.TypeRef("Fusee.Math.Core.float3")]), 
      float3x3_op_Multiply$07
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [$asm07.TypeRef("Fusee.Math.Core.float3"), $.Type]), 
      float3x3_op_Multiply$08
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3x3_op_Subtraction
    );

    $.Method({Static:false, Public:true }, "set_M11", 
      JSIL.MethodSignature.Action($.Single), 
      float3x3_set_M11
    );

    $.Method({Static:false, Public:true }, "set_M12", 
      JSIL.MethodSignature.Action($.Single), 
      float3x3_set_M12
    );

    $.Method({Static:false, Public:true }, "set_M13", 
      JSIL.MethodSignature.Action($.Single), 
      float3x3_set_M13
    );

    $.Method({Static:false, Public:true }, "set_M21", 
      JSIL.MethodSignature.Action($.Single), 
      float3x3_set_M21
    );

    $.Method({Static:false, Public:true }, "set_M22", 
      JSIL.MethodSignature.Action($.Single), 
      float3x3_set_M22
    );

    $.Method({Static:false, Public:true }, "set_M23", 
      JSIL.MethodSignature.Action($.Single), 
      float3x3_set_M23
    );

    $.Method({Static:false, Public:true }, "set_M31", 
      JSIL.MethodSignature.Action($.Single), 
      float3x3_set_M31
    );

    $.Method({Static:false, Public:true }, "set_M32", 
      JSIL.MethodSignature.Action($.Single), 
      float3x3_set_M32
    );

    $.Method({Static:false, Public:true }, "set_M33", 
      JSIL.MethodSignature.Action($.Single), 
      float3x3_set_M33
    );

    $.Method({Static:true , Public:true }, "Substract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3x3_Substract
    );

    $.Method({Static:false, Public:false}, "ToArray", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Single])), 
      float3x3_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      float3x3_toString
    );

    $.Method({Static:false, Public:true }, "Transpose", 
      JSIL.MethodSignature.Void, 
      float3x3_Transpose$09
    );

    $.Method({Static:true , Public:true }, "Transpose", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float3x3_Transpose$0A
    );

    $.Method({Static:true , Public:true }, "Transpose", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float3x3_Transpose$0B
    );

    $.Field({Static:false, Public:true }, "Row0", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:true }, "Row1", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:true }, "Row2", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:true , Public:true }, "Identity", $.Type);

    $.Field({Static:true , Public:true }, "Zero", $.Type);


    function float3x3__cctor () {
      $thisType.Identity = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.Identity = $S00().Construct($T00().UnitX.MemberwiseClone(), $T00().UnitY.MemberwiseClone(), $T00().UnitZ.MemberwiseClone());
      $thisType.Zero = $S01().Construct(0, 0, 0, 0, 0, 0, 0, 0, 0);
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      float3x3__cctor
    );

    $.Property({Static:false, Public:true }, "Determinant", $.Single);

    $.Property({Static:false, Public:true }, "Column0", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "Column1", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "Column2", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "M11", $.Single);

    $.Property({Static:false, Public:true }, "M12", $.Single);

    $.Property({Static:false, Public:true }, "M13", $.Single);

    $.Property({Static:false, Public:true }, "M21", $.Single);

    $.Property({Static:false, Public:true }, "M22", $.Single);

    $.Property({Static:false, Public:true }, "M23", $.Single);

    $.Property({Static:false, Public:true }, "M31", $.Single);

    $.Property({Static:false, Public:true }, "M32", $.Single);

    $.Property({Static:false, Public:true }, "M33", $.Single);

    $.Property({Static:false, Public:true }, "IsAffine", $.Boolean);

    $.ImplementInterfaces(
      /* 0 */ $asm15.TypeRef("System.IEquatable`1", [$.Type])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Math.Core.float4 */ 

(function float4$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm15.System.Single)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm07.Fusee.Math.Core.float2)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm07.Fusee.Math.Core.float3)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.Fusee.Math.Core.double4)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm15.System.Object)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm15.System.Boolean)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm15.System.Math)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm15.System.Int32)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm15.System.IndexOutOfRangeException)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm15.System.String)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm15.System.Double)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm07.Fusee.Math.Core.M)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm07.Fusee.Math.Core.Converter$b2.Of($asm15.System.String, $asm07.Fusee.Math.Core.float4))) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm07.Fusee.Math.Core.Quaternion)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm07.Fusee.Math.Core.float4x4)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.float4"), [
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float4"), [$asm15.TypeRef("System.Single"), $asm07.TypeRef("Fusee.Math.Core.float4")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float4")]), $asm15.TypeRef("System.Single"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float4")])
      ]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float4")]), $asm15.TypeRef("System.Single"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float4")])
      ]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float4")])
      ]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.ConstructorSignature($asm15.TypeRef("System.IndexOutOfRangeException"), [$asm15.TypeRef("System.String")]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature($asm15.TypeRef("System.Single"), [$asm15.TypeRef("System.Single")]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.float2"), [$asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single")]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single")
      ]))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float4")])
      ]))) ();
  };
  var $S0A = function () {
    return ($S0A = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.float4"), [$asm07.TypeRef("Fusee.Math.Core.double4")]))) ();
  };
  var $S0B = function () {
    return ($S0B = JSIL.Memoize(new JSIL.MethodSignature($asm15.TypeRef("System.Double"), [$asm15.TypeRef("System.Double"), $asm15.TypeRef("System.Int32")]))) ();
  };
  var $S0C = function () {
    return ($S0C = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.Quaternion")]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.Quaternion")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.Quaternion")])
      ]))) ();
  };
  var $S0D = function () {
    return ($S0D = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float4"), [$asm07.TypeRef("Fusee.Math.Core.float4x4"), $asm07.TypeRef("Fusee.Math.Core.float4")]))) ();
  };


  function float4__ctor$00 (x, y, z, w) {
    JSIL.CopyMembers(new $thisType(), this);
    this.x = +x;
    this.y = +y;
    this.z = +z;
    this.w = +w;
  }; 

  function float4__ctor$01 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = 0;
    this.w = 0;
  }; 

  function float4__ctor$02 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
    this.w = 0;
  }; 

  function float4__ctor$03 (v, ww) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
    this.w = +ww;
  }; 

  function float4__ctor$04 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
    this.w = +v.w;
  }; 

  function float4__ctor$05 (d4) {
    this.x = Math.fround(d4.x);
    this.y = Math.fround(d4.y);
    this.z = Math.fround(d4.z);
    this.w = Math.fround(d4.w);
  }; 

  function float4_Add$06 (right) {
    this.x = +this.x + +right.x;
    this.y = +this.y + +right.y;
    this.z = +this.z + +right.z;
    this.w = +this.w + +right.w;
  }; 

  function float4_Add$07 (/* ref */ right) {
    this.x = +this.x + +right.get().x;
    this.y = +this.y + +right.get().y;
    this.z = +this.z + +right.get().z;
    this.w = +this.w + +right.get().w;
  }; 

  function float4_Add$08 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Add(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  }; 

  function float4_Add$09 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x + +b.get().x), (+a.get().y + +b.get().y), (+a.get().z + +b.get().z), (+a.get().w + +b.get().w)));
  }; 

  function float4_BaryCentric (a, b, c, u, v) {
    return $thisType.op_Addition(
      $thisType.op_Addition(
        $S01().CallStatic($thisType, "op_Multiply", null, u, a.MemberwiseClone()).MemberwiseClone(), 
        $S01().CallStatic($thisType, "op_Multiply", null, v, b.MemberwiseClone())
      ).MemberwiseClone(), 
      $S01().CallStatic($thisType, "op_Multiply", null, (1 - +u) - +v, c.MemberwiseClone())
    );
  }; 

  function float4_Clamp$0A (vec, min, max) {
    vec.x = +(
      (+vec.x < +min.x)
         ? min.x
         : (
          (+vec.x > +max.x)
             ? max.x
             : vec.x)
    )
    ;
    vec.y = +(
      (+vec.y < +min.y)
         ? min.y
         : (
          (+vec.y > +max.y)
             ? max.y
             : vec.y)
    )
    ;
    vec.z = +(
      (+vec.x < +min.z)
         ? min.z
         : (
          (+vec.z > +max.z)
             ? max.z
             : vec.z)
    )
    ;
    vec.w = +(
      (+vec.y < +min.w)
         ? min.w
         : (
          (+vec.w > +max.w)
             ? max.w
             : vec.w)
    )
    ;
    return vec;
  }; 

  function float4_Clamp$0B (/* ref */ vec, /* ref */ min, /* ref */ max, /* ref */ result) {
    result.get().x = +(
      (+vec.get().x < +min.get().x)
         ? min.get().x
         : (
          (+vec.get().x > +max.get().x)
             ? max.get().x
             : vec.get().x)
    )
    ;
    result.get().y = +(
      (+vec.get().y < +min.get().y)
         ? min.get().y
         : (
          (+vec.get().y > +max.get().y)
             ? max.get().y
             : vec.get().y)
    )
    ;
    result.get().z = +(
      (+vec.get().x < +min.get().z)
         ? min.get().z
         : (
          (+vec.get().z > +max.get().z)
             ? max.get().z
             : vec.get().z)
    )
    ;
    result.get().w = +(
      (+vec.get().y < +min.get().w)
         ? min.get().w
         : (
          (+vec.get().w > +max.get().w)
             ? max.get().w
             : vec.get().w)
    )
    ;
  }; 

  function float4_Div$0C (f) {
    var mult = +((1 / +f));
    this.x = +this.x * mult;
    this.y = +this.y * mult;
    this.z = +this.z * mult;
    this.w = +this.w * mult;
  }; 

  function float4_Div$0D (a, f) {
    var mult = +((1 / +f));
    a.x = +a.x * mult;
    a.y = +a.y * mult;
    a.z = +a.z * mult;
    a.w = +a.w * mult;
    return a;
  }; 

  function float4_Div$0E (/* ref */ a, f, /* ref */ result) {
    var mult = +((1 / +f));
    result.get().x = +a.get().x * mult;
    result.get().y = +a.get().y * mult;
    result.get().z = +a.get().z * mult;
    result.get().w = +a.get().w * mult;
  }; 

  function float4_Divide$0F ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S02().CallStatic($thisType, "Divide", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  }; 

  function float4_Divide$10 (/* ref */ vector, scale, /* ref */ result) {
    $S03().CallStatic($thisType, "Multiply", null, /* ref */ vector, +((1 / +scale)), /* ref */ result);
  }; 

  function float4_Divide$11 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S04().CallStatic($thisType, "Divide", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  }; 

  function float4_Divide$12 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct(+((+vector.get().x / +scale.get().x)), +((+vector.get().y / +scale.get().y)), +((+vector.get().z / +scale.get().z)), +((+vector.get().w / +scale.get().w))));
  }; 

  function float4_Dot$13 (left, right) {
    return ((((+left.x * +right.x) + (+left.y * +right.y)) + (+left.z * +right.z)) + (+left.w * +right.w));
  }; 

  function float4_Dot$14 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set((((+left.get().x * +right.get().x) + (+left.get().y * +right.get().y)) + (+left.get().z * +right.get().z)) + (+left.get().w * +right.get().w));
  }; 

  function float4_Object_Equals (obj) {
    var flag = !$thisType.$Is(obj);
    return (!flag && this.Equals($thisType.$Cast(obj).MemberwiseClone()));
  }; 

  function float4_Equals$15 (other) {
    return (!(((Math.abs((+this.x - +other.x))) >= 1.192093E-07) || 
        ((Math.abs((+this.y - +other.y))) >= 1.192093E-07) || 
        ((Math.abs((+this.z - +other.z))) >= 1.192093E-07)) && ((Math.abs((+this.w - +other.w))) < 1.192093E-07));
  }; 

  function float4_get_a () {
    return this.w;
  }; 

  function float4_get_b () {
    return this.z;
  }; 

  function float4_get_g () {
    return this.y;
  }; 

  function float4_get_Item (i) {
    switch (i) {
      case 0: 
        var result = +this.x;
        break;

      case 1: 
        result = +this.y;
        break;

      case 2: 
        result = +this.z;
        break;

      case 3: 
        result = +this.w;
        break;

      default: 
        throw $S05().Construct(JSIL.ConcatString("float4 cannot be indexed with an index of ", $T07().$Box(i)));

    }
    return result;
  }; 

  function float4_get_Length () {
    return Math.fround(Math.sqrt((((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z)) + (+this.w * +this.w)));
  }; 

  function float4_get_Length1 () {
    return ((((Math.abs(this.x)) + (Math.abs(this.y))) + (Math.abs(this.z))) + (Math.abs(this.w)));
  }; 

  function float4_get_LengthFast () {
    return +((1 / +$S06().CallStatic($T0B(), "InverseSqrtFast", null, (((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z)) + (+this.w * +this.w))));
  }; 

  function float4_get_LengthSquared () {
    return ((((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z)) + (+this.w * +this.w));
  }; 

  function float4_get_Parse () {
    return $thisType.float4$Parse$value;
  }; 

  function float4_get_r () {
    return this.x;
  }; 

  function float4_get_rg () {
    return this.get_xy();
  }; 

  function float4_get_rgb () {
    return this.get_xyz();
  }; 

  function float4_get_xy () {
    return $S07().Construct(this.x, this.y);
  }; 

  function float4_get_xyz () {
    return $S08().Construct(this.x, this.y, this.z);
  }; 

  function float4_GetHashCode () {
    return (((((this.x).GetHashCode() | 0) ^ ((this.y).GetHashCode() | 0)) ^ ((this.z).GetHashCode() | 0)) ^ ((this.w).GetHashCode() | 0));
  }; 

  function float4_Lerp$16 (a, b, blend) {
    a.x = (+blend * (+b.x - +a.x)) + +a.x;
    a.y = (+blend * (+b.y - +a.y)) + +a.y;
    a.z = (+blend * (+b.z - +a.z)) + +a.z;
    a.w = (+blend * (+b.w - +a.w)) + +a.w;
    return a;
  }; 

  function float4_Lerp$17 (/* ref */ a, /* ref */ b, blend, /* ref */ result) {
    result.get().x = (+blend * (+b.get().x - +a.get().x)) + +a.get().x;
    result.get().y = (+blend * (+b.get().y - +a.get().y)) + +a.get().y;
    result.get().z = (+blend * (+b.get().z - +a.get().z)) + +a.get().z;
    result.get().w = (+blend * (+b.get().w - +a.get().w)) + +a.get().w;
  }; 

  function float4_Max$18 (a, b) {
    a.x = +(
      (+a.x > +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y > +b.y)
         ? a.y
         : b.y)
    ;
    a.z = +(
      (+a.z > +b.z)
         ? a.z
         : b.z)
    ;
    a.w = +(
      (+a.w > +b.w)
         ? a.w
         : b.w)
    ;
    return a;
  }; 

  function float4_Max$19 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x > +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y > +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
    result.get().z = +(
      (+a.get().z > +b.get().z)
         ? a.get().z
         : b.get().z)
    ;
    result.get().w = +(
      (+a.get().w > +b.get().w)
         ? a.get().w
         : b.get().w)
    ;
  }; 

  function float4_Min$1A (a, b) {
    a.x = +(
      (+a.x < +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y < +b.y)
         ? a.y
         : b.y)
    ;
    a.z = +(
      (+a.z < +b.z)
         ? a.z
         : b.z)
    ;
    a.w = +(
      (+a.w < +b.w)
         ? a.w
         : b.w)
    ;
    return a;
  }; 

  function float4_Min$1B (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x < +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y < +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
    result.get().z = +(
      (+a.get().z < +b.get().z)
         ? a.get().z
         : b.get().z)
    ;
    result.get().w = +(
      (+a.get().w < +b.get().w)
         ? a.get().w
         : b.get().w)
    ;
  }; 

  function float4_Mult$1C (f) {
    this.x = +this.x * +f;
    this.y = +this.y * +f;
    this.z = +this.z * +f;
    this.w = +this.w * +f;
  }; 

  function float4_Mult$1D (a, f) {
    a.x = +a.x * +f;
    a.y = +a.y * +f;
    a.z = +a.z * +f;
    a.w = +a.w * +f;
    return a;
  }; 

  function float4_Mult$1E (/* ref */ a, f, /* ref */ result) {
    result.get().x = +a.get().x * +f;
    result.get().y = +a.get().y * +f;
    result.get().z = +a.get().z * +f;
    result.get().w = +a.get().w * +f;
  }; 

  function float4_Multiply$1F ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S03().CallStatic($thisType, "Multiply", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  }; 

  function float4_Multiply$20 (/* ref */ vector, scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale), (+vector.get().y * +scale), (+vector.get().z * +scale), (+vector.get().w * +scale)));
  }; 

  function float4_Multiply$21 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S09().CallStatic($thisType, "Multiply", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  }; 

  function float4_Multiply$22 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale.get().x), (+vector.get().y * +scale.get().y), (+vector.get().z * +scale.get().z), (+vector.get().w * +scale.get().w)));
  }; 

  function float4_Normalize$23 () {
    var scale = +((1 / +this.get_Length()));
    this.x = +this.x * scale;
    this.y = +this.y * scale;
    this.z = +this.z * scale;
    this.w = +this.w * scale;
  }; 

  function float4_Normalize$24 (vec) {
    var scale = +((1 / +vec.get_Length()));
    vec.x = +vec.x * scale;
    vec.y = +vec.y * scale;
    vec.z = +vec.z * scale;
    vec.w = +vec.w * scale;
    return vec;
  }; 

  function float4_Normalize$25 (/* ref */ vec, /* ref */ result) {
    var scale = +((1 / +(vec.get()).get_Length()));
    result.get().x = +vec.get().x * scale;
    result.get().y = +vec.get().y * scale;
    result.get().z = +vec.get().z * scale;
    result.get().w = +vec.get().w * scale;
  }; 

  function float4_Normalize1 () {
    var scale = +((1 / +this.get_Length1()));
    this.x = +this.x * scale;
    this.y = +this.y * scale;
    this.z = +this.z * scale;
    this.w = +this.w * scale;
  }; 

  function float4_NormalizeFast$26 () {
    var scale = +$S06().CallStatic($T0B(), "InverseSqrtFast", null, (((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z)) + (+this.w * +this.w));
    this.x = +this.x * scale;
    this.y = +this.y * scale;
    this.z = +this.z * scale;
    this.w = +this.w * scale;
  }; 

  function float4_NormalizeFast$27 (vec) {
    var scale = +$S06().CallStatic($T0B(), "InverseSqrtFast", null, (((+vec.x * +vec.x) + (+vec.y * +vec.y)) + (+vec.z * +vec.z)) + (+vec.w * +vec.w));
    vec.x = +vec.x * scale;
    vec.y = +vec.y * scale;
    vec.z = +vec.z * scale;
    vec.w = +vec.w * scale;
    return vec;
  }; 

  function float4_NormalizeFast$28 (/* ref */ vec, /* ref */ result) {
    var scale = +$S06().CallStatic($T0B(), "InverseSqrtFast", null, (((+vec.get().x * +vec.get().x) + (+vec.get().y * +vec.get().y)) + (+vec.get().z * +vec.get().z)) + (+vec.get().w * +vec.get().w));
    result.get().x = +vec.get().x * scale;
    result.get().y = +vec.get().y * scale;
    result.get().z = +vec.get().z * scale;
    result.get().w = +vec.get().w * scale;
  }; 

  function float4_op_Addition (left, right) {
    left.x = +left.x + +right.x;
    left.y = +left.y + +right.y;
    left.z = +left.z + +right.z;
    left.w = +left.w + +right.w;
    return left;
  }; 

  function float4_op_Division (vec, scale) {
    var mult = +((1 / +scale));
    vec.x = +vec.x * mult;
    vec.y = +vec.y * mult;
    vec.z = +vec.z * mult;
    vec.w = +vec.w * mult;
    return vec;
  }; 

  function float4_op_Equality (left, right) {
    return left.Equals(right.MemberwiseClone());
  }; 

  function float4_op_Explicit (d4) {
    return $S0A().Construct(d4);
  }; 

  function float4_op_Inequality (left, right) {
    return !left.Equals(right.MemberwiseClone());
  }; 

  function float4_op_Multiply$29 (vec, scale) {
    vec.x = +vec.x * +scale;
    vec.y = +vec.y * +scale;
    vec.z = +vec.z * +scale;
    vec.w = +vec.w * +scale;
    return vec;
  }; 

  function float4_op_Multiply$2A (left, right) {
    left.x = +left.x * +right.x;
    left.y = +left.y * +right.y;
    left.z = +left.z * +right.z;
    left.w = +left.w * +right.w;
    return left;
  }; 

  function float4_op_Multiply$2B (scale, vec) {
    vec.x = +vec.x * +scale;
    vec.y = +vec.y * +scale;
    vec.z = +vec.z * +scale;
    vec.w = +vec.w * +scale;
    return vec;
  }; 

  function float4_op_Subtraction (left, right) {
    left.x = +left.x - +right.x;
    left.y = +left.y - +right.y;
    left.z = +left.z - +right.z;
    left.w = +left.w - +right.w;
    return left;
  }; 

  function float4_op_UnaryNegation (vec) {
    vec.x = -vec.x;
    vec.y = -vec.y;
    vec.z = -vec.z;
    vec.w = -vec.w;
    return vec;
  }; 

  function float4_Round$2C () {
    this.x = Math.fround($S0B().CallStatic($T06(), "Round", null, this.x, 6));
    this.y = Math.fround($S0B().CallStatic($T06(), "Round", null, this.y, 6));
    this.z = Math.fround($S0B().CallStatic($T06(), "Round", null, this.z, 6));
    this.w = Math.fround($S0B().CallStatic($T06(), "Round", null, this.w, 6));
  }; 

  function float4_Round$2D (vec) {
    return $S00().Construct(Math.fround($S0B().CallStatic($T06(), "Round", null, vec.x, 6)), Math.fround($S0B().CallStatic($T06(), "Round", null, vec.y, 6)), Math.fround($S0B().CallStatic($T06(), "Round", null, vec.z, 6)), Math.fround($S0B().CallStatic($T06(), "Round", null, vec.w, 6)));
  }; 

  function float4_Scale$2E (sx, sy, sz, sw) {
    this.x = +this.x * +sx;
    this.y = +this.y * +sy;
    this.z = +this.z * +sz;
    this.w = +this.w * +sw;
  }; 

  function float4_Scale$2F (scale) {
    this.x = +this.x * +scale.x;
    this.y = +this.y * +scale.y;
    this.z = +this.z * +scale.z;
    this.w = +this.w * +scale.w;
  }; 

  function float4_Scale$30 (/* ref */ scale) {
    this.x = +this.x * +scale.get().x;
    this.y = +this.y * +scale.get().y;
    this.z = +this.z * +scale.get().z;
    this.w = +this.w * +scale.get().w;
  }; 

  function float4_set_a (value) {
    this.w = +value;
  }; 

  function float4_set_b (value) {
    this.z = +value;
  }; 

  function float4_set_g (value) {
    this.y = +value;
  }; 

  function float4_set_Item (i, value) {
    switch (i) {
      case 0: 
        this.x = +value;
        break;

      case 1: 
        this.y = +value;
        break;

      case 2: 
        this.z = +value;
        break;

      case 3: 
        this.w = +value;
        break;

      default: 
        throw $S05().Construct(JSIL.ConcatString("float4 cannot be indexed with an index of ", $T07().$Box(i)));

    }
  }; 

  function float4_set_Parse (value) {
    $thisType.float4$Parse$value = value;
  }; 

  function float4_set_r (value) {
    this.x = +value;
  }; 

  function float4_set_rg (value) {
    (this.xy = value.MemberwiseClone());
  }; 

  function float4_set_rgb (value) {
    (this.xyz = value.MemberwiseClone());
  }; 

  function float4_set_xy (value) {
    this.x = +value.x;
    this.y = +value.y;
  }; 

  function float4_set_xyz (value) {
    this.x = +value.x;
    this.y = +value.y;
    this.z = +value.z;
  }; 

  function float4_Sub$31 (right) {
    this.x = +this.x - +right.x;
    this.y = +this.y - +right.y;
    this.z = +this.z - +right.z;
    this.w = +this.w - +right.w;
  }; 

  function float4_Sub$32 (/* ref */ right) {
    this.x = +this.x - +right.get().x;
    this.y = +this.y - +right.get().y;
    this.z = +this.z - +right.get().z;
    this.w = +this.w - +right.get().w;
  }; 

  function float4_Sub$33 (a, b) {
    a.x = +a.x - +b.x;
    a.y = +a.y - +b.y;
    a.z = +a.z - +b.z;
    a.w = +a.w - +b.w;
    return a;
  }; 

  function float4_Sub$34 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +a.get().x - +b.get().x;
    result.get().y = +a.get().y - +b.get().y;
    result.get().z = +a.get().z - +b.get().z;
    result.get().w = +a.get().w - +b.get().w;
  }; 

  function float4_Subtract$35 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Subtract(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  }; 

  function float4_Subtract$36 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x - +b.get().x), (+a.get().y - +b.get().y), (+a.get().z - +b.get().z), (+a.get().w - +b.get().w)));
  }; 

  function float4_ToArray () {
    return JSIL.Array.New($T00(), [this.x, this.y, this.z, this.w]);
  }; 

  function float4_toString () {
    return $T09().Format("({0}, {1}, {2}, {3})", JSIL.Array.New($T04(), [$T00().$Box(this.x), $T00().$Box(this.y), $T00().$Box(this.z), $T00().$Box(this.w)]));
  }; 

  function float4_Transform (vec, $quat) {
    var quat = new JSIL.BoxedVariable($quat.MemberwiseClone());
    var i = new JSIL.BoxedVariable(new ($T0D())());
    var v = new JSIL.BoxedVariable(new ($T0D())());
    var t = new JSIL.BoxedVariable(new ($T0D())());
    $T0D().prototype._ctor.call(v.get().MemberwiseClone(), vec.x, vec.y, vec.z, vec.w);
    $T0D().Invert(/* ref */ quat, /* ref */ i);
    $S0C().CallStatic($T0D(), "Multiply", null, /* ref */ quat, /* ref */ v, /* ref */ t);
    $S0C().CallStatic($T0D(), "Multiply", null, /* ref */ t, /* ref */ i, /* ref */ v);
    return $S00().Construct((v.get()).get_x(), (v.get()).get_y(), (v.get()).get_z(), (v.get()).get_w());
  }; 

  function float4_TransformPerspective (mat) {
    var tmp = $S0D().CallStatic($T0E(), "op_Multiply", null, mat, this);
    return $thisType.op_Division(tmp.MemberwiseClone(), tmp.w);
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.Core.float4", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 4, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single
        ]), 
      float4__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.float2")), 
      float4__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.float3")), 
      float4__ctor$02
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("Fusee.Math.Core.float3"), $.Single]), 
      float4__ctor$03
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Type), 
      float4__ctor$04
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.double4")), 
      float4__ctor$05
    );

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($.Type), 
      float4_Add$06
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      float4_Add$07
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4_Add$08
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Add$09
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type, $.Single, 
          $.Single
        ]), 
      float4_BaryCentric
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type
        ]), 
      float4_Clamp$0A
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Clamp$0B
    );

    $.Method({Static:false, Public:true }, "Div", 
      JSIL.MethodSignature.Action($.Single), 
      float4_Div$0C
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float4_Div$0D
    );

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Div$0E
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float4_Divide$0F
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Divide$10
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4_Divide$11
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Divide$12
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature($.Single, [$.Type, $.Type]), 
      float4_Dot$13
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Single])
        ]), 
      float4_Dot$14
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      float4_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type]), 
      float4_Equals$15
    );

    $.Method({Static:false, Public:true }, "get_a", 
      JSIL.MethodSignature.Return($.Single), 
      float4_get_a
    );

    $.Method({Static:false, Public:true }, "get_b", 
      JSIL.MethodSignature.Return($.Single), 
      float4_get_b
    );

    $.Method({Static:false, Public:true }, "get_g", 
      JSIL.MethodSignature.Return($.Single), 
      float4_get_g
    );

    $.Method({Static:false, Public:true }, "get_Item", 
      new JSIL.MethodSignature($.Single, [$.Int32]), 
      float4_get_Item
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      JSIL.MethodSignature.Return($.Single), 
      float4_get_Length
    );

    $.Method({Static:false, Public:true }, "get_Length1", 
      JSIL.MethodSignature.Return($.Single), 
      float4_get_Length1
    );

    $.Method({Static:false, Public:true }, "get_LengthFast", 
      JSIL.MethodSignature.Return($.Single), 
      float4_get_LengthFast
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      JSIL.MethodSignature.Return($.Single), 
      float4_get_LengthSquared
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type])), 
      float4_get_Parse
    )
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_r", 
      JSIL.MethodSignature.Return($.Single), 
      float4_get_r
    );

    $.Method({Static:false, Public:true }, "get_rg", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float2")), 
      float4_get_rg
    );

    $.Method({Static:false, Public:true }, "get_rgb", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float3")), 
      float4_get_rgb
    );

    $.Method({Static:false, Public:true }, "get_xy", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float2")), 
      float4_get_xy
    );

    $.Method({Static:false, Public:true }, "get_xyz", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float3")), 
      float4_get_xyz
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      float4_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Single
        ]), 
      float4_Lerp$16
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Lerp$17
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4_Max$18
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Max$19
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4_Min$1A
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Min$1B
    );

    $.Method({Static:false, Public:true }, "Mult", 
      JSIL.MethodSignature.Action($.Single), 
      float4_Mult$1C
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float4_Mult$1D
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Mult$1E
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float4_Multiply$1F
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Multiply$20
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4_Multiply$21
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Multiply$22
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      JSIL.MethodSignature.Void, 
      float4_Normalize$23
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float4_Normalize$24
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float4_Normalize$25
    );

    $.Method({Static:false, Public:true }, "Normalize1", 
      JSIL.MethodSignature.Void, 
      float4_Normalize1
    );

    $.Method({Static:false, Public:true }, "NormalizeFast", 
      JSIL.MethodSignature.Void, 
      float4_NormalizeFast$26
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float4_NormalizeFast$27
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float4_NormalizeFast$28
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Division", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float4_op_Division
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      float4_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Explicit", 
      new JSIL.MethodSignature($.Type, [$asm07.TypeRef("Fusee.Math.Core.double4")]), 
      float4_op_Explicit
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      float4_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float4_op_Multiply$29
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4_op_Multiply$2A
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Single, $.Type]), 
      float4_op_Multiply$2B
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "op_UnaryNegation", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float4_op_UnaryNegation
    );

    $.Method({Static:false, Public:true }, "Round", 
      JSIL.MethodSignature.Void, 
      float4_Round$2C
    );

    $.Method({Static:true , Public:true }, "Round", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float4_Round$2D
    );

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single
        ]), 
      float4_Scale$2E
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($.Type), 
      float4_Scale$2F
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      float4_Scale$30
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "set_a", 
      JSIL.MethodSignature.Action($.Single), 
      float4_set_a
    );

    $.Method({Static:false, Public:true }, "set_b", 
      JSIL.MethodSignature.Action($.Single), 
      float4_set_b
    );

    $.Method({Static:false, Public:true }, "set_g", 
      JSIL.MethodSignature.Action($.Single), 
      float4_set_g
    );

    $.Method({Static:false, Public:true }, "set_Item", 
      new JSIL.MethodSignature(null, [$.Int32, $.Single]), 
      float4_set_Item
    );

    $.Method({Static:true , Public:true }, "set_Parse", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type])), 
      float4_set_Parse
    )
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "set_r", 
      JSIL.MethodSignature.Action($.Single), 
      float4_set_r
    );

    $.Method({Static:false, Public:true }, "set_rg", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.float2")), 
      float4_set_rg
    );

    $.Method({Static:false, Public:true }, "set_rgb", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.float3")), 
      float4_set_rgb
    );

    $.Method({Static:false, Public:true }, "set_xy", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.float2")), 
      float4_set_xy
    );

    $.Method({Static:false, Public:true }, "set_xyz", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.float3")), 
      float4_set_xyz
    );

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($.Type), 
      float4_Sub$31
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      float4_Sub$32
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4_Sub$33
    );

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Sub$34
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4_Subtract$35
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Subtract$36
    );

    $.Method({Static:false, Public:true }, "ToArray", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Single])), 
      float4_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      float4_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm07.TypeRef("Fusee.Math.Core.Quaternion")]), 
      float4_Transform
    );

    $.Method({Static:false, Public:true }, "TransformPerspective", 
      new JSIL.MethodSignature($.Type, [$asm07.TypeRef("Fusee.Math.Core.float4x4")]), 
      float4_TransformPerspective
    );

    $.Field({Static:false, Public:true }, "x", $.Single)
      .Attribute($asm0F.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [1]; });

    $.Field({Static:false, Public:true }, "y", $.Single)
      .Attribute($asm0F.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [2]; });

    $.Field({Static:false, Public:true }, "z", $.Single)
      .Attribute($asm0F.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [3]; });

    $.Field({Static:false, Public:true }, "w", $.Single)
      .Attribute($asm0F.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [4]; });

    $.Field({Static:true , Public:true }, "UnitX", $.Type);

    $.Field({Static:true , Public:true }, "UnitY", $.Type);

    $.Field({Static:true , Public:true }, "UnitZ", $.Type);

    $.Field({Static:true , Public:true }, "UnitW", $.Type);

    $.Field({Static:true , Public:true }, "Zero", $.Type);

    $.Field({Static:true , Public:true , ReadOnly:true }, "One", $.Type);

    $.Field({Static:true , Public:false}, "float4$Parse$value", $asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type]))
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"))
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerBrowsableAttribute"), function () { return [$asm15.System.Diagnostics.DebuggerBrowsableState.Never]; });


    function float4__cctor () {
      $thisType.UnitX = new $thisType();
      $thisType.UnitY = new $thisType();
      $thisType.UnitZ = new $thisType();
      $thisType.UnitW = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.One = new $thisType();
      $thisType.UnitX = $S00().Construct(1, 0, 0, 0);
      $thisType.UnitY = $S00().Construct(0, 1, 0, 0);
      $thisType.UnitZ = $S00().Construct(0, 0, 1, 0);
      $thisType.UnitW = $S00().Construct(0, 0, 0, 1);
      $thisType.Zero = $S00().Construct(0, 0, 0, 0);
      $thisType.One = $S00().Construct(1, 1, 1, 1);
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      float4__cctor
    );

    $.Property({Static:false, Public:true }, "Length", $.Single);

    $.Property({Static:false, Public:true }, "Length1", $.Single);

    $.Property({Static:false, Public:true }, "LengthFast", $.Single);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Single);

    $.Property({Static:false, Public:true }, "xy", $asm07.TypeRef("Fusee.Math.Core.float2"));

    $.Property({Static:false, Public:true }, "xyz", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "r", $.Single);

    $.Property({Static:false, Public:true }, "g", $.Single);

    $.Property({Static:false, Public:true }, "b", $.Single);

    $.Property({Static:false, Public:true }, "rg", $asm07.TypeRef("Fusee.Math.Core.float2"));

    $.Property({Static:false, Public:true }, "rgb", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "a", $.Single);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type]));

    $.Property({Static:false, Public:true }, "Item", $.Single);

    $.ImplementInterfaces(
      /* 0 */ $asm15.TypeRef("System.IEquatable`1", [$.Type])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm15.TypeRef("System.Reflection.DefaultMemberAttribute"), function () { return ["Item"]; })
    .Attribute($asm0F.TypeRef("ProtoBuf.ProtoContractAttribute"));

})();

/* struct Fusee.Math.Core.float4x4 */ 

(function float4x4$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.Fusee.Math.Core.float4)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm15.System.Single)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm07.Fusee.Math.Core.double4x4)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.Fusee.Math.Core.float3)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm15.System.Math)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm15.System.Double)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm15.System.Boolean)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm15.System.ArgumentOutOfRangeException)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm15.System.Object)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm15.System.Exception)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm07.Fusee.Math.Core.Converter$b2.Of($asm15.System.String, $asm07.Fusee.Math.Core.float4x4))) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm15.System.String)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.float4x4"), [
        $asm07.TypeRef("Fusee.Math.Core.float4"), $asm07.TypeRef("Fusee.Math.Core.float4"), 
        $asm07.TypeRef("Fusee.Math.Core.float4"), $asm07.TypeRef("Fusee.Math.Core.float4")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.float4"), [
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single")
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.float4x4"), [
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single")
      ]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.ConstructorSignature($asm15.TypeRef("System.ArgumentOutOfRangeException"), [$asm15.TypeRef("System.String")]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm15.TypeRef("System.Single"), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float4x4")])]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single")
      ]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.ConstructorSignature($asm15.TypeRef("System.Exception"), [$asm15.TypeRef("System.String")]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.float4x4"), [$asm07.TypeRef("Fusee.Math.Core.double4x4")]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float4"), [$asm07.TypeRef("Fusee.Math.Core.float4"), $asm15.TypeRef("System.Single")]))) ();
  };


  function float4x4__ctor$00 (row0, row1, row2, row3) {
    this.Row0 = row0.MemberwiseClone();
    this.Row1 = row1.MemberwiseClone();
    this.Row2 = row2.MemberwiseClone();
    this.Row3 = row3.MemberwiseClone();
  }; 

  function float4x4__ctor$01 (m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    this.Row0 = $S01().Construct(m00, m01, m02, m03);
    this.Row1 = $S01().Construct(m10, m11, m12, m13);
    this.Row2 = $S01().Construct(m20, m21, m22, m23);
    this.Row3 = $S01().Construct(m30, m31, m32, m33);
  }; 

  function float4x4__ctor$02 (d4x4) {
    this.Row0 = $T00().op_Explicit(d4x4.Row0);
    this.Row1 = $T00().op_Explicit(d4x4.Row1);
    this.Row2 = $T00().op_Explicit(d4x4.Row2);
    this.Row3 = $T00().op_Explicit(d4x4.Row3);
  }; 

  function float4x4_Add (left, right) {
    return $S02().Construct((+left.get_M11() + +right.get_M11()), (+left.get_M12() + +right.get_M12()), (+left.get_M13() + +right.get_M13()), (+left.get_M14() + +right.get_M14()), (+left.get_M21() + +right.get_M21()), (+left.get_M22() + +right.get_M22()), (+left.get_M23() + +right.get_M23()), (+left.get_M24() + +right.get_M24()), (+left.get_M31() + +right.get_M31()), (+left.get_M32() + +right.get_M32()), (+left.get_M33() + +right.get_M33()), (+left.get_M34() + +right.get_M34()), (+left.get_M41() + +right.get_M41()), (+left.get_M42() + +right.get_M42()), (+left.get_M43() + +right.get_M43()), (+left.get_M44() + +right.get_M44()));
  }; 

  function float4x4_CreateFromAxisAngle$03 (axis, angle, /* ref */ result) {
    var cos = Math.fround(Math.cos(-angle));
    var sin = Math.fround(Math.sin(-angle));
    var t = 1 - cos;
    axis.Normalize();
    result.set($S02().Construct((((t * +axis.x) * +axis.x) + cos), (((t * +axis.x) * +axis.y) + (sin * +axis.z)), (((t * +axis.x) * +axis.z) - (sin * +axis.y)), 0, (((t * +axis.x) * +axis.y) - (sin * +axis.z)), (((t * +axis.y) * +axis.y) + cos), (((t * +axis.y) * +axis.z) + (sin * +axis.x)), 0, (((t * +axis.x) * +axis.z) + (sin * +axis.y)), (((t * +axis.y) * +axis.z) - (sin * +axis.x)), (((t * +axis.z) * +axis.z) + cos), 0, 0, 0, 0, 1));
  }; 

  function float4x4_CreateFromAxisAngle$04 (axis, angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateFromAxisAngle(axis.MemberwiseClone(), angle, /* ref */ result);
    return result.get();
  }; 

  function float4x4_CreateOrthographic$05 (width, height, zNear, zFar, /* ref */ result) {
    $thisType.CreateOrthographicOffCenter(
      +((-width / 2)), 
      +((+width / 2)), 
      +((-height / 2)), 
      +((+height / 2)), 
      zNear, 
      zFar, 
      /* ref */ result
    );
  }; 

  function float4x4_CreateOrthographic$06 (width, height, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateOrthographicOffCenter(
      +((-width / 2)), 
      +((+width / 2)), 
      +((-height / 2)), 
      +((+height / 2)), 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  }; 

  function float4x4_CreateOrthographicOffCenter$07 (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    result.set(new $thisType());
    var invRL = +((1 / (+right - +left)));
    var invTB = +((1 / (+top - +bottom)));
    var invFN = +((1 / (+zFar - +zNear)));
    (result.get()).set_M11(2 * invRL);
    (result.get()).set_M22(2 * invTB);
    (result.get()).set_M33(2 * invFN);
    (result.get()).set_M14(-(+right + +left) * invRL);
    (result.get()).set_M24(-(+top + +bottom) * invTB);
    (result.get()).set_M34(-(+zFar + +zNear) * invFN);
    (result.get()).set_M44(1);
  }; 

  function float4x4_CreateOrthographicOffCenter$08 (left, right, bottom, top, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateOrthographicOffCenter(
      left, 
      right, 
      bottom, 
      top, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  }; 

  function float4x4_CreateOrthographicOffCenterRH (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    result.set(new $thisType());
    var invRL = +((1 / (+right - +left)));
    var invTB = +((1 / (+top - +bottom)));
    var invFN = +((1 / (+zFar - +zNear)));
    (result.get()).set_M11(2 * invRL);
    (result.get()).set_M22(2 * invTB);
    (result.get()).set_M33(-2 * invFN);
    (result.get()).set_M14(-(+right + +left) * invRL);
    (result.get()).set_M24(-(+top + +bottom) * invTB);
    (result.get()).set_M34(-(+zFar + +zNear) * invFN);
    (result.get()).set_M44(1);
  }; 

  function float4x4_CreatePerspectiveFieldOfView$09 (fovy, aspect, zNear, zFar, /* ref */ result) {
    var flag = (+fovy <= 0) || 
    (fovy > 3.1415926535897931);
    if (flag) {
      throw $S03().Construct("fovy");
    }
    if (+aspect <= 0) {
      throw $S03().Construct("aspect");
    }
    if (+zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (+zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (+zNear >= +zFar) {
      throw $S03().Construct("zNear");
    }
    var yMax = +zNear * Math.fround(Math.tan(0.5 * +fovy));
    $thisType.CreatePerspectiveOffCenter(
      -yMax * +aspect, 
      yMax * +aspect, 
      -yMax, 
      yMax, 
      zNear, 
      zFar, 
      /* ref */ result
    );
  }; 

  function float4x4_CreatePerspectiveFieldOfView$0A (fovy, aspect, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreatePerspectiveFieldOfView(
      fovy, 
      aspect, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  }; 

  function float4x4_CreatePerspectiveFieldOfView_ROW$0B (fovy, aspect, zNear, zFar, /* ref */ result) {
    var flag = (+fovy <= 0) || 
    (fovy > 3.1415926535897931);
    if (flag) {
      throw $S03().Construct("fovy");
    }
    if (+aspect <= 0) {
      throw $S03().Construct("aspect");
    }
    if (+zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (+zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (+zNear >= +zFar) {
      throw $S03().Construct("zNear");
    }
    var yMax = +zNear * Math.fround(Math.tan(0.5 * +fovy));
    $thisType.CreatePerspectiveOffCenter_ROW(
      -yMax * +aspect, 
      yMax * +aspect, 
      -yMax, 
      yMax, 
      zNear, 
      zFar, 
      /* ref */ result
    );
  }; 

  function float4x4_CreatePerspectiveFieldOfView_ROW$0C (fovy, aspect, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreatePerspectiveFieldOfView_ROW(
      fovy, 
      aspect, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  }; 

  function float4x4_CreatePerspectiveOffCenter$0D (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    if (+zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    var flag2 = +zFar <= 0;
    if (flag2) {
      throw $S03().Construct("zFar");
    }
    var flag3 = +zNear >= +zFar;
    if (flag3) {
      throw $S03().Construct("zNear");
    }
    var x = +(((2 * +zNear) / (+right - +left)));
    var y = +(((2 * +zNear) / (+top - +bottom)));
    var a = +(((+left + +right) / (+left - +right)));
    var b = +(((+top + +bottom) / (+bottom - +top)));
    var c = +(((+zFar + +zNear) / (+zFar - +zNear)));
    var d = +((-((2 * +zFar) * +zNear) / (+zFar - +zNear)));
    result.set($S02().Construct(x, 0, a, 0, 0, y, b, 0, 0, 0, c, d, 0, 0, 1, 0));
  }; 

  function float4x4_CreatePerspectiveOffCenter$0E (left, right, bottom, top, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreatePerspectiveOffCenter(
      left, 
      right, 
      bottom, 
      top, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  }; 

  function float4x4_CreatePerspectiveOffCenter_ROW (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    var flag = +zNear <= 0;
    if (flag) {
      throw $S03().Construct("zNear");
    }
    var flag2 = +zFar <= 0;
    if (flag2) {
      throw $S03().Construct("zFar");
    }
    var flag3 = +zNear >= +zFar;
    if (flag3) {
      throw $S03().Construct("zNear");
    }
    var x = +(((2 * +zNear) / (+right - +left)));
    var y = +(((2 * +zNear) / (+top - +bottom)));
    var a = +(((+left + +right) / (+left - +right)));
    var b = +(((+top + +bottom) / (+bottom - +top)));
    var c = +(((+zFar + +zNear) / (+zFar - +zNear)));
    var d = +((-((2 * +zFar) * +zNear) / (+zFar - +zNear)));
    result.set($S02().Construct(x, 0, 0, 0, 0, y, 0, 0, a, b, c, 1, 0, 0, d, 0));
  }; 

  function float4x4_CreatePerspectiveOffCenterRH (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    var flag = +zNear <= 0;
    if (flag) {
      throw $S03().Construct("zNear");
    }
    var flag2 = +zFar <= 0;
    if (flag2) {
      throw $S03().Construct("zFar");
    }
    var flag3 = +zNear >= +zFar;
    if (flag3) {
      throw $S03().Construct("zNear");
    }
    var x = +(((2 * +zNear) / (+right - +left)));
    var y = +(((2 * +zNear) / (+top - +bottom)));
    var a = +(((+right + +left) / (+right - +left)));
    var b = +(((+top + +bottom) / (+top - +bottom)));
    var c = +((-(+zFar + +zNear) / (+zFar - +zNear)));
    var d = +((-((2 * +zFar) * +zNear) / (+zFar - +zNear)));
    result.set($S02().Construct(x, 0, a, 0, 0, y, b, 0, 0, 0, c, d, 0, 0, -1, 0));
  }; 

  function float4x4_CreateRotationX$0F (angle, /* ref */ result) {
    var cos = Math.fround(Math.cos(angle));
    var sin = Math.fround(Math.sin(angle));
    result.get().Row0 = $T00().UnitX.MemberwiseClone();
    result.get().Row1 = $S01().Construct(0, cos, -sin, 0);
    result.get().Row2 = $S01().Construct(0, sin, cos, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  }; 

  function float4x4_CreateRotationX$10 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationX(angle, /* ref */ result);
    return result.get();
  }; 

  function float4x4_CreateRotationX_ROW$11 (angle, /* ref */ result) {
    var cos = Math.fround(Math.cos(angle));
    var sin = Math.fround(Math.sin(angle));
    result.get().Row0 = $T00().UnitX.MemberwiseClone();
    result.get().Row1 = $S01().Construct(0, cos, sin, 0);
    result.get().Row2 = $S01().Construct(0, -sin, cos, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  }; 

  function float4x4_CreateRotationX_ROW$12 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationX_ROW(angle, /* ref */ result);
    return result.get();
  }; 

  function float4x4_CreateRotationY$13 (angle, /* ref */ result) {
    var cos = Math.fround(Math.cos(angle));
    var sin = Math.fround(Math.sin(angle));
    result.get().Row0 = $S01().Construct(cos, 0, sin, 0);
    result.get().Row1 = $T00().UnitY.MemberwiseClone();
    result.get().Row2 = $S01().Construct(-sin, 0, cos, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  }; 

  function float4x4_CreateRotationY$14 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationY(angle, /* ref */ result);
    return result.get();
  }; 

  function float4x4_CreateRotationY_ROW$15 (angle, /* ref */ result) {
    var cos = Math.fround(Math.cos(angle));
    var sin = Math.fround(Math.sin(angle));
    result.get().Row0 = $S01().Construct(cos, 0, -sin, 0);
    result.get().Row1 = $T00().UnitY.MemberwiseClone();
    result.get().Row2 = $S01().Construct(sin, 0, cos, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  }; 

  function float4x4_CreateRotationY_ROW$16 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationY_ROW(angle, /* ref */ result);
    return result.get();
  }; 

  function float4x4_CreateRotationZ$17 (angle, /* ref */ result) {
    var cos = Math.fround(Math.cos(angle));
    var sin = Math.fround(Math.sin(angle));
    result.get().Row0 = $S01().Construct(cos, -sin, 0, 0);
    result.get().Row1 = $S01().Construct(sin, cos, 0, 0);
    result.get().Row2 = $T00().UnitZ.MemberwiseClone();
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  }; 

  function float4x4_CreateRotationZ$18 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationZ(angle, /* ref */ result);
    return result.get();
  }; 

  function float4x4_CreateScale$19 (scale, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    (result.get()).set_M11(scale);
    (result.get()).set_M22(scale);
    (result.get()).set_M33(scale);
  }; 

  function float4x4_CreateScale$1A (scale) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $S04().CallStatic($thisType, "CreateScale", null, scale, /* ref */ result);
    return result.get();
  }; 

  function float4x4_CreateScale$1B (x, y, z, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    (result.get()).set_M11(x);
    (result.get()).set_M22(y);
    (result.get()).set_M33(z);
  }; 

  function float4x4_CreateScale$1C (/* ref */ vector, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    (result.get()).set_M11(vector.get().x);
    (result.get()).set_M22(vector.get().y);
    (result.get()).set_M33(vector.get().z);
  }; 

  function float4x4_CreateScale$1D (x, y, z) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateScale(x, y, z, /* ref */ result);
    return result.get();
  }; 

  function float4x4_CreateScale$1E (vector) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateScale(vector.x, vector.y, vector.z, /* ref */ result);
    return result.get();
  }; 

  function float4x4_CreateTranslation$1F (x, y, z, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    (result.get()).set_M14(x);
    (result.get()).set_M24(y);
    (result.get()).set_M34(z);
  }; 

  function float4x4_CreateTranslation$20 (/* ref */ vector, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    (result.get()).set_M14(vector.get().x);
    (result.get()).set_M24(vector.get().y);
    (result.get()).set_M34(vector.get().z);
  }; 

  function float4x4_CreateTranslation$21 (x, y, z) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateTranslation(x, y, z, /* ref */ result);
    return result.get();
  }; 

  function float4x4_CreateTranslation$22 (vector) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateTranslation(vector.x, vector.y, vector.z, /* ref */ result);
    return result.get();
  }; 

  function float4x4_CreateTranslation_ROW$23 (x, y, z, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    result.get().Row3 = $S01().Construct(x, y, z, 1);
  }; 

  function float4x4_CreateTranslation_ROW$24 (x, y, z) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateTranslation_ROW(x, y, z, /* ref */ result);
    return result.get();
  }; 

  function float4x4_Object_Equals (obj) {
    var flag = !$thisType.$Is(obj);
    return (!flag && this.Equals($thisType.$Cast(obj).MemberwiseClone()));
  }; 

  function float4x4_Equals$25 (other) {
    return (!(!$T00().op_Equality(this.Row0.MemberwiseClone(), other.Row0.MemberwiseClone()) || 
        !$T00().op_Equality(this.Row1.MemberwiseClone(), other.Row1.MemberwiseClone()) || 
        !$T00().op_Equality(this.Row2.MemberwiseClone(), other.Row2.MemberwiseClone())) && $T00().op_Equality(this.Row3.MemberwiseClone(), other.Row3.MemberwiseClone()));
  }; 

  function float4x4_get_Column0 () {
    return $S01().Construct(this.Row0.x, this.Row1.x, this.Row2.x, this.Row3.x);
  }; 

  function float4x4_get_Column1 () {
    return $S01().Construct(this.Row0.y, this.Row1.y, this.Row2.y, this.Row3.y);
  }; 

  function float4x4_get_Column2 () {
    return $S01().Construct(this.Row0.z, this.Row1.z, this.Row2.z, this.Row3.z);
  }; 

  function float4x4_get_Column3 () {
    return $S01().Construct(this.Row0.w, this.Row1.w, this.Row2.w, this.Row3.w);
  }; 

  function float4x4_get_Determinant () {
    return ((((((((((((((((((((((((((+this.Row0.x * +this.Row1.y) * +this.Row2.z) * +this.Row3.w) - (((+this.Row0.x * +this.Row1.y) * +this.Row2.w) * +this.Row3.z)) + (((+this.Row0.x * +this.Row1.z) * +this.Row2.w) * +this.Row3.y)) - (((+this.Row0.x * +this.Row1.z) * +this.Row2.y) * +this.Row3.w)) + (((+this.Row0.x * +this.Row1.w) * +this.Row2.y) * +this.Row3.z)) - (((+this.Row0.x * +this.Row1.w) * +this.Row2.z) * +this.Row3.y)) - (((+this.Row0.y * +this.Row1.z) * +this.Row2.w) * +this.Row3.x)) + (((+this.Row0.y * +this.Row1.z) * +this.Row2.x) * +this.Row3.w)) - (((+this.Row0.y * +this.Row1.w) * +this.Row2.x) * +this.Row3.z)) + (((+this.Row0.y * +this.Row1.w) * +this.Row2.z) * +this.Row3.x)) - (((+this.Row0.y * +this.Row1.x) * +this.Row2.z) * +this.Row3.w)) + (((+this.Row0.y * +this.Row1.x) * +this.Row2.w) * +this.Row3.z)) + (((+this.Row0.z * +this.Row1.w) * +this.Row2.x) * +this.Row3.y)) - (((+this.Row0.z * +this.Row1.w) * +this.Row2.y) * +this.Row3.x)) + (((+this.Row0.z * +this.Row1.x) * +this.Row2.y) * +this.Row3.w)) - (((+this.Row0.z * +this.Row1.x) * +this.Row2.w) * +this.Row3.y)) + (((+this.Row0.z * +this.Row1.y) * +this.Row2.w) * +this.Row3.x)) - (((+this.Row0.z * +this.Row1.y) * +this.Row2.x) * +this.Row3.w)) - (((+this.Row0.w * +this.Row1.x) * +this.Row2.y) * +this.Row3.z)) + (((+this.Row0.w * +this.Row1.x) * +this.Row2.z) * +this.Row3.y)) - (((+this.Row0.w * +this.Row1.y) * +this.Row2.z) * +this.Row3.x)) + (((+this.Row0.w * +this.Row1.y) * +this.Row2.x) * +this.Row3.z)) - (((+this.Row0.w * +this.Row1.z) * +this.Row2.x) * +this.Row3.y)) + (((+this.Row0.w * +this.Row1.z) * +this.Row2.y) * +this.Row3.x));
  }; 

  function float4x4_get_IsAffine () {
    return $T00().op_Equality(this.Row3.MemberwiseClone(), $T00().UnitW.MemberwiseClone());
  }; 

  function float4x4_get_M11 () {
    return this.Row0.x;
  }; 

  function float4x4_get_M12 () {
    return this.Row0.y;
  }; 

  function float4x4_get_M13 () {
    return this.Row0.z;
  }; 

  function float4x4_get_M14 () {
    return this.Row0.w;
  }; 

  function float4x4_get_M21 () {
    return this.Row1.x;
  }; 

  function float4x4_get_M22 () {
    return this.Row1.y;
  }; 

  function float4x4_get_M23 () {
    return this.Row1.z;
  }; 

  function float4x4_get_M24 () {
    return this.Row1.w;
  }; 

  function float4x4_get_M31 () {
    return this.Row2.x;
  }; 

  function float4x4_get_M32 () {
    return this.Row2.y;
  }; 

  function float4x4_get_M33 () {
    return this.Row2.z;
  }; 

  function float4x4_get_M34 () {
    return this.Row2.w;
  }; 

  function float4x4_get_M41 () {
    return this.Row3.x;
  }; 

  function float4x4_get_M42 () {
    return this.Row3.y;
  }; 

  function float4x4_get_M43 () {
    return this.Row3.z;
  }; 

  function float4x4_get_M44 () {
    return this.Row3.w;
  }; 

  function float4x4_get_Offset () {
    return $S05().Construct(this.Row0.w, this.Row1.w, this.Row2.w);
  }; 

  function float4x4_get_Parse () {
    return $thisType.float4x4$Parse$value;
  }; 

  function float4x4_GetHashCode () {
    return ((((JSIL.ObjectHashCode(this.Row0, !false, $T08().__Type__)) ^ (JSIL.ObjectHashCode(this.Row1, !false, $T08().__Type__))) ^ (JSIL.ObjectHashCode(this.Row2, !false, $T08().__Type__))) ^ (JSIL.ObjectHashCode(this.Row3, !false, $T08().__Type__)));
  }; 

  function float4x4_Invert$26 () {
    JSIL.CopyMembers($thisType.Invert(this).MemberwiseClone(), this);
  }; 

  function float4x4_Invert$27 (mat) {
    var flag = $thisType.op_Equality(mat.MemberwiseClone(), $thisType.Identity.MemberwiseClone()) || 
    $thisType.op_Equality(mat.MemberwiseClone(), $thisType.Zero.MemberwiseClone());
    if (flag) {
      var result = mat.MemberwiseClone();
    } else {
      mat.Transpose();
      var tmp0 = +mat.get_M33() * +mat.get_M44();
      var tmp = +mat.get_M34() * +mat.get_M43();
      var tmp2 = +mat.get_M32() * +mat.get_M44();
      var tmp3 = +mat.get_M34() * +mat.get_M42();
      var tmp4 = +mat.get_M32() * +mat.get_M43();
      var tmp5 = +mat.get_M33() * +mat.get_M42();
      var tmp6 = +mat.get_M31() * +mat.get_M44();
      var tmp7 = +mat.get_M34() * +mat.get_M41();
      var tmp8 = +mat.get_M31() * +mat.get_M43();
      var tmp9 = +mat.get_M33() * +mat.get_M41();
      var tmp10 = +mat.get_M31() * +mat.get_M42();
      var tmp11 = +mat.get_M32() * +mat.get_M41();
      var m11 = ((tmp0 * +mat.get_M22()) + (tmp3 * +mat.get_M23())) + (tmp4 * +mat.get_M24());
      m11 -= ((tmp * +mat.get_M22()) + (tmp2 * +mat.get_M23())) + (tmp5 * +mat.get_M24());
      var m12 = ((tmp * +mat.get_M21()) + (tmp6 * +mat.get_M23())) + (tmp9 * +mat.get_M24());
      m12 -= ((tmp0 * +mat.get_M21()) + (tmp7 * +mat.get_M23())) + (tmp8 * +mat.get_M24());
      var m13 = ((tmp2 * +mat.get_M21()) + (tmp7 * +mat.get_M22())) + (tmp10 * +mat.get_M24());
      m13 -= ((tmp3 * +mat.get_M21()) + (tmp6 * +mat.get_M22())) + (tmp11 * +mat.get_M24());
      var m14 = ((tmp5 * +mat.get_M21()) + (tmp8 * +mat.get_M22())) + (tmp11 * +mat.get_M23());
      m14 -= ((tmp4 * +mat.get_M21()) + (tmp9 * +mat.get_M22())) + (tmp10 * +mat.get_M23());
      var m15 = ((tmp * +mat.get_M12()) + (tmp2 * +mat.get_M13())) + (tmp5 * +mat.get_M14());
      m15 -= ((tmp0 * +mat.get_M12()) + (tmp3 * +mat.get_M13())) + (tmp4 * +mat.get_M14());
      var m16 = ((tmp0 * +mat.get_M11()) + (tmp7 * +mat.get_M13())) + (tmp8 * +mat.get_M14());
      m16 -= ((tmp * +mat.get_M11()) + (tmp6 * +mat.get_M13())) + (tmp9 * +mat.get_M14());
      var m17 = ((tmp3 * +mat.get_M11()) + (tmp6 * +mat.get_M12())) + (tmp11 * +mat.get_M14());
      m17 -= ((tmp2 * +mat.get_M11()) + (tmp7 * +mat.get_M12())) + (tmp10 * +mat.get_M14());
      var m18 = ((tmp4 * +mat.get_M11()) + (tmp9 * +mat.get_M12())) + (tmp10 * +mat.get_M13());
      m18 -= ((tmp5 * +mat.get_M11()) + (tmp8 * +mat.get_M12())) + (tmp11 * +mat.get_M13());
      tmp0 = +mat.get_M13() * +mat.get_M24();
      tmp = +mat.get_M14() * +mat.get_M23();
      tmp2 = +mat.get_M12() * +mat.get_M24();
      tmp3 = +mat.get_M14() * +mat.get_M22();
      tmp4 = +mat.get_M12() * +mat.get_M23();
      tmp5 = +mat.get_M13() * +mat.get_M22();
      tmp6 = +mat.get_M11() * +mat.get_M24();
      tmp7 = +mat.get_M14() * +mat.get_M21();
      tmp8 = +mat.get_M11() * +mat.get_M23();
      tmp9 = +mat.get_M13() * +mat.get_M21();
      tmp10 = +mat.get_M11() * +mat.get_M22();
      tmp11 = +mat.get_M12() * +mat.get_M21();
      var m19 = ((tmp0 * +mat.get_M42()) + (tmp3 * +mat.get_M43())) + (tmp4 * +mat.get_M44());
      m19 -= ((tmp * +mat.get_M42()) + (tmp2 * +mat.get_M43())) + (tmp5 * +mat.get_M44());
      var m20 = ((tmp * +mat.get_M41()) + (tmp6 * +mat.get_M43())) + (tmp9 * +mat.get_M44());
      m20 -= ((tmp0 * +mat.get_M41()) + (tmp7 * +mat.get_M43())) + (tmp8 * +mat.get_M44());
      var m21 = ((tmp2 * +mat.get_M41()) + (tmp7 * +mat.get_M42())) + (tmp10 * +mat.get_M44());
      m21 -= ((tmp3 * +mat.get_M41()) + (tmp6 * +mat.get_M42())) + (tmp11 * +mat.get_M44());
      var m22 = ((tmp5 * +mat.get_M41()) + (tmp8 * +mat.get_M42())) + (tmp11 * +mat.get_M43());
      m22 -= ((tmp4 * +mat.get_M41()) + (tmp9 * +mat.get_M42())) + (tmp10 * +mat.get_M43());
      var m23 = ((tmp2 * +mat.get_M33()) + (tmp5 * +mat.get_M34())) + (tmp * +mat.get_M32());
      m23 -= ((tmp4 * +mat.get_M34()) + (tmp0 * +mat.get_M32())) + (tmp3 * +mat.get_M33());
      var m24 = ((tmp8 * +mat.get_M34()) + (tmp0 * +mat.get_M31())) + (tmp7 * +mat.get_M33());
      m24 -= ((tmp6 * +mat.get_M33()) + (tmp9 * +mat.get_M34())) + (tmp * +mat.get_M31());
      var m25 = ((tmp6 * +mat.get_M32()) + (tmp11 * +mat.get_M34())) + (tmp3 * +mat.get_M31());
      m25 -= ((tmp10 * +mat.get_M34()) + (tmp2 * +mat.get_M31())) + (tmp7 * +mat.get_M32());
      var m26 = ((tmp10 * +mat.get_M33()) + (tmp4 * +mat.get_M31())) + (tmp9 * +mat.get_M32());
      m26 -= ((tmp8 * +mat.get_M32()) + (tmp11 * +mat.get_M33())) + (tmp5 * +mat.get_M31());
      var det = (((+mat.get_M11() * m11) + (+mat.get_M12() * m12)) + (+mat.get_M13() * m13)) + (+mat.get_M14() * m14);
      var flag2 = (det > 1.192093E-07) || 
      (det < -1.192093E-07);
      if (flag2) {
        det = +((1 / det));
        (mat = mat.MemberwiseClone(), 
          $thisType.prototype._ctor.call(mat, 
            det * m11, 
            det * m12, 
            det * m13, 
            det * m14, 
            det * m15, 
            det * m16, 
            det * m17, 
            det * m18, 
            det * m19, 
            det * m20, 
            det * m21, 
            det * m22, 
            det * m23, 
            det * m24, 
            det * m25, 
            det * m26
          ));
      } else {
        mat.Transpose();
      }
      result = mat.MemberwiseClone();
    }
    return result;
  }; 

  function float4x4_InvertAffine (mat) {
    throw $S06().Construct("InvertAffine is broken (probably since column order notation)");
  }; 

  function float4x4_LookAt$28 (eye, target, up) {
    var z = $T03().Normalize($T03().op_Subtraction(target.MemberwiseClone(), eye).MemberwiseClone());
    var x = $T03().Normalize($T03().Cross(up.MemberwiseClone(), z.MemberwiseClone()).MemberwiseClone());
    var y = $T03().Cross(z.MemberwiseClone(), x.MemberwiseClone());
    return $S02().Construct(x.x, x.y, x.z, -$T03().Dot(x, eye), y.x, y.y, y.z, -$T03().Dot(y, eye), z.x, z.y, z.z, -$T03().Dot(z, eye), 0, 0, 0, 1);
  }; 

  function float4x4_LookAt$29 (eyeX, eyeY, eyeZ, targetX, targetY, targetZ, upX, upY, upZ) {
    return $thisType.LookAt($S05().Construct(eyeX, eyeY, eyeZ), $S05().Construct(targetX, targetY, targetZ), $S05().Construct(upX, upY, upZ));
  }; 

  function float4x4_LookAt_ROW$2A (eye, target, up) {
    var z = $T03().Normalize($T03().op_Subtraction(target.MemberwiseClone(), eye).MemberwiseClone());
    var x = $T03().Normalize($T03().Cross(up.MemberwiseClone(), z.MemberwiseClone()).MemberwiseClone());
    var y = $T03().Cross(z.MemberwiseClone(), x.MemberwiseClone());
    return $S00().Construct($S01().Construct(x.x, y.x, z.x, 0), $S01().Construct(x.y, y.y, z.y, 0), $S01().Construct(x.z, y.z, z.z, 0), $S01().Construct(-$T03().Dot(x, eye), -$T03().Dot(y, eye), -$T03().Dot(z, eye), 1));
  }; 

  function float4x4_LookAt_ROW$2B (eyeX, eyeY, eyeZ, targetX, targetY, targetZ, upX, upY, upZ) {
    return $thisType.LookAt_ROW($S05().Construct(eyeX, eyeY, eyeZ), $S05().Construct(targetX, targetY, targetZ), $S05().Construct(upX, upY, upZ));
  }; 

  function float4x4_LookAtRH (eye, target, up) {
    var z = $T03().Normalize($T03().op_Subtraction(eye.MemberwiseClone(), target).MemberwiseClone());
    var x = $T03().Normalize($T03().Cross(up.MemberwiseClone(), z.MemberwiseClone()).MemberwiseClone());
    var y = $T03().Cross(z.MemberwiseClone(), x.MemberwiseClone());
    return $S02().Construct(x.x, x.y, x.z, -$T03().Dot(x, eye), y.x, y.y, y.z, -$T03().Dot(y, eye), z.x, z.y, z.z, -$T03().Dot(z, eye), 0, 0, 0, 1);
  }; 

  function float4x4_Mult$2C ($left, $right) {
    var right = new JSIL.BoxedVariable($right);
    var left = new JSIL.BoxedVariable($left);
    var result = new JSIL.BoxedVariable(new $thisType());
    var flag = $thisType.op_Equality(left.get().MemberwiseClone(), $thisType.Identity.MemberwiseClone());
    if (flag) {
      var result2 = right.get().MemberwiseClone();
    } else {
      var flag2 = $thisType.op_Equality(right.get().MemberwiseClone(), $thisType.Identity.MemberwiseClone());
      if (flag2) {
        result2 = left.get().MemberwiseClone();
      } else {
        var flag3 = $thisType.op_Equality(left.get().MemberwiseClone(), $thisType.Zero.MemberwiseClone()) || 
        $thisType.op_Equality(right.get().MemberwiseClone(), $thisType.Zero.MemberwiseClone());
        if (flag3) {
          result2 = $thisType.Zero.MemberwiseClone();
        } else {
          var flag4 = (left.get()).get_IsAffine() && 
          (right.get()).get_IsAffine();
          if (flag4) {
            $thisType.MultAffine(/* ref */ left, /* ref */ right, /* ref */ result);
          } else {
            $thisType.Mult(/* ref */ left, /* ref */ right, /* ref */ result);
          }
          result2 = result.get().MemberwiseClone();
        }
      }
    }
    return result2;
  }; 

  function float4x4_Mult$2D (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct(((((+(left.get()).get_M11() * +(right.get()).get_M11()) + (+(left.get()).get_M12() * +(right.get()).get_M21())) + (+(left.get()).get_M13() * +(right.get()).get_M31())) + (+(left.get()).get_M14() * +(right.get()).get_M41())), ((((+(left.get()).get_M11() * +(right.get()).get_M12()) + (+(left.get()).get_M12() * +(right.get()).get_M22())) + (+(left.get()).get_M13() * +(right.get()).get_M32())) + (+(left.get()).get_M14() * +(right.get()).get_M42())), ((((+(left.get()).get_M11() * +(right.get()).get_M13()) + (+(left.get()).get_M12() * +(right.get()).get_M23())) + (+(left.get()).get_M13() * +(right.get()).get_M33())) + (+(left.get()).get_M14() * +(right.get()).get_M43())), ((((+(left.get()).get_M11() * +(right.get()).get_M14()) + (+(left.get()).get_M12() * +(right.get()).get_M24())) + (+(left.get()).get_M13() * +(right.get()).get_M34())) + (+(left.get()).get_M14() * +(right.get()).get_M44())), ((((+(left.get()).get_M21() * +(right.get()).get_M11()) + (+(left.get()).get_M22() * +(right.get()).get_M21())) + (+(left.get()).get_M23() * +(right.get()).get_M31())) + (+(left.get()).get_M24() * +(right.get()).get_M41())), ((((+(left.get()).get_M21() * +(right.get()).get_M12()) + (+(left.get()).get_M22() * +(right.get()).get_M22())) + (+(left.get()).get_M23() * +(right.get()).get_M32())) + (+(left.get()).get_M24() * +(right.get()).get_M42())), ((((+(left.get()).get_M21() * +(right.get()).get_M13()) + (+(left.get()).get_M22() * +(right.get()).get_M23())) + (+(left.get()).get_M23() * +(right.get()).get_M33())) + (+(left.get()).get_M24() * +(right.get()).get_M43())), ((((+(left.get()).get_M21() * +(right.get()).get_M14()) + (+(left.get()).get_M22() * +(right.get()).get_M24())) + (+(left.get()).get_M23() * +(right.get()).get_M34())) + (+(left.get()).get_M24() * +(right.get()).get_M44())), ((((+(left.get()).get_M31() * +(right.get()).get_M11()) + (+(left.get()).get_M32() * +(right.get()).get_M21())) + (+(left.get()).get_M33() * +(right.get()).get_M31())) + (+(left.get()).get_M34() * +(right.get()).get_M41())), ((((+(left.get()).get_M31() * +(right.get()).get_M12()) + (+(left.get()).get_M32() * +(right.get()).get_M22())) + (+(left.get()).get_M33() * +(right.get()).get_M32())) + (+(left.get()).get_M34() * +(right.get()).get_M42())), ((((+(left.get()).get_M31() * +(right.get()).get_M13()) + (+(left.get()).get_M32() * +(right.get()).get_M23())) + (+(left.get()).get_M33() * +(right.get()).get_M33())) + (+(left.get()).get_M34() * +(right.get()).get_M43())), ((((+(left.get()).get_M31() * +(right.get()).get_M14()) + (+(left.get()).get_M32() * +(right.get()).get_M24())) + (+(left.get()).get_M33() * +(right.get()).get_M34())) + (+(left.get()).get_M34() * +(right.get()).get_M44())), ((((+(left.get()).get_M41() * +(right.get()).get_M11()) + (+(left.get()).get_M42() * +(right.get()).get_M21())) + (+(left.get()).get_M43() * +(right.get()).get_M31())) + (+(left.get()).get_M44() * +(right.get()).get_M41())), ((((+(left.get()).get_M41() * +(right.get()).get_M12()) + (+(left.get()).get_M42() * +(right.get()).get_M22())) + (+(left.get()).get_M43() * +(right.get()).get_M32())) + (+(left.get()).get_M44() * +(right.get()).get_M42())), ((((+(left.get()).get_M41() * +(right.get()).get_M13()) + (+(left.get()).get_M42() * +(right.get()).get_M23())) + (+(left.get()).get_M43() * +(right.get()).get_M33())) + (+(left.get()).get_M44() * +(right.get()).get_M43())), ((((+(left.get()).get_M41() * +(right.get()).get_M14()) + (+(left.get()).get_M42() * +(right.get()).get_M24())) + (+(left.get()).get_M43() * +(right.get()).get_M34())) + (+(left.get()).get_M44() * +(right.get()).get_M44()))));
  }; 

  function float4x4_MultAffine (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct((((+(left.get()).get_M11() * +(right.get()).get_M11()) + (+(left.get()).get_M12() * +(right.get()).get_M21())) + (+(left.get()).get_M13() * +(right.get()).get_M31())), (((+(left.get()).get_M11() * +(right.get()).get_M12()) + (+(left.get()).get_M12() * +(right.get()).get_M22())) + (+(left.get()).get_M13() * +(right.get()).get_M32())), (((+(left.get()).get_M11() * +(right.get()).get_M13()) + (+(left.get()).get_M12() * +(right.get()).get_M23())) + (+(left.get()).get_M13() * +(right.get()).get_M33())), ((((+(left.get()).get_M11() * +(right.get()).get_M14()) + (+(left.get()).get_M12() * +(right.get()).get_M24())) + (+(left.get()).get_M13() * +(right.get()).get_M34())) + +(left.get()).get_M14()), (((+(left.get()).get_M21() * +(right.get()).get_M11()) + (+(left.get()).get_M22() * +(right.get()).get_M21())) + (+(left.get()).get_M23() * +(right.get()).get_M31())), (((+(left.get()).get_M21() * +(right.get()).get_M12()) + (+(left.get()).get_M22() * +(right.get()).get_M22())) + (+(left.get()).get_M23() * +(right.get()).get_M32())), (((+(left.get()).get_M21() * +(right.get()).get_M13()) + (+(left.get()).get_M22() * +(right.get()).get_M23())) + (+(left.get()).get_M23() * +(right.get()).get_M33())), ((((+(left.get()).get_M21() * +(right.get()).get_M14()) + (+(left.get()).get_M22() * +(right.get()).get_M24())) + (+(left.get()).get_M23() * +(right.get()).get_M34())) + +(left.get()).get_M24()), (((+(left.get()).get_M31() * +(right.get()).get_M11()) + (+(left.get()).get_M32() * +(right.get()).get_M21())) + (+(left.get()).get_M33() * +(right.get()).get_M31())), (((+(left.get()).get_M31() * +(right.get()).get_M12()) + (+(left.get()).get_M32() * +(right.get()).get_M22())) + (+(left.get()).get_M33() * +(right.get()).get_M32())), (((+(left.get()).get_M31() * +(right.get()).get_M13()) + (+(left.get()).get_M32() * +(right.get()).get_M23())) + (+(left.get()).get_M33() * +(right.get()).get_M33())), ((((+(left.get()).get_M31() * +(right.get()).get_M14()) + (+(left.get()).get_M32() * +(right.get()).get_M24())) + (+(left.get()).get_M33() * +(right.get()).get_M34())) + +(left.get()).get_M34()), 0, 0, 0, 1));
  }; 

  function float4x4_op_Addition (left, right) {
    return $thisType.Add(left, right);
  }; 

  function float4x4_op_Equality (left, right) {
    return left.Equals(right.MemberwiseClone());
  }; 

  function float4x4_op_Explicit (d4x4) {
    return $S07().Construct(d4x4);
  }; 

  function float4x4_op_Inequality (left, right) {
    return !left.Equals(right.MemberwiseClone());
  }; 

  function float4x4_op_Multiply$2E (left, right) {
    return $thisType.Mult(left.MemberwiseClone(), right.MemberwiseClone());
  }; 

  function float4x4_op_Multiply$2F (matrix, vector) {
    return $thisType.Transform(matrix, vector);
  }; 

  function float4x4_op_Multiply$30 (vector, matrix) {
    return $thisType.TransformPremult(vector, matrix);
  }; 

  function float4x4_op_Multiply$31 (matrix, vector) {
    return $thisType.TransformPD(matrix, vector);
  }; 

  function float4x4_op_Multiply$32 (vector, matrix) {
    return $thisType.TransformPremultPD(vector, matrix);
  }; 

  function float4x4_op_Subtraction (left, right) {
    return $thisType.Substract(left, right);
  }; 

  function float4x4_Round$33 () {
    (this.Row0).Round();
    (this.Row1).Round();
    (this.Row2).Round();
    (this.Row3).Round();
  }; 

  function float4x4_Round$34 (mat) {
    return $S00().Construct($T00().Round(mat.Row0.MemberwiseClone()).MemberwiseClone(), $T00().Round(mat.Row1.MemberwiseClone()).MemberwiseClone(), $T00().Round(mat.Row2.MemberwiseClone()).MemberwiseClone(), $T00().Round(mat.Row3.MemberwiseClone()).MemberwiseClone());
  }; 

  function float4x4_Scale$35 (scale) {
    return $thisType.Scale(scale, scale, scale);
  }; 

  function float4x4_Scale$36 (scale) {
    return $thisType.Scale(scale.x, scale.y, scale.z);
  }; 

  function float4x4_Scale$37 (x, y, z) {
    var result = new $thisType();
    result.Row0 = $S08().CallStatic($T00(), "op_Multiply", null, $T00().UnitX.MemberwiseClone(), x);
    result.Row1 = $S08().CallStatic($T00(), "op_Multiply", null, $T00().UnitY.MemberwiseClone(), y);
    result.Row2 = $S08().CallStatic($T00(), "op_Multiply", null, $T00().UnitZ.MemberwiseClone(), z);
    result.Row3 = $T00().UnitW.MemberwiseClone();
    return result;
  }; 

  function float4x4_set_M11 (value) {
    this.Row0.x = +value;
  }; 

  function float4x4_set_M12 (value) {
    this.Row0.y = +value;
  }; 

  function float4x4_set_M13 (value) {
    this.Row0.z = +value;
  }; 

  function float4x4_set_M14 (value) {
    this.Row0.w = +value;
  }; 

  function float4x4_set_M21 (value) {
    this.Row1.x = +value;
  }; 

  function float4x4_set_M22 (value) {
    this.Row1.y = +value;
  }; 

  function float4x4_set_M23 (value) {
    this.Row1.z = +value;
  }; 

  function float4x4_set_M24 (value) {
    this.Row1.w = +value;
  }; 

  function float4x4_set_M31 (value) {
    this.Row2.x = +value;
  }; 

  function float4x4_set_M32 (value) {
    this.Row2.y = +value;
  }; 

  function float4x4_set_M33 (value) {
    this.Row2.z = +value;
  }; 

  function float4x4_set_M34 (value) {
    this.Row2.w = +value;
  }; 

  function float4x4_set_M41 (value) {
    this.Row3.x = +value;
  }; 

  function float4x4_set_M42 (value) {
    this.Row3.y = +value;
  }; 

  function float4x4_set_M43 (value) {
    this.Row3.z = +value;
  }; 

  function float4x4_set_M44 (value) {
    this.Row3.w = +value;
  }; 

  function float4x4_set_Parse (value) {
    $thisType.float4x4$Parse$value = value;
  }; 

  function float4x4_Substract (left, right) {
    return $S02().Construct((+left.get_M11() - +right.get_M11()), (+left.get_M12() - +right.get_M12()), (+left.get_M13() - +right.get_M13()), (+left.get_M14() - +right.get_M14()), (+left.get_M21() - +right.get_M21()), (+left.get_M22() - +right.get_M22()), (+left.get_M23() - +right.get_M23()), (+left.get_M24() - +right.get_M24()), (+left.get_M31() - +right.get_M31()), (+left.get_M32() - +right.get_M32()), (+left.get_M33() - +right.get_M33()), (+left.get_M34() - +right.get_M34()), (+left.get_M41() - +right.get_M41()), (+left.get_M42() - +right.get_M42()), (+left.get_M43() - +right.get_M43()), (+left.get_M44() - +right.get_M44()));
  }; 

  function float4x4_ToArray () {
    return JSIL.Array.New($T01(), [this.get_M11(), this.get_M12(), this.get_M13(), this.get_M14(), this.get_M21(), this.get_M22(), this.get_M23(), this.get_M24(), this.get_M31(), this.get_M32(), this.get_M33(), this.get_M34(), this.get_M41(), this.get_M42(), this.get_M43(), this.get_M44()]);
  }; 

  function float4x4_toString () {
    return $T0B().Format("{0}\n{1}\n{2}\n{3}", JSIL.Array.New($T08(), [this.Row0, this.Row1, this.Row2, this.Row3]));
  }; 

  function float4x4_Transform (matrix, vector) {
    return $S01().Construct(((((+matrix.get_M11() * +vector.x) + (+matrix.get_M12() * +vector.y)) + (+matrix.get_M13() * +vector.z)) + (+matrix.get_M14() * +vector.w)), ((((+matrix.get_M21() * +vector.x) + (+matrix.get_M22() * +vector.y)) + (+matrix.get_M23() * +vector.z)) + (+matrix.get_M24() * +vector.w)), ((((+matrix.get_M31() * +vector.x) + (+matrix.get_M32() * +vector.y)) + (+matrix.get_M33() * +vector.z)) + (+matrix.get_M34() * +vector.w)), ((((+matrix.get_M41() * +vector.x) + (+matrix.get_M42() * +vector.y)) + (+matrix.get_M43() * +vector.z)) + (+matrix.get_M44() * +vector.w)));
  }; 

  function float4x4_TransformPD (matrix, vector) {
    var w = (((+matrix.get_M41() * +vector.x) + (+matrix.get_M42() * +vector.y)) + (+matrix.get_M43() * +vector.z)) + +matrix.get_M44();
    return $S05().Construct(+((((((+matrix.get_M11() * +vector.x) + (+matrix.get_M12() * +vector.y)) + (+matrix.get_M13() * +vector.z)) + +matrix.get_M14()) / w)), +((((((+matrix.get_M21() * +vector.x) + (+matrix.get_M22() * +vector.y)) + (+matrix.get_M23() * +vector.z)) + +matrix.get_M24()) / w)), +((((((+matrix.get_M31() * +vector.x) + (+matrix.get_M32() * +vector.y)) + (+matrix.get_M33() * +vector.z)) + +matrix.get_M34()) / w)));
  }; 

  function float4x4_TransformPremult (vector, matrix) {
    return $S01().Construct(((((+matrix.get_M11() * +vector.x) + (+matrix.get_M21() * +vector.y)) + (+matrix.get_M31() * +vector.z)) + (+matrix.get_M41() * +vector.w)), ((((+matrix.get_M12() * +vector.x) + (+matrix.get_M22() * +vector.y)) + (+matrix.get_M32() * +vector.z)) + (+matrix.get_M42() * +vector.w)), ((((+matrix.get_M13() * +vector.x) + (+matrix.get_M23() * +vector.y)) + (+matrix.get_M33() * +vector.z)) + (+matrix.get_M43() * +vector.w)), ((((+matrix.get_M14() * +vector.x) + (+matrix.get_M24() * +vector.y)) + (+matrix.get_M34() * +vector.z)) + (+matrix.get_M44() * +vector.w)));
  }; 

  function float4x4_TransformPremultPD (vector, matrix) {
    var w = (((+matrix.get_M14() * +vector.x) + (+matrix.get_M24() * +vector.y)) + (+matrix.get_M34() * +vector.z)) + +matrix.get_M44();
    return $S05().Construct(+((((((+matrix.get_M11() * +vector.x) + (+matrix.get_M21() * +vector.y)) + (+matrix.get_M31() * +vector.z)) + +matrix.get_M41()) / w)), +((((((+matrix.get_M12() * +vector.x) + (+matrix.get_M22() * +vector.y)) + (+matrix.get_M32() * +vector.z)) + +matrix.get_M42()) / w)), +((((((+matrix.get_M13() * +vector.x) + (+matrix.get_M23() * +vector.y)) + (+matrix.get_M33() * +vector.z)) + +matrix.get_M43()) / w)));
  }; 

  function float4x4_Transpose$38 () {
    JSIL.CopyMembers($thisType.Transpose(this), this);
  }; 

  function float4x4_Transpose$39 (mat) {
    return $S00().Construct(mat.get_Column0().MemberwiseClone(), mat.get_Column1().MemberwiseClone(), mat.get_Column2().MemberwiseClone(), mat.get_Column3().MemberwiseClone());
  }; 

  function float4x4_Transpose$3A (/* ref */ mat, /* ref */ result) {
    result.get().Row0 = (mat.get()).get_Column0().MemberwiseClone();
    result.get().Row1 = (mat.get()).get_Column1().MemberwiseClone();
    result.get().Row2 = (mat.get()).get_Column2().MemberwiseClone();
    result.get().Row3 = (mat.get()).get_Column3().MemberwiseClone();
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.Core.float4x4", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 16, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm07.TypeRef("Fusee.Math.Core.float4"), $asm07.TypeRef("Fusee.Math.Core.float4"), 
          $asm07.TypeRef("Fusee.Math.Core.float4"), $asm07.TypeRef("Fusee.Math.Core.float4")
        ]), 
      float4x4__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single
        ]), 
      float4x4__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.double4x4")), 
      float4x4__ctor$02
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4x4_Add
    );

    $.Method({Static:true , Public:true }, "CreateFromAxisAngle", 
      new JSIL.MethodSignature(null, [
          $asm07.TypeRef("Fusee.Math.Core.float3"), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreateFromAxisAngle$03
    );

    $.Method({Static:true , Public:true }, "CreateFromAxisAngle", 
      new JSIL.MethodSignature($.Type, [$asm07.TypeRef("Fusee.Math.Core.float3"), $.Single]), 
      float4x4_CreateFromAxisAngle$04
    );

    $.Method({Static:true , Public:true }, "CreateOrthographic", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreateOrthographic$05
    );

    $.Method({Static:true , Public:true }, "CreateOrthographic", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single, $.Single
        ]), 
      float4x4_CreateOrthographic$06
    );

    $.Method({Static:true , Public:true }, "CreateOrthographicOffCenter", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreateOrthographicOffCenter$07
    );

    $.Method({Static:true , Public:true }, "CreateOrthographicOffCenter", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single
        ]), 
      float4x4_CreateOrthographicOffCenter$08
    );

    $.Method({Static:true , Public:true }, "CreateOrthographicOffCenterRH", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreateOrthographicOffCenterRH
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreatePerspectiveFieldOfView$09
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single, $.Single
        ]), 
      float4x4_CreatePerspectiveFieldOfView$0A
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView_ROW", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreatePerspectiveFieldOfView_ROW$0B
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView_ROW", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single, $.Single
        ]), 
      float4x4_CreatePerspectiveFieldOfView_ROW$0C
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenter", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreatePerspectiveOffCenter$0D
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenter", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single
        ]), 
      float4x4_CreatePerspectiveOffCenter$0E
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenter_ROW", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreatePerspectiveOffCenter_ROW
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenterRH", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreatePerspectiveOffCenterRH
    );

    $.Method({Static:true , Public:true }, "CreateRotationX", 
      new JSIL.MethodSignature(null, [$.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float4x4_CreateRotationX$0F
    );

    $.Method({Static:true , Public:true }, "CreateRotationX", 
      new JSIL.MethodSignature($.Type, [$.Single]), 
      float4x4_CreateRotationX$10
    );

    $.Method({Static:true , Public:true }, "CreateRotationX_ROW", 
      new JSIL.MethodSignature(null, [$.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float4x4_CreateRotationX_ROW$11
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationX_ROW", 
      new JSIL.MethodSignature($.Type, [$.Single]), 
      float4x4_CreateRotationX_ROW$12
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationY", 
      new JSIL.MethodSignature(null, [$.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float4x4_CreateRotationY$13
    );

    $.Method({Static:true , Public:true }, "CreateRotationY", 
      new JSIL.MethodSignature($.Type, [$.Single]), 
      float4x4_CreateRotationY$14
    );

    $.Method({Static:true , Public:true }, "CreateRotationY_ROW", 
      new JSIL.MethodSignature(null, [$.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float4x4_CreateRotationY_ROW$15
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationY_ROW", 
      new JSIL.MethodSignature($.Type, [$.Single]), 
      float4x4_CreateRotationY_ROW$16
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationZ", 
      new JSIL.MethodSignature(null, [$.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float4x4_CreateRotationZ$17
    );

    $.Method({Static:true , Public:true }, "CreateRotationZ", 
      new JSIL.MethodSignature($.Type, [$.Single]), 
      float4x4_CreateRotationZ$18
    );

    $.Method({Static:true , Public:true }, "CreateScale", 
      new JSIL.MethodSignature(null, [$.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float4x4_CreateScale$19
    );

    $.Method({Static:true , Public:true }, "CreateScale", 
      new JSIL.MethodSignature($.Type, [$.Single]), 
      float4x4_CreateScale$1A
    );

    $.Method({Static:true , Public:true }, "CreateScale", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreateScale$1B
    );

    $.Method({Static:true , Public:true }, "CreateScale", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float3")]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float4x4_CreateScale$1C
    );

    $.Method({Static:true , Public:true }, "CreateScale", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single
        ]), 
      float4x4_CreateScale$1D
    );

    $.Method({Static:true , Public:true }, "CreateScale", 
      new JSIL.MethodSignature($.Type, [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
      float4x4_CreateScale$1E
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreateTranslation$1F
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float3")]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float4x4_CreateTranslation$20
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single
        ]), 
      float4x4_CreateTranslation$21
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature($.Type, [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
      float4x4_CreateTranslation$22
    );

    $.Method({Static:true , Public:true }, "CreateTranslation_ROW", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreateTranslation_ROW$23
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateTranslation_ROW", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single
        ]), 
      float4x4_CreateTranslation_ROW$24
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      float4x4_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type]), 
      float4x4_Equals$25
    );

    $.Method({Static:false, Public:true }, "get_Column0", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float4")), 
      float4x4_get_Column0
    );

    $.Method({Static:false, Public:true }, "get_Column1", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float4")), 
      float4x4_get_Column1
    );

    $.Method({Static:false, Public:true }, "get_Column2", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float4")), 
      float4x4_get_Column2
    );

    $.Method({Static:false, Public:true }, "get_Column3", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float4")), 
      float4x4_get_Column3
    );

    $.Method({Static:false, Public:true }, "get_Determinant", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_Determinant
    );

    $.Method({Static:false, Public:true }, "get_IsAffine", 
      JSIL.MethodSignature.Return($.Boolean), 
      float4x4_get_IsAffine
    );

    $.Method({Static:false, Public:true }, "get_M11", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M11
    );

    $.Method({Static:false, Public:true }, "get_M12", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M12
    );

    $.Method({Static:false, Public:true }, "get_M13", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M13
    );

    $.Method({Static:false, Public:true }, "get_M14", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M14
    );

    $.Method({Static:false, Public:true }, "get_M21", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M21
    );

    $.Method({Static:false, Public:true }, "get_M22", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M22
    );

    $.Method({Static:false, Public:true }, "get_M23", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M23
    );

    $.Method({Static:false, Public:true }, "get_M24", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M24
    );

    $.Method({Static:false, Public:true }, "get_M31", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M31
    );

    $.Method({Static:false, Public:true }, "get_M32", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M32
    );

    $.Method({Static:false, Public:true }, "get_M33", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M33
    );

    $.Method({Static:false, Public:true }, "get_M34", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M34
    );

    $.Method({Static:false, Public:true }, "get_M41", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M41
    );

    $.Method({Static:false, Public:true }, "get_M42", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M42
    );

    $.Method({Static:false, Public:true }, "get_M43", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M43
    );

    $.Method({Static:false, Public:true }, "get_M44", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M44
    );

    $.Method({Static:false, Public:true }, "get_Offset", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float3")), 
      float4x4_get_Offset
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type])), 
      float4x4_get_Parse
    )
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      float4x4_GetHashCode
    );

    $.Method({Static:false, Public:true }, "Invert", 
      JSIL.MethodSignature.Void, 
      float4x4_Invert$26
    );

    $.Method({Static:true , Public:true }, "Invert", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float4x4_Invert$27
    );

    $.Method({Static:true , Public:true }, "InvertAffine", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float4x4_InvertAffine
    );

    $.Method({Static:true , Public:true }, "LookAt", 
      new JSIL.MethodSignature($.Type, [
          $asm07.TypeRef("Fusee.Math.Core.float3"), $asm07.TypeRef("Fusee.Math.Core.float3"), 
          $asm07.TypeRef("Fusee.Math.Core.float3")
        ]), 
      float4x4_LookAt$28
    );

    $.Method({Static:true , Public:true }, "LookAt", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single
        ]), 
      float4x4_LookAt$29
    );

    $.Method({Static:true , Public:true }, "LookAt_ROW", 
      new JSIL.MethodSignature($.Type, [
          $asm07.TypeRef("Fusee.Math.Core.float3"), $asm07.TypeRef("Fusee.Math.Core.float3"), 
          $asm07.TypeRef("Fusee.Math.Core.float3")
        ]), 
      float4x4_LookAt_ROW$2A
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "LookAt_ROW", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single
        ]), 
      float4x4_LookAt_ROW$2B
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "LookAtRH", 
      new JSIL.MethodSignature($.Type, [
          $asm07.TypeRef("Fusee.Math.Core.float3"), $asm07.TypeRef("Fusee.Math.Core.float3"), 
          $asm07.TypeRef("Fusee.Math.Core.float3")
        ]), 
      float4x4_LookAtRH
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4x4_Mult$2C
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_Mult$2D
    );

    $.Method({Static:true , Public:true }, "MultAffine", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_MultAffine
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4x4_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      float4x4_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Explicit", 
      new JSIL.MethodSignature($.Type, [$asm07.TypeRef("Fusee.Math.Core.double4x4")]), 
      float4x4_op_Explicit
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      float4x4_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4x4_op_Multiply$2E
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float4"), [$.Type, $asm07.TypeRef("Fusee.Math.Core.float4")]), 
      float4x4_op_Multiply$2F
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float4"), [$asm07.TypeRef("Fusee.Math.Core.float4"), $.Type]), 
      float4x4_op_Multiply$30
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [$.Type, $asm07.TypeRef("Fusee.Math.Core.float3")]), 
      float4x4_op_Multiply$31
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [$asm07.TypeRef("Fusee.Math.Core.float3"), $.Type]), 
      float4x4_op_Multiply$32
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4x4_op_Subtraction
    );

    $.Method({Static:false, Public:true }, "Round", 
      JSIL.MethodSignature.Void, 
      float4x4_Round$33
    );

    $.Method({Static:true , Public:true }, "Round", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float4x4_Round$34
    );

    $.Method({Static:true , Public:true }, "Scale", 
      new JSIL.MethodSignature($.Type, [$.Single]), 
      float4x4_Scale$35
    );

    $.Method({Static:true , Public:true }, "Scale", 
      new JSIL.MethodSignature($.Type, [$asm07.TypeRef("Fusee.Math.Core.float3")]), 
      float4x4_Scale$36
    );

    $.Method({Static:true , Public:true }, "Scale", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single
        ]), 
      float4x4_Scale$37
    );

    $.Method({Static:false, Public:true }, "set_M11", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M11
    );

    $.Method({Static:false, Public:true }, "set_M12", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M12
    );

    $.Method({Static:false, Public:true }, "set_M13", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M13
    );

    $.Method({Static:false, Public:true }, "set_M14", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M14
    );

    $.Method({Static:false, Public:true }, "set_M21", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M21
    );

    $.Method({Static:false, Public:true }, "set_M22", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M22
    );

    $.Method({Static:false, Public:true }, "set_M23", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M23
    );

    $.Method({Static:false, Public:true }, "set_M24", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M24
    );

    $.Method({Static:false, Public:true }, "set_M31", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M31
    );

    $.Method({Static:false, Public:true }, "set_M32", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M32
    );

    $.Method({Static:false, Public:true }, "set_M33", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M33
    );

    $.Method({Static:false, Public:true }, "set_M34", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M34
    );

    $.Method({Static:false, Public:true }, "set_M41", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M41
    );

    $.Method({Static:false, Public:true }, "set_M42", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M42
    );

    $.Method({Static:false, Public:true }, "set_M43", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M43
    );

    $.Method({Static:false, Public:true }, "set_M44", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M44
    );

    $.Method({Static:true , Public:true }, "set_Parse", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type])), 
      float4x4_set_Parse
    )
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:true , Public:true }, "Substract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4x4_Substract
    );

    $.Method({Static:false, Public:false}, "ToArray", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Single])), 
      float4x4_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      float4x4_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float4"), [$.Type, $asm07.TypeRef("Fusee.Math.Core.float4")]), 
      float4x4_Transform
    );

    $.Method({Static:true , Public:true }, "TransformPD", 
      new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [$.Type, $asm07.TypeRef("Fusee.Math.Core.float3")]), 
      float4x4_TransformPD
    );

    $.Method({Static:true , Public:true }, "TransformPremult", 
      new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float4"), [$asm07.TypeRef("Fusee.Math.Core.float4"), $.Type]), 
      float4x4_TransformPremult
    );

    $.Method({Static:true , Public:true }, "TransformPremultPD", 
      new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [$asm07.TypeRef("Fusee.Math.Core.float3"), $.Type]), 
      float4x4_TransformPremultPD
    );

    $.Method({Static:false, Public:true }, "Transpose", 
      JSIL.MethodSignature.Void, 
      float4x4_Transpose$38
    );

    $.Method({Static:true , Public:true }, "Transpose", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float4x4_Transpose$39
    );

    $.Method({Static:true , Public:true }, "Transpose", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float4x4_Transpose$3A
    );

    $.Field({Static:false, Public:true }, "Row0", $asm07.TypeRef("Fusee.Math.Core.float4"))
      .Attribute($asm0F.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [1]; });

    $.Field({Static:false, Public:true }, "Row1", $asm07.TypeRef("Fusee.Math.Core.float4"))
      .Attribute($asm0F.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [2]; });

    $.Field({Static:false, Public:true }, "Row2", $asm07.TypeRef("Fusee.Math.Core.float4"))
      .Attribute($asm0F.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [3]; });

    $.Field({Static:false, Public:true }, "Row3", $asm07.TypeRef("Fusee.Math.Core.float4"))
      .Attribute($asm0F.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [4]; });

    $.Field({Static:true , Public:true }, "Identity", $.Type);

    $.Field({Static:true , Public:true }, "Zero", $.Type);

    $.Field({Static:true , Public:false}, "float4x4$Parse$value", $asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type]))
      .Attribute($asm15.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"))
      .Attribute($asm15.TypeRef("System.Diagnostics.DebuggerBrowsableAttribute"), function () { return [$asm15.System.Diagnostics.DebuggerBrowsableState.Never]; });


    function float4x4__cctor () {
      $thisType.Identity = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.Identity = $S00().Construct($T00().UnitX.MemberwiseClone(), $T00().UnitY.MemberwiseClone(), $T00().UnitZ.MemberwiseClone(), $T00().UnitW.MemberwiseClone());
      $thisType.Zero = $S00().Construct($T00().Zero.MemberwiseClone(), $T00().Zero.MemberwiseClone(), $T00().Zero.MemberwiseClone(), $T00().Zero.MemberwiseClone());
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      float4x4__cctor
    );

    $.Property({Static:false, Public:true }, "Determinant", $.Single);

    $.Property({Static:false, Public:true }, "Column0", $asm07.TypeRef("Fusee.Math.Core.float4"));

    $.Property({Static:false, Public:true }, "Column1", $asm07.TypeRef("Fusee.Math.Core.float4"));

    $.Property({Static:false, Public:true }, "Column2", $asm07.TypeRef("Fusee.Math.Core.float4"));

    $.Property({Static:false, Public:true }, "Column3", $asm07.TypeRef("Fusee.Math.Core.float4"));

    $.Property({Static:false, Public:true }, "M11", $.Single);

    $.Property({Static:false, Public:true }, "M12", $.Single);

    $.Property({Static:false, Public:true }, "M13", $.Single);

    $.Property({Static:false, Public:true }, "M14", $.Single);

    $.Property({Static:false, Public:true }, "M21", $.Single);

    $.Property({Static:false, Public:true }, "M22", $.Single);

    $.Property({Static:false, Public:true }, "M23", $.Single);

    $.Property({Static:false, Public:true }, "M24", $.Single);

    $.Property({Static:false, Public:true }, "M31", $.Single);

    $.Property({Static:false, Public:true }, "M32", $.Single);

    $.Property({Static:false, Public:true }, "M33", $.Single);

    $.Property({Static:false, Public:true }, "M34", $.Single);

    $.Property({Static:false, Public:true }, "M41", $.Single);

    $.Property({Static:false, Public:true }, "M42", $.Single);

    $.Property({Static:false, Public:true }, "M43", $.Single);

    $.Property({Static:false, Public:true }, "M44", $.Single);

    $.Property({Static:false, Public:true }, "Offset", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "IsAffine", $.Boolean);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("Fusee.Math.Core.Converter`2", [$.String, $.Type]));

    $.ImplementInterfaces(
      /* 0 */ $asm15.TypeRef("System.IEquatable`1", [$.Type])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("ProtoBuf.ProtoContractAttribute"));

})();

/* delegate Fusee.Math.Core.Converter`2 */ 

JSIL.MakeDelegate("Fusee.Math.Core.Converter`2", true, ["in TInput", "out TOutput"], 
  new JSIL.MethodSignature(new JSIL.GenericParameter("TOutput", "Fusee.Math.Core.Converter`2").out(), [new JSIL.GenericParameter("TInput", "Fusee.Math.Core.Converter`2").in()]));

/* class Fusee.Math.Core.M */ 

(function M$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm15.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm15.System.Int64)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm15.System.Double)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm15.System.Single)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm15.System.Math)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm07.Fusee.Math.Core.float4)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm15.System.UInt32)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm15.System.Int16)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm15.System.UInt16)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm15.System.ArgumentOutOfRangeException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm15.TypeRef("System.Single"), [$asm15.TypeRef("System.Single")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm15.TypeRef("System.ArgumentOutOfRangeException"), [$asm15.TypeRef("System.String"), $asm15.TypeRef("System.String")]))) ();
  };


  function M_BinomialCoefficient (n, k) {
    return $T01().op_Division(
      $thisType.Factorial(n), 
      $T01().op_Multiplication(
        $thisType.Factorial(k), 
        $thisType.Factorial((((n | 0) - (k | 0)) | 0))
      )
    );
  }; 

  function M_Clamp$00 (val, min, max) {
    return (
      (+val < +min)
         ? min
         : (
          (+val > +max)
             ? max
             : val)
    )
    ;
  }; 

  function M_Clamp$01 (val, min, max) {
    return (
      (+val < +min)
         ? min
         : (
          (+val > +max)
             ? max
             : val)
    )
    ;
  }; 

  function M_Cos (val) {
    return Math.fround(Math.cos(val));
  }; 

  function M_DegreesToRadians (degrees) {
    return (+degrees * 0.0174532924);
  }; 

  function M_Equals$02 (a, b) {
    return ((Math.abs((+a - +b))) < 1.11022302462516E-16);
  }; 

  function M_Equals$03 (a, b) {
    return ((Math.abs((+a - +b))) < 1.192093E-07);
  }; 

  function M_Factorial (n) {
    var result = $T01().Create(1, 0, 0);

    while ((n | 0) > 1) {
      result = $T01().op_Multiplication(result, $T01().FromNumber(n));
      n = (((n | 0) - 1) | 0);
    }
    return result;
  }; 

  function M_Float4ToABGR (value) {
    var r = ((255 * +value.x) | 0);
    var g = ((255 * +value.y) | 0);
    var b = ((255 * +value.z) | 0);
    var a = ((255 * +value.w) | 0);
    return (((((((a << 24) + (b << 16)) >>> 0) + (g << 8)) >>> 0) + r) >>> 0);
  }; 

  function M_InverseSqrtFast$04 (x) {
    return Math.fround(+(1 / (Math.sqrt(x))));
  }; 

  function M_InverseSqrtFast$05 (x) {
    return $S00().CallStatic($thisType, "InverseSqrtFast", null, Math.fround(x));
  }; 

  function M_IsPowerOfTwo (val) {
    return (((val | 0) & (((val | 0) - 1) | 0)) === 0);
  }; 

  function M_Max$06 (a, b) {
    return (
      (+a > +b)
         ? a
         : b)
    ;
  }; 

  function M_Max$07 (a, b) {
    return (
      (+a > +b)
         ? a
         : b)
    ;
  }; 

  function M_Max$08 (a, b) {
    return (
      ((a | 0) > (b | 0))
         ? a
         : b)
    ;
  }; 

  function M_Max$09 (a, b) {
    return (
      ((a >>> 0) > (b >>> 0))
         ? a
         : b)
    ;
  }; 

  function M_Max$0A (a, b) {
    return (
      ((a | 0) > (b | 0))
         ? a
         : b)
    ;
  }; 

  function M_Max$0B (a, b) {
    return (
      ((a | 0) > (b | 0))
         ? a
         : b)
    ;
  }; 

  function M_Min$0C (a, b) {
    return (
      (+a < +b)
         ? a
         : b)
    ;
  }; 

  function M_Min$0D (a, b) {
    return (
      (+a < +b)
         ? a
         : b)
    ;
  }; 

  function M_Min$0E (a, b) {
    return (
      ((a | 0) < (b | 0))
         ? a
         : b)
    ;
  }; 

  function M_Min$0F (a, b) {
    return (
      ((a >>> 0) < (b >>> 0))
         ? a
         : b)
    ;
  }; 

  function M_Min$10 (a, b) {
    return (
      ((a | 0) < (b | 0))
         ? a
         : b)
    ;
  }; 

  function M_Min$11 (a, b) {
    return (
      ((a | 0) < (b | 0))
         ? a
         : b)
    ;
  }; 

  function M_MinAngle$12 (angle) {

    for (; +angle > 3.14159274; angle -= 6.28318548) {
    }

    for (; +angle <= -3.14159274; angle += 6.28318548) {
    }
    return angle;
  }; 

  function M_MinAngle$13 (angle) {

    for (; +angle > 3.1415926535897931; angle -= 6.2831853071795862) {
    }

    for (; +angle <= -3.1415927410125732; angle += 6.2831853071795862) {
    }
    return angle;
  }; 

  function M_NextPowerOfTwo$14 (n) {
    if ($T01().op_LessThan(n, $T01().Create(0, 0, 0))) {
      throw $S01().Construct("n", "Must be positive.");
    }
    return $T01().FromNumber(Math.pow(2, Math.ceil((Math.log(n.ToNumber(-1, false)) / Math.log(2)))));
  }; 

  function M_NextPowerOfTwo$15 (n) {
    if ((n | 0) < 0) {
      throw $S01().Construct("n", "Must be positive.");
    }
    return ((Math.pow(2, Math.ceil((Math.log(+n) / Math.log(2))))) | 0);
  }; 

  function M_NextPowerOfTwo$16 (n) {
    if (+n < 0) {
      throw $S01().Construct("n", "Must be positive.");
    }
    return Math.fround(Math.pow(2, Math.ceil((Math.log(n) / Math.log(2)))));
  }; 

  function M_NextPowerOfTwo$17 (n) {
    if (+n < 0) {
      throw $S01().Construct("n", "Must be positive.");
    }
    return Math.pow(2, Math.ceil((Math.log(n) / Math.log(2))));
  }; 

  function M_RadiansToDegrees (radians) {
    return (+radians * 57.2957764);
  }; 

  function M_Sin (val) {
    return Math.fround(Math.sin(val));
  }; 

  function M_Swap$18 (/* ref */ a, /* ref */ b) {
    var temp = +a.get();
    a.set(b.get());
    b.set(temp);
  }; 

  function M_Swap$19 (/* ref */ a, /* ref */ b) {
    var temp = +a.get();
    a.set(b.get());
    b.set(temp);
  }; 

  JSIL.MakeStaticClass("Fusee.Math.Core.M", true, [], function ($ib) {
    $ = $ib;

    $.Method({Static:true , Public:true }, "BinomialCoefficient", 
      new JSIL.MethodSignature($.Int64, [$.Int32, $.Int32]), 
      M_BinomialCoefficient
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Double, [
          $.Double, $.Double, 
          $.Double
        ]), 
      M_Clamp$00
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Single, [
          $.Single, $.Single, 
          $.Single
        ]), 
      M_Clamp$01
    );

    $.Method({Static:true , Public:true }, "Cos", 
      new JSIL.MethodSignature($.Single, [$.Single]), 
      M_Cos
    );

    $.Method({Static:true , Public:true }, "DegreesToRadians", 
      new JSIL.MethodSignature($.Single, [$.Single]), 
      M_DegreesToRadians
    );

    $.Method({Static:true , Public:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Double, $.Double]), 
      M_Equals$02
    );

    $.Method({Static:true , Public:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Single, $.Single]), 
      M_Equals$03
    );

    $.Method({Static:true , Public:true }, "Factorial", 
      new JSIL.MethodSignature($.Int64, [$.Int32]), 
      M_Factorial
    );

    $.Method({Static:true , Public:true }, "Float4ToABGR", 
      new JSIL.MethodSignature($.UInt32, [$asm07.TypeRef("Fusee.Math.Core.float4")]), 
      M_Float4ToABGR
    );

    $.Method({Static:true , Public:true }, "InverseSqrtFast", 
      new JSIL.MethodSignature($.Single, [$.Single]), 
      M_InverseSqrtFast$04
    );

    $.Method({Static:true , Public:true }, "InverseSqrtFast", 
      new JSIL.MethodSignature($.Double, [$.Double]), 
      M_InverseSqrtFast$05
    );

    $.Method({Static:true , Public:true }, "IsPowerOfTwo", 
      new JSIL.MethodSignature($.Boolean, [$.Int32]), 
      M_IsPowerOfTwo
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.Single, [$.Single, $.Single]), 
      M_Max$06
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.Double, [$.Double, $.Double]), 
      M_Max$07
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.Int32, [$.Int32, $.Int32]), 
      M_Max$08
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.UInt32, [$.UInt32, $.UInt32]), 
      M_Max$09
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.Int16, [$.Int16, $.Int16]), 
      M_Max$0A
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.UInt16, [$.UInt16, $.UInt16]), 
      M_Max$0B
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.Single, [$.Single, $.Single]), 
      M_Min$0C
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.Double, [$.Double, $.Double]), 
      M_Min$0D
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.Int32, [$.Int32, $.Int32]), 
      M_Min$0E
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.UInt32, [$.UInt32, $.UInt32]), 
      M_Min$0F
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.Int16, [$.Int16, $.Int16]), 
      M_Min$10
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.UInt16, [$.UInt16, $.UInt16]), 
      M_Min$11
    );

    $.Method({Static:true , Public:true }, "MinAngle", 
      new JSIL.MethodSignature($.Single, [$.Single]), 
      M_MinAngle$12
    );

    $.Method({Static:true , Public:true }, "MinAngle", 
      new JSIL.MethodSignature($.Double, [$.Double]), 
      M_MinAngle$13
    );

    $.Method({Static:true , Public:true }, "NextPowerOfTwo", 
      new JSIL.MethodSignature($.Int64, [$.Int64]), 
      M_NextPowerOfTwo$14
    );

    $.Method({Static:true , Public:true }, "NextPowerOfTwo", 
      new JSIL.MethodSignature($.Int32, [$.Int32]), 
      M_NextPowerOfTwo$15
    );

    $.Method({Static:true , Public:true }, "NextPowerOfTwo", 
      new JSIL.MethodSignature($.Single, [$.Single]), 
      M_NextPowerOfTwo$16
    );

    $.Method({Static:true , Public:true }, "NextPowerOfTwo", 
      new JSIL.MethodSignature($.Double, [$.Double]), 
      M_NextPowerOfTwo$17
    );

    $.Method({Static:true , Public:true }, "RadiansToDegrees", 
      new JSIL.MethodSignature($.Single, [$.Single]), 
      M_RadiansToDegrees
    );

    $.Method({Static:true , Public:true }, "Sin", 
      new JSIL.MethodSignature($.Single, [$.Single]), 
      M_Sin
    );

    $.Method({Static:true , Public:true }, "Swap", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Double]), $jsilcore.TypeRef("JSIL.Reference", [$.Double])]), 
      M_Swap$18
    );

    $.Method({Static:true , Public:true }, "Swap", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Single]), $jsilcore.TypeRef("JSIL.Reference", [$.Single])]), 
      M_Swap$19
    );

    $.Constant({Static:true , Public:true }, "EpsilonFloat", $.Single, 1.192093E-07);

    $.Constant({Static:true , Public:true }, "EpsilonDouble", $.Double, 1.11022302462516E-16);

    $.Constant({Static:true , Public:true }, "Pi", $.Single, 3.14159274);

    $.Constant({Static:true , Public:true }, "PiOver2", $.Single, 1.57079637);

    $.Constant({Static:true , Public:true }, "PiOver3", $.Single, 1.04719758);

    $.Constant({Static:true , Public:true }, "PiOver4", $.Single, 0.7853982);

    $.Constant({Static:true , Public:true }, "PiOver6", $.Single, 0.5235988);

    $.Constant({Static:true , Public:true }, "TwoPi", $.Single, 6.28318548);

    $.Constant({Static:true , Public:true }, "ThreePiOver2", $.Single, 4.712389);

    $.Constant({Static:true , Public:true }, "E", $.Single, 2.71828175);

    $.Constant({Static:true , Public:true }, "Log10E", $.Single, 0.4342945);

    $.Constant({Static:true , Public:true }, "Log2E", $.Single, 1.442695);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Math.Core.MathHelper */ 

(function MathHelper$Members () {
  var $, $thisType;

  JSIL.MakeStaticClass("Fusee.Math.Core.MathHelper", true, [], function ($ib) {
    $ = $ib;

    $.Constant({Static:true , Public:true }, "PiOver4", $.Single, 0.7853982)
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"));


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm15.TypeRef("System.ObsoleteAttribute"));

})();

/* struct Fusee.Math.Core.QuaternionD */ 

(function QuaternionD$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.Fusee.Math.Core.double3)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm15.System.Double)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm15.System.Object)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm15.System.Boolean)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm15.System.Math)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm07.Fusee.Math.Core.double4)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm15.System.String)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.QuaternionD"), [
        $asm15.TypeRef("System.Double"), $asm15.TypeRef("System.Double"), 
        $asm15.TypeRef("System.Double"), $asm15.TypeRef("System.Double")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.double3"), [
        $asm15.TypeRef("System.Double"), $asm15.TypeRef("System.Double"), 
        $asm15.TypeRef("System.Double")
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.QuaternionD"), [$asm07.TypeRef("Fusee.Math.Core.double3"), $asm15.TypeRef("System.Double")]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.double3"), [$asm07.TypeRef("Fusee.Math.Core.double3"), $asm15.TypeRef("System.Double")]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.double3"), [$asm15.TypeRef("System.Double"), $asm07.TypeRef("Fusee.Math.Core.double3")]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.QuaternionD")]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.QuaternionD")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.QuaternionD")])
      ]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.QuaternionD")]), $asm15.TypeRef("System.Double"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.QuaternionD")])
      ]))) ();
  };


  function QuaternionD__ctor$00 (v, w) {
    this._xyz = v.MemberwiseClone();
    this._w = +w;
  }; 

  function QuaternionD__ctor$01 (xx, yy, zz, w) {
    $thisType.prototype._ctor.call(this, $S01().Construct(xx, yy, zz), w);
  }; 

  function QuaternionD_Add$02 (left, right) {
    return $S02().Construct($T00().op_Addition(
        left.get_xyz().MemberwiseClone(), 
        right.get_xyz()
      ).MemberwiseClone(), (+left.get_w() + +right.get_w()));
  }; 

  function QuaternionD_Add$03 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct($T00().op_Addition(
          (left.get()).get_xyz().MemberwiseClone(), 
          (right.get()).get_xyz()
        ).MemberwiseClone(), (+(left.get()).get_w() + +(right.get()).get_w())));
  }; 

  function QuaternionD_Conjugate$04 () {
    (this.xyz = $T00().op_UnaryNegation(this.get_xyz().MemberwiseClone()));
  }; 

  function QuaternionD_Conjugate$05 (q) {
    return $S02().Construct($T00().op_UnaryNegation(q.get_xyz().MemberwiseClone()).MemberwiseClone(), q.get_w());
  }; 

  function QuaternionD_Conjugate$06 (/* ref */ q, /* ref */ result) {
    result.set($S02().Construct($T00().op_UnaryNegation((q.get()).get_xyz().MemberwiseClone()).MemberwiseClone(), (q.get()).get_w()));
  }; 

  function QuaternionD_Object_Equals (other) {
    var flag = !$thisType.$Is(other);
    return (!flag && $thisType.op_Equality(this, $thisType.$Cast(other).MemberwiseClone()));
  }; 

  function QuaternionD_Equals$07 (other) {
    return ($T00().op_Equality(
        this.get_xyz(), 
        other.get_xyz()
      ) && ((Math.abs((+this.get_w() - +other.get_w()))) < 1.11022302462516E-16));
  }; 

  function QuaternionD_FromAxisAngle (axis, angle) {
    var flag = +axis.get_LengthSquared() > 1.11022302462516E-16;
    if (flag) {
      var result2 = $thisType.Identity.MemberwiseClone();
    } else {
      var result = $thisType.Identity.MemberwiseClone();
      angle *= 0.5;
      axis.Normalize();
      (result.xyz = $S03().CallStatic($T00(), "op_Multiply", null, axis.MemberwiseClone(), Math.sin(angle)));
      result.set_w(Math.cos(angle));
      result2 = $thisType.Normalize(result.MemberwiseClone()).MemberwiseClone();
    }
    return result2;
  }; 

  function QuaternionD_get_Length () {
    return Math.sqrt(((+this.get_w() * +this.get_w()) + +(this.get_xyz()).get_LengthSquared()));
  }; 

  function QuaternionD_get_LengthSquared () {
    return ((+this.get_w() * +this.get_w()) + +(this.get_xyz()).get_LengthSquared());
  }; 

  function QuaternionD_get_w () {
    return this._w;
  }; 

  function QuaternionD_get_x () {
    return this._xyz.x;
  }; 

  function QuaternionD_get_xyz () {
    return this._xyz;
  }; 

  function QuaternionD_get_y () {
    return this._xyz.y;
  }; 

  function QuaternionD_get_z () {
    return this._xyz.z;
  }; 

  function QuaternionD_GetHashCode () {
    return ((JSIL.ObjectHashCode(this.get_xyz(), !false, $T02().__Type__)) ^ ((this.get_w()).GetHashCode() | 0));
  }; 

  function QuaternionD_Invert$08 ($q) {
    var q = new JSIL.BoxedVariable($q.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Invert(/* ref */ q, /* ref */ result);
    return result.get();
  }; 

  function QuaternionD_Invert$09 (/* ref */ q, /* ref */ result) {
    var lengthSq = +(q.get()).get_LengthSquared();
    var flag = lengthSq > 1.11022302462516E-16;
    if (flag) {
      var i = +((1 / lengthSq));
      result.set($S02().Construct($S03().CallStatic($T00(), "op_Multiply", null, (q.get()).get_xyz().MemberwiseClone(), -i).MemberwiseClone(), (+(q.get()).get_w() * i)));
    } else {
      result.set(q.get().MemberwiseClone());
    }
  }; 

  function QuaternionD_Mult$0A (left, right) {
    return $S02().Construct($T00().op_Addition(
        $T00().op_Addition(
          $S04().CallStatic($T00(), "op_Multiply", null, 
            right.get_w(), 
            left.get_xyz().MemberwiseClone()
          ).MemberwiseClone(), 
          $S04().CallStatic($T00(), "op_Multiply", null, 
            left.get_w(), 
            right.get_xyz().MemberwiseClone()
          )
        ).MemberwiseClone(), 
        $T00().Cross(
          left.get_xyz().MemberwiseClone(), 
          right.get_xyz().MemberwiseClone()
        )
      ).MemberwiseClone(), ((+left.get_w() * +right.get_w()) - +$T00().Dot(
          left.get_xyz(), 
          right.get_xyz()
        )));
  }; 

  function QuaternionD_Mult$0B (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct($T00().op_Addition(
          $T00().op_Addition(
            $S04().CallStatic($T00(), "op_Multiply", null, 
              (right.get()).get_w(), 
              (left.get()).get_xyz().MemberwiseClone()
            ).MemberwiseClone(), 
            $S04().CallStatic($T00(), "op_Multiply", null, 
              (left.get()).get_w(), 
              (right.get()).get_xyz().MemberwiseClone()
            )
          ).MemberwiseClone(), 
          $T00().Cross(
            (left.get()).get_xyz().MemberwiseClone(), 
            (right.get()).get_xyz().MemberwiseClone()
          )
        ).MemberwiseClone(), ((+(left.get()).get_w() * +(right.get()).get_w()) - +$T00().Dot(
            (left.get()).get_xyz(), 
            (right.get()).get_xyz()
          ))));
  }; 

  function QuaternionD_Multiply$0C ($left, $right) {
    var right = new JSIL.BoxedVariable($right.MemberwiseClone());
    var left = new JSIL.BoxedVariable($left.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $S05().CallStatic($thisType, "Multiply", null, /* ref */ left, /* ref */ right, /* ref */ result);
    return result.get();
  }; 

  function QuaternionD_Multiply$0D (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S00().Construct(((((+(left.get()).get_w() * +(right.get()).get_x()) + (+(left.get()).get_x() * +(right.get()).get_w())) + (+(left.get()).get_y() * +(right.get()).get_z())) - (+(left.get()).get_z() * +(right.get()).get_y())), ((((+(left.get()).get_w() * +(right.get()).get_y()) + (+(left.get()).get_y() * +(right.get()).get_w())) + (+(left.get()).get_z() * +(right.get()).get_x())) - (+(left.get()).get_x() * +(right.get()).get_z())), ((((+(left.get()).get_w() * +(right.get()).get_z()) + (+(left.get()).get_z() * +(right.get()).get_w())) + (+(left.get()).get_x() * +(right.get()).get_y())) - (+(left.get()).get_y() * +(right.get()).get_x())), ((((+(left.get()).get_w() * +(right.get()).get_w()) - (+(left.get()).get_x() * +(right.get()).get_x())) - (+(left.get()).get_y() * +(right.get()).get_y())) - (+(left.get()).get_z() * +(right.get()).get_z()))));
  }; 

  function QuaternionD_Multiply$0E (/* ref */ quaternionD, scale, /* ref */ result) {
    result.set($S00().Construct((+(quaternionD.get()).get_x() * +scale), (+(quaternionD.get()).get_y() * +scale), (+(quaternionD.get()).get_z() * +scale), (+(quaternionD.get()).get_w() * +scale)));
  }; 

  function QuaternionD_Multiply$0F (quaternionD, scale) {
    return $S00().Construct((+quaternionD.get_x() * +scale), (+quaternionD.get_y() * +scale), (+quaternionD.get_z() * +scale), (+quaternionD.get_w() * +scale));
  }; 

  function QuaternionD_Normalize$10 () {
    var flag = +this.get_Length() <= 1.11022302462516E-16;
    if (!flag) {
      var scale = +((1 / +this.get_Length()));
      (this.xyz = $S03().CallStatic($T00(), "op_Multiply", null, this.get_xyz().MemberwiseClone(), scale));
      this.set_w(+this.get_w() * scale);
    }
  }; 

  function QuaternionD_Normalize$11 ($q) {
    var q = new JSIL.BoxedVariable($q);
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Normalize(/* ref */ q, /* ref */ result);
    return result.get();
  }; 

  function QuaternionD_Normalize$12 (/* ref */ q, /* ref */ result) {
    var flag = +(q.get()).get_Length() <= 1.1920930376163597E-07;
    if (flag) {
      var scale = 0;
    } else {
      scale = +((1 / +(q.get()).get_Length()));
    }
    result.set($S02().Construct($S03().CallStatic($T00(), "op_Multiply", null, (q.get()).get_xyz().MemberwiseClone(), scale).MemberwiseClone(), (+(q.get()).get_w() * scale)));
  }; 

  function QuaternionD_op_Addition (left, right) {
    (left.xyz = $T00().op_Addition(
        left.get_xyz().MemberwiseClone(), 
        right.get_xyz()
      ));
    left.set_w(+left.get_w() + +right.get_w());
    return left;
  }; 

  function QuaternionD_op_Equality (left, right) {
    return left.Equals(right.MemberwiseClone());
  }; 

  function QuaternionD_op_Inequality (left, right) {
    return !left.Equals(right.MemberwiseClone());
  }; 

  function QuaternionD_op_Multiply$13 ($left, $right) {
    var right = new JSIL.BoxedVariable($right.MemberwiseClone());
    var left = new JSIL.BoxedVariable($left.MemberwiseClone());
    $S05().CallStatic($thisType, "Multiply", null, /* ref */ left, /* ref */ right, /* ref */ left);
    return left.get();
  }; 

  function QuaternionD_op_Multiply$14 ($quaternionD, scale) {
    var quaternionD = new JSIL.BoxedVariable($quaternionD.MemberwiseClone());
    $S06().CallStatic($thisType, "Multiply", null, /* ref */ quaternionD, scale, /* ref */ quaternionD);
    return quaternionD.get();
  }; 

  function QuaternionD_op_Multiply$15 (scale, quaternionD) {
    return $S00().Construct((+quaternionD.get_x() * +scale), (+quaternionD.get_y() * +scale), (+quaternionD.get_z() * +scale), (+quaternionD.get_w() * +scale));
  }; 

  function QuaternionD_op_Subtraction (left, right) {
    (left.xyz = $T00().op_Subtraction(
        left.get_xyz().MemberwiseClone(), 
        right.get_xyz()
      ));
    left.set_w(+left.get_w() - +right.get_w());
    return left;
  }; 

  function QuaternionD_set_w (value) {
    this._w = +value;
  }; 

  function QuaternionD_set_x (value) {
    this._xyz.x = +value;
  }; 

  function QuaternionD_set_xyz (value) {
    this._xyz = value.MemberwiseClone();
  }; 

  function QuaternionD_set_y (value) {
    this._xyz.y = +value;
  }; 

  function QuaternionD_set_z (value) {
    this._xyz.z = +value;
  }; 

  function QuaternionD_Slerp (q1, q2, blend) {
    var result = new $thisType();
    var flag = +q1.get_LengthSquared() < 1.11022302462516E-16;
    if (flag) {
      var result2 = (
        (+q2.get_LengthSquared() <= 1.1920930376163597E-07)
           ? $thisType.Identity
           : q2)
      .MemberwiseClone();
    } else {
      var flag2 = +q2.get_LengthSquared() < 1.11022302462516E-16;
      if (flag2) {
        result2 = q1.MemberwiseClone();
      } else {
        var cosHalfAngle = (+q1.get_w() * +q2.get_w()) + +$T00().Dot(
          q1.get_xyz(), 
          q2.get_xyz()
        );
        var flag3 = (cosHalfAngle >= 1) || 
        (cosHalfAngle <= -1);
        if (flag3) {
          result2 = q1.MemberwiseClone();
        } else {
          var flag4 = cosHalfAngle < 0;
          if (flag4) {
            (q2.xyz = $T00().op_UnaryNegation(q2.get_xyz().MemberwiseClone()));
            q2.set_w(-q2.get_w());
            cosHalfAngle = -cosHalfAngle;
          }
          var flag5 = cosHalfAngle < 0.99000000953674316;
          if (flag5) {
            var halfAngle = (Math.acos(cosHalfAngle));
            var sinHalfAngle = (Math.sin(halfAngle));
            var oneOverSinHalfAngle = +((1 / sinHalfAngle));
            var blendA = (Math.sin((halfAngle * (1 - +blend)))) * oneOverSinHalfAngle;
            var blendB = (Math.sin((halfAngle * +blend))) * oneOverSinHalfAngle;
          } else {
            blendA = 1 - +blend;
            blendB = +blend;
          }
          (result = result.MemberwiseClone(), 
            $thisType.prototype._ctor.call(result, 
              $T00().op_Addition(
                $S04().CallStatic($T00(), "op_Multiply", null, blendA, q1.get_xyz().MemberwiseClone()).MemberwiseClone(), 
                $S04().CallStatic($T00(), "op_Multiply", null, blendB, q2.get_xyz().MemberwiseClone())
              ).MemberwiseClone(), 
              (blendA * +q1.get_w()) + (blendB * +q2.get_w())
            ));
          result2 = (
            (+result.get_LengthSquared() > 1.11022302462516E-16)
               ? $thisType.Normalize(result.MemberwiseClone())
               : $thisType.Identity)
          .MemberwiseClone();
        }
      }
    }
    return result2;
  }; 

  function QuaternionD_Sub$16 (left, right) {
    return $S02().Construct($T00().op_Subtraction(
        left.get_xyz().MemberwiseClone(), 
        right.get_xyz()
      ).MemberwiseClone(), (+left.get_w() - +right.get_w()));
  }; 

  function QuaternionD_Sub$17 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct($T00().op_Subtraction(
          (left.get()).get_xyz().MemberwiseClone(), 
          (right.get()).get_xyz()
        ).MemberwiseClone(), (+(left.get()).get_w() - +(right.get()).get_w())));
  }; 

  function QuaternionD_ToAxisAngle$18 (/* ref */ axis, /* ref */ angle) {
    var result = this.ToAxisAngle();
    axis.set(result.get_xyz().MemberwiseClone());
    angle.set(result.w);
  }; 

  function QuaternionD_ToAxisAngle$19 () {
    var q = this;
    var flag = +q.get_w() > 1;
    if (flag) {
      q.Normalize();
    }
    var double = new ($T05())();
    double.w = 2 * (Math.acos(q.get_w()));
    var result = double.MemberwiseClone();
    var den = (Math.sqrt((1 - (+q.get_w() * +q.get_w()))));
    if (den > 1.11022302462516E-16) {
      (result.xyz = $T00().op_Division(q.get_xyz().MemberwiseClone(), den));
    } else {
      (result.xyz = $T00().UnitX.MemberwiseClone());
    }
    return result;
  }; 

  function QuaternionD_toString () {
    return $T06().Format("V: {0}, w: {1}", JSIL.Array.New($T02(), [this.get_xyz(), $T01().$Box(this.get_w())]));
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.Core.QuaternionD", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 4, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("Fusee.Math.Core.double3"), $.Double]), 
      QuaternionD__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double
        ]), 
      QuaternionD__ctor$01
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      QuaternionD_Add$02
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      QuaternionD_Add$03
    );

    $.Method({Static:false, Public:true }, "Conjugate", 
      JSIL.MethodSignature.Void, 
      QuaternionD_Conjugate$04
    );

    $.Method({Static:true , Public:true }, "Conjugate", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      QuaternionD_Conjugate$05
    );

    $.Method({Static:true , Public:true }, "Conjugate", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      QuaternionD_Conjugate$06
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      QuaternionD_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type]), 
      QuaternionD_Equals$07
    );

    $.Method({Static:true , Public:true }, "FromAxisAngle", 
      new JSIL.MethodSignature($.Type, [$asm07.TypeRef("Fusee.Math.Core.double3"), $.Double]), 
      QuaternionD_FromAxisAngle
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      JSIL.MethodSignature.Return($.Double), 
      QuaternionD_get_Length
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      JSIL.MethodSignature.Return($.Double), 
      QuaternionD_get_LengthSquared
    );

    $.Method({Static:false, Public:true }, "get_w", 
      JSIL.MethodSignature.Return($.Double), 
      QuaternionD_get_w
    );

    $.Method({Static:false, Public:true }, "get_x", 
      JSIL.MethodSignature.Return($.Double), 
      QuaternionD_get_x
    );

    $.Method({Static:false, Public:true }, "get_xyz", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.double3")), 
      QuaternionD_get_xyz
    );

    $.Method({Static:false, Public:true }, "get_y", 
      JSIL.MethodSignature.Return($.Double), 
      QuaternionD_get_y
    );

    $.Method({Static:false, Public:true }, "get_z", 
      JSIL.MethodSignature.Return($.Double), 
      QuaternionD_get_z
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      QuaternionD_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Invert", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      QuaternionD_Invert$08
    );

    $.Method({Static:true , Public:true }, "Invert", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      QuaternionD_Invert$09
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      QuaternionD_Mult$0A
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use Multiply instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      QuaternionD_Mult$0B
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use Multiply instead."]; });

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      QuaternionD_Multiply$0C
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      QuaternionD_Multiply$0D
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      QuaternionD_Multiply$0E
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      QuaternionD_Multiply$0F
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      JSIL.MethodSignature.Void, 
      QuaternionD_Normalize$10
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      QuaternionD_Normalize$11
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      QuaternionD_Normalize$12
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      QuaternionD_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      QuaternionD_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      QuaternionD_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      QuaternionD_op_Multiply$13
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      QuaternionD_op_Multiply$14
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Double, $.Type]), 
      QuaternionD_op_Multiply$15
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      QuaternionD_op_Subtraction
    );

    $.Method({Static:false, Public:true }, "set_w", 
      JSIL.MethodSignature.Action($.Double), 
      QuaternionD_set_w
    );

    $.Method({Static:false, Public:true }, "set_x", 
      JSIL.MethodSignature.Action($.Double), 
      QuaternionD_set_x
    );

    $.Method({Static:false, Public:true }, "set_xyz", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.double3")), 
      QuaternionD_set_xyz
    );

    $.Method({Static:false, Public:true }, "set_y", 
      JSIL.MethodSignature.Action($.Double), 
      QuaternionD_set_y
    );

    $.Method({Static:false, Public:true }, "set_z", 
      JSIL.MethodSignature.Action($.Double), 
      QuaternionD_set_z
    );

    $.Method({Static:true , Public:true }, "Slerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Double
        ]), 
      QuaternionD_Slerp
    );

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      QuaternionD_Sub$16
    );

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      QuaternionD_Sub$17
    );

    $.Method({Static:false, Public:true }, "ToAxisAngle", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.double3")]), $jsilcore.TypeRef("JSIL.Reference", [$.Double])]), 
      QuaternionD_ToAxisAngle$18
    );

    $.Method({Static:false, Public:true }, "ToAxisAngle", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.double4")), 
      QuaternionD_ToAxisAngle$19
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      QuaternionD_toString
    );

    $.Field({Static:false, Public:false}, "_xyz", $asm07.TypeRef("Fusee.Math.Core.double3"));

    $.Field({Static:false, Public:false}, "_w", $.Double);

    $.Field({Static:true , Public:true }, "Identity", $.Type);


    function QuaternionD__cctor () {
      $thisType.Identity = new $thisType();
      $thisType.Identity = $S00().Construct(0, 0, 0, 1);
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      QuaternionD__cctor
    );

    $.Property({Static:false, Public:true }, "xyz", $asm07.TypeRef("Fusee.Math.Core.double3"));

    $.Property({Static:false, Public:true }, "x", $.Double);

    $.Property({Static:false, Public:true }, "y", $.Double);

    $.Property({Static:false, Public:true }, "z", $.Double);

    $.Property({Static:false, Public:true }, "w", $.Double);

    $.Property({Static:false, Public:true }, "Length", $.Double);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Double);

    $.ImplementInterfaces(
      /* 0 */ $asm15.TypeRef("System.IEquatable`1", [$.Type])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Math.Core.Quaternion */ 

(function Quaternion$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.Fusee.Math.Core.float3)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm15.System.Single)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm15.System.Math)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm15.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm15.System.Boolean)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm07.Fusee.Math.Core.M)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm15.System.Double)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize(System.Array.Of($asm07.Fusee.Math.Core.float3))) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm07.Fusee.Math.Core.float4x4)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm07.Fusee.Math.Core.float4)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm15.System.String)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.Quaternion"), [
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single")
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("Fusee.Math.Core.Quaternion"), [$asm07.TypeRef("Fusee.Math.Core.float3"), $asm15.TypeRef("System.Single")]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature($asm15.TypeRef("System.Int32"), [$asm15.TypeRef("System.Single")]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [$asm07.TypeRef("Fusee.Math.Core.float3"), $asm15.TypeRef("System.Single")]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [$asm15.TypeRef("System.Single"), $asm07.TypeRef("Fusee.Math.Core.float3")]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.Quaternion")]), $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.Quaternion")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.Quaternion")])
      ]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.Quaternion")]), $asm15.TypeRef("System.Single"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.Quaternion")])
      ]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature($asm15.TypeRef("System.Boolean"), [$asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single")]))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.MethodSignature($asm15.TypeRef("System.Single"), [
        $asm15.TypeRef("System.Single"), $asm15.TypeRef("System.Single"), 
        $asm15.TypeRef("System.Single")
      ]))) ();
  };


  function Quaternion__ctor$00 (v, w) {
    this._xyz = v.MemberwiseClone();
    this._w = +w;
  }; 

  function Quaternion__ctor$01 (xx, yy, zz, w) {
    $thisType.prototype._ctor.call(this, $S01().Construct(xx, yy, zz), w);
  }; 

  function Quaternion_Add$02 (left, right) {
    return $S02().Construct($T00().op_Addition(
        left.get_xyz().MemberwiseClone(), 
        right.get_xyz()
      ).MemberwiseClone(), (+left.get_w() + +right.get_w()));
  }; 

  function Quaternion_Add$03 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct($T00().op_Addition(
          (left.get()).get_xyz().MemberwiseClone(), 
          (right.get()).get_xyz()
        ).MemberwiseClone(), (+(left.get()).get_w() + +(right.get()).get_w())));
  }; 

  function Quaternion_Conjugate$04 () {
    (this.xyz = $T00().op_UnaryNegation(this.get_xyz().MemberwiseClone()));
  }; 

  function Quaternion_Conjugate$05 (q) {
    return $S02().Construct($T00().op_UnaryNegation(q.get_xyz().MemberwiseClone()).MemberwiseClone(), q.get_w());
  }; 

  function Quaternion_Conjugate$06 (/* ref */ q, /* ref */ result) {
    result.set($S02().Construct($T00().op_UnaryNegation((q.get()).get_xyz().MemberwiseClone()).MemberwiseClone(), (q.get()).get_w()));
  }; 

  function Quaternion_CopySign (a, b) {
    return ((Math.abs(a)) * +($S03().CallStatic($T02(), "Sign", null, b)));
  }; 

  function Quaternion_Object_Equals (other) {
    var flag = !$thisType.$Is(other);
    return (!flag && $thisType.op_Equality(this, $thisType.$Cast(other).MemberwiseClone()));
  }; 

  function Quaternion_Equals$07 (other) {
    return ($T00().op_Equality(
        this.get_xyz().MemberwiseClone(), 
        other.get_xyz().MemberwiseClone()
      ) && ((Math.abs((+this.get_w() - +other.get_w()))) < 1.192093E-07));
  }; 

  function Quaternion_EulerToQuaternion (e, inDegrees) {
    if (inDegrees) {
      var rX = +$T05().DegreesToRadians(e.x);
      var rY = +$T05().DegreesToRadians(e.y);
      var rZ = +$T05().DegreesToRadians(e.z);
      (e = e.MemberwiseClone(), 
        $T00().prototype._ctor.call(e, rX, rY, rZ));
    }
    e.y = 6.28318548 - +e.y;
    var s = Math.fround(Math.sin(+e.y * 0.5));
    var c = Math.fround(Math.cos(+e.y * 0.5));
    var s2 = Math.fround(Math.sin(+e.x * 0.5));
    var c2 = Math.fround(Math.cos(+e.x * 0.5));
    var s3 = Math.fround(Math.sin(+e.z * 0.5));
    var c3 = Math.fround(Math.cos(+e.z * 0.5));
    return $S00().Construct((((s * s2) * c3) + ((c * c2) * s3)), (((s * c2) * c3) + ((c * s2) * s3)), (((c * s2) * c3) - ((s * c2) * s3)), (((c * c2) * c3) - ((s * s2) * s3)));
  }; 

  function Quaternion_FromAxisAngle (axis, angle) {
    var flag = +axis.get_LengthSquared() > 1.192093E-07;
    if (flag) {
      var result2 = $thisType.Identity.MemberwiseClone();
    } else {
      var result = $thisType.Identity.MemberwiseClone();
      angle *= 0.5;
      axis.Normalize();
      (result.xyz = $S04().CallStatic($T00(), "op_Multiply", null, axis.MemberwiseClone(), Math.fround(Math.sin(angle))));
      result.set_w(Math.fround(Math.cos(angle)));
      result2 = $thisType.Normalize(result.MemberwiseClone()).MemberwiseClone();
    }
    return result2;
  }; 

  function Quaternion_get_Length () {
    return Math.fround(Math.sqrt((+this.get_w() * +this.get_w()) + +(this.get_xyz()).get_LengthSquared()));
  }; 

  function Quaternion_get_LengthSquared () {
    return ((+this.get_w() * +this.get_w()) + +(this.get_xyz()).get_LengthSquared());
  }; 

  function Quaternion_get_w () {
    return this._w;
  }; 

  function Quaternion_get_x () {
    return this._xyz.x;
  }; 

  function Quaternion_get_xyz () {
    return this._xyz;
  }; 

  function Quaternion_get_y () {
    return this._xyz.y;
  }; 

  function Quaternion_get_z () {
    return this._xyz.z;
  }; 

  function Quaternion_GetHashCode () {
    return ((JSIL.ObjectHashCode(this.get_xyz(), !false, $T03().__Type__)) ^ ((this.get_w()).GetHashCode() | 0));
  }; 

  function Quaternion_Invert$08 ($q) {
    var q = new JSIL.BoxedVariable($q.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Invert(/* ref */ q, /* ref */ result);
    return result.get();
  }; 

  function Quaternion_Invert$09 (/* ref */ q, /* ref */ result) {
    var lengthSq = +(q.get()).get_LengthSquared();
    var flag = lengthSq > 1.192093E-07;
    if (flag) {
      var i = +((1 / lengthSq));
      result.set($S02().Construct($S04().CallStatic($T00(), "op_Multiply", null, (q.get()).get_xyz().MemberwiseClone(), -i).MemberwiseClone(), (+(q.get()).get_w() * i)));
    } else {
      result.set(q.get().MemberwiseClone());
    }
  }; 

  function Quaternion_LookRotation (lookAt, upDirection) {
    var result = $T00().OrthoNormalize(lookAt.MemberwiseClone(), upDirection.MemberwiseClone());
    upDirection = result[1].MemberwiseClone();
    lookAt = result[0].MemberwiseClone();
    var right = $T00().Cross(upDirection.MemberwiseClone(), lookAt.MemberwiseClone()).MemberwiseClone();
    var w = Math.fround(Math.sqrt(((1 + +right.x) + +upDirection.y) + +lookAt.z)) * 0.5;
    var w4Recip = +((1 / (4 * w)));
    var x = (+upDirection.z - +lookAt.y) * w4Recip;
    var y = (+lookAt.x - +right.z) * w4Recip;
    var z = (+right.y - +upDirection.x) * w4Recip;
    var ret = $S00().Construct(x, y, z, w);
    return ret;
  }; 

  function Quaternion_Mult$0A (left, right) {
    return $S02().Construct($T00().op_Addition(
        $T00().op_Addition(
          $S05().CallStatic($T00(), "op_Multiply", null, 
            right.get_w(), 
            left.get_xyz().MemberwiseClone()
          ).MemberwiseClone(), 
          $S05().CallStatic($T00(), "op_Multiply", null, 
            left.get_w(), 
            right.get_xyz().MemberwiseClone()
          )
        ).MemberwiseClone(), 
        $T00().Cross(
          left.get_xyz().MemberwiseClone(), 
          right.get_xyz().MemberwiseClone()
        )
      ).MemberwiseClone(), ((+left.get_w() * +right.get_w()) - +$T00().Dot(
          left.get_xyz(), 
          right.get_xyz()
        )));
  }; 

  function Quaternion_Mult$0B (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct($T00().op_Addition(
          $T00().op_Addition(
            $S05().CallStatic($T00(), "op_Multiply", null, 
              (right.get()).get_w(), 
              (left.get()).get_xyz().MemberwiseClone()
            ).MemberwiseClone(), 
            $S05().CallStatic($T00(), "op_Multiply", null, 
              (left.get()).get_w(), 
              (right.get()).get_xyz().MemberwiseClone()
            )
          ).MemberwiseClone(), 
          $T00().Cross(
            (left.get()).get_xyz().MemberwiseClone(), 
            (right.get()).get_xyz().MemberwiseClone()
          )
        ).MemberwiseClone(), ((+(left.get()).get_w() * +(right.get()).get_w()) - +$T00().Dot(
            (left.get()).get_xyz(), 
            (right.get()).get_xyz()
          ))));
  }; 

  function Quaternion_Multiply$0C ($left, $right) {
    var right = new JSIL.BoxedVariable($right.MemberwiseClone());
    var left = new JSIL.BoxedVariable($left.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $S06().CallStatic($thisType, "Multiply", null, /* ref */ left, /* ref */ right, /* ref */ result);
    return result.get();
  }; 

  function Quaternion_Multiply$0D (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S00().Construct(((((+(left.get()).get_w() * +(right.get()).get_x()) + (+(left.get()).get_x() * +(right.get()).get_w())) + (+(left.get()).get_y() * +(right.get()).get_z())) - (+(left.get()).get_z() * +(right.get()).get_y())), ((((+(left.get()).get_w() * +(right.get()).get_y()) + (+(left.get()).get_y() * +(right.get()).get_w())) + (+(left.get()).get_z() * +(right.get()).get_x())) - (+(left.get()).get_x() * +(right.get()).get_z())), ((((+(left.get()).get_w() * +(right.get()).get_z()) + (+(left.get()).get_z() * +(right.get()).get_w())) + (+(left.get()).get_x() * +(right.get()).get_y())) - (+(left.get()).get_y() * +(right.get()).get_x())), ((((+(left.get()).get_w() * +(right.get()).get_w()) - (+(left.get()).get_x() * +(right.get()).get_x())) - (+(left.get()).get_y() * +(right.get()).get_y())) - (+(left.get()).get_z() * +(right.get()).get_z()))));
  }; 

  function Quaternion_Multiply$0E (/* ref */ quaternion, scale, /* ref */ result) {
    result.set($S00().Construct((+(quaternion.get()).get_x() * +scale), (+(quaternion.get()).get_y() * +scale), (+(quaternion.get()).get_z() * +scale), (+(quaternion.get()).get_w() * +scale)));
  }; 

  function Quaternion_Multiply$0F (quaternion, scale) {
    return $S00().Construct((+quaternion.get_x() * +scale), (+quaternion.get_y() * +scale), (+quaternion.get_z() * +scale), (+quaternion.get_w() * +scale));
  }; 

  function Quaternion_Normalize$10 () {
    var flag = +this.get_Length() <= 1.192093E-07;
    if (!flag) {
      var scale = +((1 / +this.get_Length()));
      (this.xyz = $S04().CallStatic($T00(), "op_Multiply", null, this.get_xyz().MemberwiseClone(), scale));
      this.set_w(+this.get_w() * scale);
    }
  }; 

  function Quaternion_Normalize$11 ($q) {
    var q = new JSIL.BoxedVariable($q);
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Normalize(/* ref */ q, /* ref */ result);
    return result.get();
  }; 

  function Quaternion_Normalize$12 (/* ref */ q, /* ref */ result) {
    var flag = +(q.get()).get_Length() <= 1.192093E-07;
    if (flag) {
      var scale = 0;
    } else {
      scale = +((1 / +(q.get()).get_Length()));
    }
    result.set($S02().Construct($S04().CallStatic($T00(), "op_Multiply", null, (q.get()).get_xyz().MemberwiseClone(), scale).MemberwiseClone(), (+(q.get()).get_w() * scale)));
  }; 

  function Quaternion_op_Addition (left, right) {
    (left.xyz = $T00().op_Addition(
        left.get_xyz().MemberwiseClone(), 
        right.get_xyz()
      ));
    left.set_w(+left.get_w() + +right.get_w());
    return left;
  }; 

  function Quaternion_op_Equality (left, right) {
    return left.Equals(right.MemberwiseClone());
  }; 

  function Quaternion_op_Inequality (left, right) {
    return !left.Equals(right.MemberwiseClone());
  }; 

  function Quaternion_op_Multiply$13 ($left, $right) {
    var right = new JSIL.BoxedVariable($right.MemberwiseClone());
    var left = new JSIL.BoxedVariable($left.MemberwiseClone());
    $S06().CallStatic($thisType, "Multiply", null, /* ref */ left, /* ref */ right, /* ref */ left);
    return left.get();
  }; 

  function Quaternion_op_Multiply$14 ($quaternion, scale) {
    var quaternion = new JSIL.BoxedVariable($quaternion.MemberwiseClone());
    $S07().CallStatic($thisType, "Multiply", null, /* ref */ quaternion, scale, /* ref */ quaternion);
    return quaternion.get();
  }; 

  function Quaternion_op_Multiply$15 (scale, quaternion) {
    return $S00().Construct((+quaternion.get_x() * +scale), (+quaternion.get_y() * +scale), (+quaternion.get_z() * +scale), (+quaternion.get_w() * +scale));
  }; 

  function Quaternion_op_Subtraction (left, right) {
    (left.xyz = $T00().op_Subtraction(
        left.get_xyz().MemberwiseClone(), 
        right.get_xyz()
      ));
    left.set_w(+left.get_w() - +right.get_w());
    return left;
  }; 

  function Quaternion_QuaternionToEuler (q, inDegrees) {
    q.Normalize();
    var test = 2 * ((+q.get_x() * +q.get_y()) + (+q.get_z() * +q.get_w()));
    if ($S08().CallStatic($T05(), "Equals", null, test, 1)) {
      var z = -2 * Math.fround(Math.atan2(q.get_x(), q.get_w()));
      var y = 0;
      var x = 1.57079637;
    } else {
      if ($S08().CallStatic($T05(), "Equals", null, test, -1)) {
        z = 2 * Math.fround(Math.atan2(q.get_x(), q.get_w()));
        y = 0;
        x = -1.57079637;
      } else {
        var sqX = +q.get_x() * +q.get_x();
        var sqY = +q.get_y() * +q.get_y();
        var sqZ = +q.get_z() * +q.get_z();
        var sqW = +q.get_w() * +q.get_w();
        y = Math.fround(Math.atan2(2 * ((+q.get_y() * +q.get_w()) - (+q.get_x() * +q.get_z())), (1 - (2 * sqY)) - (2 * sqZ)));
        x = Math.fround(Math.asin($S09().CallStatic($T05(), "Clamp", null, test, -1, 1)));
        z = Math.fround(Math.atan2(2 * ((+q.get_x() * +q.get_w()) - (+q.get_y() * +q.get_z())), (1 - (2 * sqX)) - (2 * sqZ)));
      }
    }

    for (y = 6.28318548 - y; y >= 6.28318548; y -= 6.28318548) {
    }

    for (; y <= -6.28318548; y += 6.28318548) {
    }
    if (inDegrees) {
      x = +$T05().RadiansToDegrees(x);
      y = +$T05().RadiansToDegrees(y);
      z = +$T05().RadiansToDegrees(z);
    }
    return $S01().Construct(x, y, z);
  }; 

  function Quaternion_QuaternionToMatrix (q) {
    q.Normalize();
    var result = new ($T08())();
    result.set_M11(1 - (2 * ((+q.get_y() * +q.get_y()) + (+q.get_z() * +q.get_z()))));
    result.set_M12(2 * ((+q.get_x() * +q.get_y()) + (+q.get_z() * +q.get_w())));
    result.set_M13(2 * ((+q.get_x() * +q.get_z()) - (+q.get_y() * +q.get_w())));
    result.set_M14(0);
    result.set_M21(2 * ((+q.get_x() * +q.get_y()) - (+q.get_z() * +q.get_w())));
    result.set_M22(1 - (2 * ((+q.get_x() * +q.get_x()) + (+q.get_z() * +q.get_z()))));
    result.set_M23(2 * ((+q.get_z() * +q.get_y()) + (+q.get_x() * +q.get_w())));
    result.set_M24(0);
    result.set_M31(2 * ((+q.get_x() * +q.get_z()) + (+q.get_y() * +q.get_w())));
    result.set_M32(2 * ((+q.get_y() * +q.get_z()) - (+q.get_x() * +q.get_w())));
    result.set_M33(1 - (2 * ((+q.get_x() * +q.get_x()) + (+q.get_y() * +q.get_y()))));
    result.set_M34(0);
    result.set_M41(0);
    result.set_M42(0);
    result.set_M43(0);
    result.set_M44(1);
    return result;
  }; 

  function Quaternion_set_w (value) {
    this._w = +value;
  }; 

  function Quaternion_set_x (value) {
    this._xyz.x = +value;
  }; 

  function Quaternion_set_xyz (value) {
    this._xyz = value.MemberwiseClone();
  }; 

  function Quaternion_set_y (value) {
    this._xyz.y = +value;
  }; 

  function Quaternion_set_z (value) {
    this._xyz.z = +value;
  }; 

  function Quaternion_Slerp (q1, q2, blend) {
    var result = new $thisType();
    var flag = +q1.get_LengthSquared() < 1.192093E-07;
    if (flag) {
      var flag2 = +q2.get_LengthSquared() < 1.192093E-07;
      if (flag2) {
        var result2 = $thisType.Identity.MemberwiseClone();
      } else {
        result2 = q2.MemberwiseClone();
      }
    } else {
      var flag3 = +q2.get_LengthSquared() < 1.192093E-07;
      if (flag3) {
        result2 = q1.MemberwiseClone();
      } else {
        var cosHalfAngle = (+q1.get_w() * +q2.get_w()) + +$T00().Dot(
          q1.get_xyz(), 
          q2.get_xyz()
        );
        var flag4 = (cosHalfAngle >= 1) || 
        (cosHalfAngle <= -1);
        if (flag4) {
          result2 = q1.MemberwiseClone();
        } else {
          var flag5 = cosHalfAngle < 0;
          if (flag5) {
            (q2.xyz = $T00().op_UnaryNegation(q2.get_xyz().MemberwiseClone()));
            q2.set_w(-q2.get_w());
            cosHalfAngle = -cosHalfAngle;
          }
          var flag6 = cosHalfAngle < 0.99995;
          if (flag6) {
            var halfAngle = Math.fround(Math.acos(cosHalfAngle));
            var sinHalfAngle = Math.fround(Math.sin(halfAngle));
            var oneOverSinHalfAngle = +((1 / sinHalfAngle));
            var blendA = Math.fround(Math.sin(halfAngle * (1 - +blend))) * oneOverSinHalfAngle;
            var blendB = Math.fround(Math.sin(halfAngle * +blend)) * oneOverSinHalfAngle;
          } else {
            blendA = 1 - +blend;
            blendB = +blend;
          }
          (result = result.MemberwiseClone(), 
            $thisType.prototype._ctor.call(result, 
              $T00().op_Addition(
                $S05().CallStatic($T00(), "op_Multiply", null, blendA, q1.get_xyz().MemberwiseClone()).MemberwiseClone(), 
                $S05().CallStatic($T00(), "op_Multiply", null, blendB, q2.get_xyz().MemberwiseClone())
              ).MemberwiseClone(), 
              (blendA * +q1.get_w()) + (blendB * +q2.get_w())
            ));
          result2 = (
            (+result.get_LengthSquared() > 1.192093E-07)
               ? $thisType.Normalize(result.MemberwiseClone())
               : $thisType.Identity)
          .MemberwiseClone();
        }
      }
    }
    return result2;
  }; 

  function Quaternion_Sub$16 (left, right) {
    return $S02().Construct($T00().op_Subtraction(
        left.get_xyz().MemberwiseClone(), 
        right.get_xyz()
      ).MemberwiseClone(), (+left.get_w() - +right.get_w()));
  }; 

  function Quaternion_Sub$17 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct($T00().op_Subtraction(
          (left.get()).get_xyz().MemberwiseClone(), 
          (right.get()).get_xyz()
        ).MemberwiseClone(), (+(left.get()).get_w() - +(right.get()).get_w())));
  }; 

  function Quaternion_ToAxisAngle$18 (/* ref */ axis, /* ref */ angle) {
    var result = this.ToAxisAngle();
    axis.set(result.get_xyz().MemberwiseClone());
    angle.set(result.w);
  }; 

  function Quaternion_ToAxisAngle$19 () {
    var q = this;
    var flag = +q.get_w() > 1;
    if (flag) {
      q.Normalize();
    }
    var float = new ($T09())();
    float.w = 2 * Math.fround(Math.acos(q.get_w()));
    var result = float.MemberwiseClone();
    var den = Math.fround(Math.sqrt((1 - +q.get_w() * +q.get_w())));
    if (den > 1.192093E-07) {
      (result.xyz = $T00().op_Division(q.get_xyz().MemberwiseClone(), den).MemberwiseClone());
    } else {
      (result.xyz = $T00().UnitX.MemberwiseClone());
    }
    return result;
  }; 

  function Quaternion_toString () {
    return $T0A().Format("V: {0}, w: {1}", JSIL.Array.New($T03(), [this.get_xyz(), $T01().$Box(this.get_w())]));
  }; 

  JSIL.MakeType({
      BaseType: $asm15.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.Core.Quaternion", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 4, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("Fusee.Math.Core.float3"), $.Single]), 
      Quaternion__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single
        ]), 
      Quaternion__ctor$01
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      Quaternion_Add$02
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      Quaternion_Add$03
    );

    $.Method({Static:false, Public:true }, "Conjugate", 
      JSIL.MethodSignature.Void, 
      Quaternion_Conjugate$04
    );

    $.Method({Static:true , Public:true }, "Conjugate", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      Quaternion_Conjugate$05
    );

    $.Method({Static:true , Public:true }, "Conjugate", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      Quaternion_Conjugate$06
    );

    $.Method({Static:true , Public:true }, "CopySign", 
      new JSIL.MethodSignature($.Single, [$.Single, $.Single]), 
      Quaternion_CopySign
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      Quaternion_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type]), 
      Quaternion_Equals$07
    );

    $.Method({Static:true , Public:true }, "EulerToQuaternion", 
      new JSIL.MethodSignature($.Type, [$asm07.TypeRef("Fusee.Math.Core.float3"), $.Boolean]), 
      Quaternion_EulerToQuaternion
    );

    $.Method({Static:true , Public:true }, "FromAxisAngle", 
      new JSIL.MethodSignature($.Type, [$asm07.TypeRef("Fusee.Math.Core.float3"), $.Single]), 
      Quaternion_FromAxisAngle
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      JSIL.MethodSignature.Return($.Single), 
      Quaternion_get_Length
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      JSIL.MethodSignature.Return($.Single), 
      Quaternion_get_LengthSquared
    );

    $.Method({Static:false, Public:true }, "get_w", 
      JSIL.MethodSignature.Return($.Single), 
      Quaternion_get_w
    );

    $.Method({Static:false, Public:true }, "get_x", 
      JSIL.MethodSignature.Return($.Single), 
      Quaternion_get_x
    );

    $.Method({Static:false, Public:true }, "get_xyz", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float3")), 
      Quaternion_get_xyz
    );

    $.Method({Static:false, Public:true }, "get_y", 
      JSIL.MethodSignature.Return($.Single), 
      Quaternion_get_y
    );

    $.Method({Static:false, Public:true }, "get_z", 
      JSIL.MethodSignature.Return($.Single), 
      Quaternion_get_z
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      Quaternion_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Invert", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      Quaternion_Invert$08
    );

    $.Method({Static:true , Public:true }, "Invert", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      Quaternion_Invert$09
    );

    $.Method({Static:true , Public:true }, "LookRotation", 
      new JSIL.MethodSignature($.Type, [$asm07.TypeRef("Fusee.Math.Core.float3"), $asm07.TypeRef("Fusee.Math.Core.float3")]), 
      Quaternion_LookRotation
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      Quaternion_Mult$0A
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use Multiply instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      Quaternion_Mult$0B
    )
      .Attribute($asm15.TypeRef("System.ObsoleteAttribute"), function () { return ["Use Multiply instead."]; });

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      Quaternion_Multiply$0C
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      Quaternion_Multiply$0D
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      Quaternion_Multiply$0E
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      Quaternion_Multiply$0F
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      JSIL.MethodSignature.Void, 
      Quaternion_Normalize$10
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      Quaternion_Normalize$11
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      Quaternion_Normalize$12
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      Quaternion_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      Quaternion_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      Quaternion_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      Quaternion_op_Multiply$13
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      Quaternion_op_Multiply$14
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Single, $.Type]), 
      Quaternion_op_Multiply$15
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      Quaternion_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "QuaternionToEuler", 
      new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float3"), [$.Type, $.Boolean]), 
      Quaternion_QuaternionToEuler
    );

    $.Method({Static:true , Public:true }, "QuaternionToMatrix", 
      new JSIL.MethodSignature($asm07.TypeRef("Fusee.Math.Core.float4x4"), [$.Type]), 
      Quaternion_QuaternionToMatrix
    );

    $.Method({Static:false, Public:true }, "set_w", 
      JSIL.MethodSignature.Action($.Single), 
      Quaternion_set_w
    );

    $.Method({Static:false, Public:true }, "set_x", 
      JSIL.MethodSignature.Action($.Single), 
      Quaternion_set_x
    );

    $.Method({Static:false, Public:true }, "set_xyz", 
      JSIL.MethodSignature.Action($asm07.TypeRef("Fusee.Math.Core.float3")), 
      Quaternion_set_xyz
    );

    $.Method({Static:false, Public:true }, "set_y", 
      JSIL.MethodSignature.Action($.Single), 
      Quaternion_set_y
    );

    $.Method({Static:false, Public:true }, "set_z", 
      JSIL.MethodSignature.Action($.Single), 
      Quaternion_set_z
    );

    $.Method({Static:true , Public:true }, "Slerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Single
        ]), 
      Quaternion_Slerp
    );

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      Quaternion_Sub$16
    );

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      Quaternion_Sub$17
    );

    $.Method({Static:false, Public:true }, "ToAxisAngle", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$asm07.TypeRef("Fusee.Math.Core.float3")]), $jsilcore.TypeRef("JSIL.Reference", [$.Single])]), 
      Quaternion_ToAxisAngle$18
    );

    $.Method({Static:false, Public:true }, "ToAxisAngle", 
      JSIL.MethodSignature.Return($asm07.TypeRef("Fusee.Math.Core.float4")), 
      Quaternion_ToAxisAngle$19
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      Quaternion_toString
    );

    $.Field({Static:false, Public:false}, "_xyz", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Field({Static:false, Public:false}, "_w", $.Single);

    $.Field({Static:true , Public:true }, "Identity", $.Type);


    function Quaternion__cctor () {
      $thisType.Identity = new $thisType();
      $thisType.Identity = $S00().Construct(0, 0, 0, 1);
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      Quaternion__cctor
    );

    $.Property({Static:false, Public:true }, "xyz", $asm07.TypeRef("Fusee.Math.Core.float3"));

    $.Property({Static:false, Public:true }, "x", $.Single);

    $.Property({Static:false, Public:true }, "y", $.Single);

    $.Property({Static:false, Public:true }, "z", $.Single);

    $.Property({Static:false, Public:true }, "w", $.Single);

    $.Property({Static:false, Public:true }, "Length", $.Single);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Single);

    $.ImplementInterfaces(
      /* 0 */ $asm15.TypeRef("System.IEquatable`1", [$.Type])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

